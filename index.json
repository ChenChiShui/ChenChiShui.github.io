
[{"content":" 文章分类 # ","date":"2025 年 2 月 12 日","externalUrl":null,"permalink":"/categories/","section":"","summary":"","title":"","type":"categories"},{"content":" 最近文章 # ","date":"2025 年 2 月 12 日","externalUrl":null,"permalink":"/posts/","section":"","summary":"","title":"","type":"posts"},{"content":" 文章标签 # ","date":"2025 年 2 月 12 日","externalUrl":null,"permalink":"/tags/","section":"","summary":"","title":"","type":"tags"},{"content":" 本博客部分写自 2023 年，与 2025 年初重置。 由于本人经常忘记二分查找的要点，因此便对其进行了整理总结。\n大量参考了 yxc 和 0x3f 的教学内容。\n前言 # 二分查找在面试与竞赛中都十分常见。\n虽然算法难度不高。但不熟练的情况下会很容易出现边界错误而浪费时间。\n在复杂的综合题中，也可以会忘记使用二分查找，而导致超时。\n二分模板 # 二分最经典的情景，在单调数组中找目标值。\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e 原题链接：点击这里访问 # 第一个大于等于 target 的位置 # 等价于最常用的 lower_bound(a.begin(), a.end(), target) l = 0 r = n - 1 while l \u0026lt; r : mid = l + r \u0026gt;\u0026gt; 1 if nums[mid] \u0026lt; target: l = mid + 1 else: r = mid return l # 第一个大于 target 的位置 # 等价于 upper_bound(a.begin(), a.end(), target) l = 0 r = n - 1 while l \u0026lt; r : mid = l + r \u0026gt;\u0026gt; 1 if nums[mid] \u0026lt;= target: l = mid + 1 else: r = mid return l # 最后一个小于等于 target 的位置 # 等价于的 lower_bound(a.begin(), a.end(), target, greater\u0026lt;int\u0026gt;()) l = 0 r = n - 1 while l \u0026lt; r : mid = l + r + 1 \u0026gt;\u0026gt; 1 if nums[mid] \u0026lt; target: l = mid else: r = mid - 1 return l # 最后一个小于 target 的位置 # 等价于最常用的 upper_bound(a.begin(), a.end(), target, greater\u0026lt;int\u0026gt;()) l = 0 r = n - 1 while l \u0026lt; r : mid = l + r + 1 \u0026gt;\u0026gt; 1 if nums[mid] \u0026lt;= target: l = mid else: r = mid - 1 return l 二分的库函数 # 对于 C++ 而言：\n#include\u0026lt;bits/stdc++.h\u0026gt; #include\u0026lt;algorithm\u0026gt; // 具体头文件 vector\u0026lt;int\u0026gt; a = {1, 2, 3, 4, 4, 5, 6}; int target = 4; // 对 vector 二分，库返回的是迭代器 auto it1 = lower_bound(a.begin(), a.end(), target); auto it2 = upper_bound(a.begin(), a.end(), target); // 其实 greater 就是把数组反过来查找 auto it3 = lower_bound(a.begin(), a.end(), target, greater\u0026lt;int\u0026gt;()); auto it4 = upper_bound(a.begin(), a.end(), target, greater\u0026lt;int\u0026gt;()); int pos = it1 - a.begin(); 对于 python 而言：\nimport bisect a = [1, 2, 3, 4, 4, 5, 6] target = 4 # 分别对应 lower_bound 和 upper_bound pos1 = bisect.bisect_left(a, target) pos2 = bisect.bisect_right(a, target) # Python 没有原生的降序 bisect，只能自己写下面两个 二分答案 # 根据经验，当题目中出现求最小、求最大、最大化最小、最小化最大时，很有可能要对答案进行二分查找。\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e 灵茶山艾府总结：点击这里访问 在二分答案时候，要时刻注意：\nr 的初始值是什么？即答案的上界。（如果在比赛中，上界开大一些更稳妥）\ncheck() 条件对应的边界是哪种？\n一般而言，check(int x) 按正常的 bool 逻辑写。 即 x 满足条件为 true，不满足为 false。 而在 while 查找中，用 !check()，代替第一种二分的 if 条件。 问题有没有单调性，能不能用二分？\n如果没有单调性，一般是 DP 或 搜索。 绝大部分二分答案的上界都在 int 范围外\n因此千万别忘了 mid 开 long long\n求最小 - 修车的最少时间： # \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e 原题链接：点击这里访问 给你一个整数数组 ranks ，表示一些机械工的 能力值 。ranksi 是第 i 位机械工的能力值。能力值为 r的机械工可以在 r * n2 分钟内修好 n 辆车。\n同时给你一个整数 cars ，表示总共需要修理的汽车数目。\n请你返回修理所有汽车 最少 需要多少时间。\n**注意：**所有机械工可以同时修理汽车。\n示例 1：\n输入：ranks = [4,2,3,1], cars = 10 输出：16 解释： - 第一位机械工修 2 辆车，需要 4 * 2 * 2 = 16 分钟。 - 第二位机械工修 2 辆车，需要 2 * 2 * 2 = 8 分钟。 - 第三位机械工修 2 辆车，需要 3 * 2 * 2 = 12 分钟。 - 第四位机械工修 4 辆车，需要 1 * 4 * 4 = 16 分钟。 16 分钟是修理完所有车需要的最少时间。 示例 2：\n输入：ranks = [5,1,8], cars = 6 输出：16 解释： - 第一位机械工修 1 辆车，需要 5 * 1 * 1 = 5 分钟。 - 第二位机械工修 4 辆车，需要 1 * 4 * 4 = 16 分钟。 - 第三位机械工修 1 辆车，需要 8 * 1 * 1 = 8 分钟。 16 分钟时修理完所有车需要的最少时间。 提示：\n1 \u0026lt;= ranks.length \u0026lt;= 105 1 \u0026lt;= ranks[i] \u0026lt;= 100 1 \u0026lt;= cars \u0026lt;= 106 题解：\n# 经典二分答案 class Solution: def repairCars(self, ranks: List[int], cars: int) -\u0026gt; int: def check(x : int) -\u0026gt; bool: car_num = 0 for rank in ranks: car_num += int(sqrt(x / rank)) return car_num \u0026gt;= cars l, r = 0, int(1e15) while l \u0026lt; r: mid = l + r \u0026gt;\u0026gt; 1 if not check(mid): l = mid + 1 else: r = mid return l 最小化最大 - 袋子里最少数目的球： # \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e 原题链接：点击这里访问 给你一个整数数组 nums ，其中 nums[i] 表示第 i 个袋子里球的数目。同时给你一个整数maxOperations 。\n你可以进行如下操作至多 maxOperations 次：\n选择任意一个袋子，并将袋子里的球分到 2 个新的袋子中，每个袋子里都有正整数个球。 比方说，一个袋子里有 5 个球，你可以把它们分到两个新袋子里，分别有 1 个和 4 个球，或者分别有 2 个和 3 个球。 你的开销是单个袋子里球数目的 最大值 ，你想要 最小化 开销。\n请你返回进行上述操作后的最小开销。\n示例 1：\n输入：nums = [9], maxOperations = 2 输出：3 解释： - 将装有 9 个球的袋子分成装有 6 个和 3 个球的袋子。[9] -\u0026gt; [6,3] 。 - 将装有 6 个球的袋子分成装有 3 个和 3 个球的袋子。[6,3] -\u0026gt; [3,3,3] 。 装有最多球的袋子里装有 3 个球，所以开销为 3 并返回 3 。 示例 2：\n输入：nums = [2,4,8,2], maxOperations = 4 输出：2 解释： - 将装有 8 个球的袋子分成装有 4 个和 4 个球的袋子。[2,4,8,2] -\u0026gt; [2,4,4,4,2] 。 - 将装有 4 个球的袋子分成装有 2 个和 2 个球的袋子。[2,4,4,4,2] -\u0026gt; [2,2,2,4,4,2] 。 - 将装有 4 个球的袋子分成装有 2 个和 2 个球的袋子。[2,2,2,4,4,2] -\u0026gt; [2,2,2,2,2,4,2] 。 - 将装有 4 个球的袋子分成装有 2 个和 2 个球的袋子。[2,2,2,2,2,4,2] -\u0026gt; [2,2,2,2,2,2,2,2] 。 装有最多球的袋子里装有 2 个球，所以开销为 2 并返回 2 。 示例 3：\n输入：nums = [7,17], maxOperations = 2 输出：7 提示：\n1 \u0026lt;= nums.length \u0026lt;= 105 1 \u0026lt;= maxOperations, nums[i] \u0026lt;= 109 题解：\nclass Solution: def minimumSize(self, nums: List[int], maxOperations: int) -\u0026gt; int: def check(x : int) -\u0026gt; bool: if x == 0: return False operation = 0 for num in nums: if num \u0026gt; x: operation += (num + x - 1) // x - 1 # 向上取整后减一 return operation \u0026lt;= maxOperations l, r = 0, int(1e9) while l \u0026lt; r: mid = l + r \u0026gt;\u0026gt; 1 if not check(mid): l = mid + 1 else: r = mid return l 最大化最小 - 范围内整数的最大得分： # \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e 原题链接：点击这里访问 给你一个整数数组 start 和一个整数 d，代表 n 个区间 [start[i], start[i] + d]。\n你需要选择 n 个整数，其中第 i 个整数必须属于第 i 个区间。所选整数的 得分 定义为所选整数两两之间的最小 绝对差。\n返回所选整数的 最大可能得分 。\n示例 1：\n输入： start = [6,0,3], d = 2\n输出： 4\n解释：\n可以选择整数 8, 0 和 4 获得最大可能得分，得分为 min(|8 - 0|, |8 - 4|, |0 - 4|)，等于 4。\n示例 2：\n输入： start = [2,6,13,13], d = 5\n输出： 5\n解释：\n可以选择整数 2, 7, 13 和 18 获得最大可能得分，得分为 min(|2 - 7|, |2 - 13|, |2 - 18|, |7 - 13|, |7 - 18|, |13 - 18|)，等于 5。\n提示：\n2 \u0026lt;= start.length \u0026lt;= 105 0 \u0026lt;= start[i] \u0026lt;= 109 0 \u0026lt;= d \u0026lt;= 109 题解：\n// 24.9.8 注释： 对二分板子不熟悉 导致花了很长时间 class Solution { public: bool check(int mid, vector\u0026lt;int\u0026gt;\u0026amp; start, int d) { int n = start.size(); long long mn = start[0]; for (int i = 1; i \u0026lt; n; i++) { // 改了一个小时没改出来 max 这行 还得多学学 mn = max(1LL * start[i], mn + mid); if (mn \u0026lt;= start[i] + d) { continue; } return false; } return true; } int maxPossibleScore(vector\u0026lt;int\u0026gt;\u0026amp; start, int d) { int n = start.size(); sort(start.begin(), start.end()); // 上边界二分的写法不能忘啊 long long l = 0, r = long(2e9); while (l \u0026lt; r) { long long mid = l + r + 1 \u0026gt;\u0026gt; 1; if (!check(mid, start, d)) { r = mid - 1; } else { l = mid; } } return l; } }; 二分作为解题步骤之一 # 二分经常作为解题中的某一步，经常和其他算法结合考察。\n前缀和 - 青蛙过河 # 原题链接：点击这里访问 小青蛙住在一条河边，它想到河对岸的学校去学习。\n小青蛙打算经过河里的石头跳到对岸。\n河里的石头排成了一条直线，小青蛙每次跳跃必须落在一块石头或者岸上。\n不过，每块石头有一个高度，每次小青蛙从一块石头起跳，这块石头的高度就会下降 1，当石头的高度下降到 0 时小青蛙不能再跳到这块石头上（某次跳跃后使石头高度下降到 0 是允许的）。\n小青蛙一共需要去学校上 x 天课，所以它需要往返 2x 次。 当小青蛙具有一个跳跃能力 y 时，它能跳不超过 y 的距离。 请问小青蛙的跳跃能力至少是多少才能用这些石头上完 x 次课。\n输入格式\n输入的第一行包含两个整数 n, x，分别表示河的宽度和小青蛙需要去学校的天数。请注意 2x 才是实际过河的次数。\n第二行包含 n−1 个非负整数 H1, H2, ⋅⋅⋅, Hn−1，其中 Hi \u0026gt; 0 表示在河中与小青蛙的家相距 i 的地方有一块高度为 Hi 的石头，Hi = 0 表示这个位置没有石头。\n输出格式\n输出一行，包含一个整数，表示小青蛙需要的最低跳跃能力。\n数据范围\n对于所有评测用例，1 ≤ n ≤ 10⁵, 1 ≤ x ≤ 10⁹, 0 ≤ Hi ≤ 10⁴。\n输入样例\n5 1 1 0 1 0 输出样例\n4 样例解释\n由于只有两块高度为 1 的石头，所以往返只能各用一块。\n第 1 块石头和对岸的距离为 4，如果小青蛙的跳跃能力为 3 则无法满足要求。\n所以小青蛙最少需要 4 的跳跃能力。\n题解\n// 找规律 + 前缀和 + 二分查找 // 核心是先找到为了让青蛙能踩到对应的石头，满足 i 块到 i + step 块石头的和大于 2 * x 即可 // 多次求区间之和自然想到前缀和 // 多次求位置的 step 并且符合二段性 自然考虑二分查找 // 此题要实现的细节挺多的 要注意 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n, x; vector\u0026lt;int\u0026gt;stone; vector\u0026lt;long long\u0026gt;prefix; bool check(int step) { // 注意上界为 n - step for (int i = 0; i \u0026lt; n - step + 1; i++) { if (prefix[i + step] - prefix[i] \u0026lt; 2 * x) { return false; } } return true; } int main () { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; x; n--; stone.resize(n); for (int i = 0; i \u0026lt; n ;i++) { cin \u0026gt;\u0026gt; stone[i]; } prefix.resize(n + 1); prefix[0] = 0; for (int i = 1; i \u0026lt;= n; i++) { prefix[i] = prefix[i - 1] + stone[i - 1]; //\tcout \u0026lt;\u0026lt; prefix[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } int l = 0, r = n + 100; while(l \u0026lt; r) { int mid = l + r \u0026gt;\u0026gt; 1; //\tcout \u0026lt;\u0026lt; mid \u0026lt;\u0026lt; \u0026#34; \u0026#34;; if (!check(mid)) l = mid + 1; else r = mid; } cout \u0026lt;\u0026lt; l; return 0; } ","date":"2025 年 2 月 12 日","externalUrl":null,"permalink":"/posts/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%80%BB%E7%BB%93%E4%B8%8E%E4%BE%8B%E9%A2%98/","section":"","summary":"","title":"“二分查找” 总结与例题","type":"posts"},{"content":"","date":"2025 年 2 月 12 日","externalUrl":null,"permalink":"/","section":"陈驰水-个人博客","summary":"","title":"陈驰水-个人博客","type":"page"},{"content":"","date":"2025 年 2 月 12 日","externalUrl":null,"permalink":"/tags/%E4%BA%8C%E5%88%86/","section":"","summary":"","title":"二分","type":"tags"},{"content":"","date":"2025 年 2 月 12 日","externalUrl":null,"permalink":"/tags/%E6%A8%A1%E6%9D%BF/","section":"","summary":"","title":"模板","type":"tags"},{"content":"","date":"2025 年 2 月 12 日","externalUrl":null,"permalink":"/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","section":"","summary":"","title":"算法与数据结构","type":"categories"},{"content":"","date":"2025 年 2 月 10 日","externalUrl":null,"permalink":"/tags/%E5%8D%9A%E5%BC%88/","section":"","summary":"","title":"博弈","type":"tags"},{"content":" \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e 原题链接：点击这里访问 猫和老鼠 题干 # 两位玩家分别扮演猫和老鼠，在一张无向图上进行游戏，两人轮流行动。\n图的形式是：graph[a] 是一个列表，由满足 ab 是图中的一条边的所有节点 b 组成。\n老鼠从节点 1 开始，第一个出发；猫从节点 2 开始，第二个出发。在节点 0 处有一个洞。\n在每个玩家的行动中，他们必须沿着图中与所在当前位置连通的一条边移动。例如，如果老鼠在节点 1 ，那么它必须移动到 graph[1] 中的任一节点。\n此外，猫无法移动到洞中（节点 0）。\n然后，游戏在出现以下三种情形之一时结束：\n如果猫和老鼠出现在同一个节点，猫获胜。 如果老鼠到达洞中，老鼠获胜。 = 如果某一位置重复出现（即，玩家的位置和移动顺序都与上一次行动相同），游戏平局。 给你一张图 graph ，并假设两位玩家都都以最佳状态参与游戏：\n如果老鼠获胜，则返回 1； 如果猫获胜，则返回 2； 如果平局，则返回 0 。 示例 1：\n输入：graph = [[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]] 输出：0 示例 2：\n输入：graph = [[1,3],[0],[3],[0,2]] 输出：1\n提示：\n3 \u0026lt;= graph.length \u0026lt;= 50 1 \u0026lt;= graph[i].length \u0026lt; graph.length 0 \u0026lt;= graph[i][j] \u0026lt; graph.length graph[i][j] != i graph[i] 互不相同 猫和老鼠在游戏中总是可以移动 博弈 前置知识 # 显然此题和博弈有关。先回忆最简单的博弈：NIM 游戏。\n给定 N 堆石子，第 i 堆有 ai 个石子。\n两名玩家轮流行动，每次在一堆石子中取若干个，不能不取，最后不能取的人输。\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e 原题链接：点击这里访问 简单来说，在公平博弈中，己方的最优策略是通过将对方引入其必败状态来确保胜利。\n核心思想是，在假设双方都采用最优策略的情况下：\n如果从某个状态可以到达至少一个对方必败状态，那么该状态对于己方就是必胜的。\n反之，如果无法到达任何对方必败状态，则该状态对己方就是必败的。\n如果游戏存在平局，则无法在确认必胜或必负的情况就是平局。\n对于该前置内容，我在24年初写过一道蓝桥杯的题，连接贴在下面可以参考：\n原题链接：点击这里访问 灭鼠先锋是一个老少咸宜的棋盘小游戏，由两人参与，轮流操作。\n灭鼠先锋的棋盘有各种规格，本题中游戏在两行四列的棋盘上进行。游戏的规则为：两人轮流操作，每次可选择在棋盘的一个空位上放置一个棋子，或在同一行的连续两个空位上各放置一个棋子，放下棋子后使棋盘放满的一方输掉游戏。\n小蓝和小乔一起玩游戏，小蓝先手，小乔后手。小蓝可以放置棋子的方法很多，通过旋转和翻转可以对应如下四种情况：\nXOOO XXOO OXOO OXXO OOOO OOOO OOOO OOOO 其中 O 表示棋盘上的一个方格为空，X 表示该方格已经放置了棋子。\n请问，对于以上四种情况，如果小蓝和小乔都是按照对自己最优的策略来玩游戏，小蓝是否能获胜。如果获胜，请用 V 表示，否则用 L 表示。请将四种情况的胜负结果按顺序连接在一起提交。\n24年题解如下\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; bool check(string s){//判断是否只有一个O int cnt = 0; for(auto i : s){ cnt += i==\u0026#39;O\u0026#39;; } return cnt == 1; } unordered_map\u0026lt;string, bool\u0026gt;mp; bool dfs(string s){ if(mp.count(s))return mp[s]; if(check(s)){//当当前状态只有一个O时标记为必败态 mp[s] = false; return false; } // 核心思路是只有遍历能到达一个必败态，此态就是必胜的（两人都是最优策略） // 如果一个必败态都无法到达，此态就是必败的 // 进行记忆化搜素 // 放置一个 for(int i = 0; i \u0026lt; s.size(); i ++){ if(s[i] == \u0026#39;O\u0026#39;){ string tmp = s; tmp[i] = \u0026#39;X\u0026#39;; if(dfs(tmp) == false){ mp[s] = true; return true; } } } // 放置两个 for(int i = 0; i \u0026lt; s.size(); i ++){ if(s[i] == \u0026#39;O\u0026#39; \u0026amp;\u0026amp; s[i+1] == \u0026#39;O\u0026#39; \u0026amp;\u0026amp; i != 3){ string tmp = s; tmp[i] = \u0026#39;X\u0026#39;; tmp[i+1] = \u0026#39;X\u0026#39;; if(dfs(tmp) == false){ mp[s] = true; return true; } } } mp[s] = false; return false; } int main() { dfs(\u0026#34;OOOOOOOO\u0026#34;); dfs(\u0026#34;XOOOOOOO\u0026#34;); dfs(\u0026#34;OXOOOOOO\u0026#34;); dfs(\u0026#34;XXOOOOOO\u0026#34;); dfs(\u0026#34;OXXOOOOO\u0026#34;); cout \u0026lt;\u0026lt; mp[\u0026#34;OXXOOOOO\u0026#34;] \u0026lt;\u0026lt; endl; return 0; } 记忆化搜索 # 一般而言，博弈问题可以转化为搜索问题。显然在博弈过程中会有大量重复子问题，因此往往会引入记忆化搜索。\n对于该题，很容易思考到搜索的前两个参数：猫位置与鼠位置。而第三个参数则有两种可能的写法，即 bool 类型表示现在是哪方的回合，以及 int 类型表示当前第几回合。\n而初始状态为：\n老鼠成功进洞，即 dp[0][j][1] = 1 （贪心可知，老鼠赢的下一回合一定是猫的回合） 猫捉到老鼠，即 dp[i][i][1] = 2 dp[i][i][0] = 2 如果想用 bool 类型表示回合，就又引出了新的问题。在无法确定回合数的情况下，如果不加上其他限制，对于平局会进入无限循环的搜索。\n但是对于 int 类型表示回合数，在此题的时间复杂度是不够的：\n在本题中，猫和鼠的数据范围都是 n 。如果第三个参数为上述的 int 行，其上界为： \\( 2 \\times n^2 \\) 则搜索状态为 \\( O(n^4) \\)，而此题的初始状态数上述提到过了是 n ，因此总复杂度为： \\( O(n^5) \\) 不能满足时间要求。\n根据上面的分析，此题的问题变为：在使用 bool 表示当前是谁的回合时，如何避免出现无限循环的搜索并尽可能剪枝。\n对于回合数作为第三个参数时的官方题解如下：\nclass Solution { public: const int MOUSE_TURN = 0, CAT_TURN = 1; const int DRAW = 0, MOUSE_WIN = 1, CAT_WIN = 2; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; graph; vector\u0026lt;vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026gt; degrees; vector\u0026lt;vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026gt; results; int catMouseGame(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; graph) { int n = graph.size(); this-\u0026gt;graph = graph; this-\u0026gt;degrees = vector\u0026lt;vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026gt;(n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;(n, vector\u0026lt;int\u0026gt;(2))); this-\u0026gt;results = vector\u0026lt;vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026gt;(n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;(n, vector\u0026lt;int\u0026gt;(2))); queue\u0026lt;tuple\u0026lt;int, int, int\u0026gt;\u0026gt; qu; for (int i = 0; i \u0026lt; n; i++) { for (int j = 1; j \u0026lt; n; j++) { degrees[i][j][MOUSE_TURN] = graph[i].size(); degrees[i][j][CAT_TURN] = graph[j].size(); } } for (int node : graph[0]) { for (int i = 0; i \u0026lt; n; i++) { degrees[i][node][CAT_TURN]--; } } for (int j = 1; j \u0026lt; n; j++) { results[0][j][MOUSE_TURN] = MOUSE_WIN; results[0][j][CAT_TURN] = MOUSE_WIN; qu.emplace(0, j, MOUSE_TURN); qu.emplace(0, j, CAT_TURN); } for (int i = 1; i \u0026lt; n; i++) { results[i][i][MOUSE_TURN] = CAT_WIN; results[i][i][CAT_TURN] = CAT_WIN; qu.emplace(i, i, MOUSE_TURN); qu.emplace(i, i, CAT_TURN); } while (!qu.empty()) { auto [mouse, cat, turn] = qu.front(); qu.pop(); int result = results[mouse][cat][turn]; vector\u0026lt;tuple\u0026lt;int, int, int\u0026gt;\u0026gt; prevStates = GetPrevStates(mouse, cat, turn); for (auto \u0026amp; [prevMouse, prevCat, prevTurn] : prevStates) { if (results[prevMouse][prevCat][prevTurn] == DRAW) { bool canWin = (result == MOUSE_WIN \u0026amp;\u0026amp; prevTurn == MOUSE_TURN) || (result == CAT_WIN \u0026amp;\u0026amp; prevTurn == CAT_TURN); if (canWin) { results[prevMouse][prevCat][prevTurn] = result; qu.emplace(prevMouse, prevCat, prevTurn); } else if (--degrees[prevMouse][prevCat][prevTurn] == 0) { int loseResult = prevTurn == MOUSE_TURN ? CAT_WIN : MOUSE_WIN; results[prevMouse][prevCat][prevTurn] = loseResult; qu.emplace(prevMouse, prevCat, prevTurn); } } } } return results[1][2][MOUSE_TURN]; } vector\u0026lt;tuple\u0026lt;int, int, int\u0026gt;\u0026gt; GetPrevStates(int mouse, int cat, int turn) { vector\u0026lt;tuple\u0026lt;int, int, int\u0026gt;\u0026gt; prevStates; int prevTurn = turn == MOUSE_TURN ? CAT_TURN : MOUSE_TURN; if (prevTurn == MOUSE_TURN) { for (int \u0026amp; prev : graph[mouse]) { prevStates.emplace_back(prev, cat, prevTurn); } } else { for (int \u0026amp; prev : graph[cat]) { if (prev != 0) { prevStates.emplace_back(mouse, prev, prevTurn); } } } return prevStates; } }; 拓扑排序 前置知识 # 此题说是用到拓扑排序并不准确，更应该说是用到拓扑排序的“ 入度表 ”的思想。\n入度表 记录 每个节点被指向的次数。\n使用 队列 处理 入度为 0 的节点。\n不断删除已处理的节点，更新 入度表。\n若无法遍历所有节点，则存在环。\n时间复杂度 O(n + m)，适用于 有向无环图（DAG）。\n对于该拓扑排序前置知识，可以参考下面：\n任务拓扑排序 # 一个工程被分解成n个子任务，编号为0至n-1。要完成整个工程需要完成所有的子任务。其中一些子任务必须先于另外一些子任务被完成。给定各子任务之间的先后关系，请编写程序给出一个合理的任务完成顺序，若工程不可行，程序亦能识别。\n输入第一行为两个整数n和e，均不超过100。n表示子任务数。接下来e行，表示已知的两个子任务间的先后关系，每行为两个整数a和b，表示任务a必须先于任务b完成。\n若工程不可行（一些子任务以自己为先决条件），输出“unworkable project”；若工程可行，输出为1行整数，每个整数后一个空格，为n个子任务的编号，表示子任务的完成顺序，如果有多种可能的顺序，则输出字典序最小者。\n注：字典序，即对象在字典中的顺序。对于两个数字序列，从第一个数字开始比较，当某一个位置的数字不同时，该位置数字较小的序列，字典序较小，例如1 2 3 9比1 2 4 5小，1 2 8 9比1 2 10 3小。\n样例1：\n3 2 0 1 1 2 0 1 2 样例2：\n3 3 0 1 1 2 2 0 unworkable project ANSWER # #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; graph(n); vector\u0026lt;int\u0026gt; inDegree(n, 0); // 记录每个节点的入度 // 读取边信息 for (int i = 0; i \u0026lt; m; i++) { int from, to; cin \u0026gt;\u0026gt; from \u0026gt;\u0026gt; to; graph[from].push_back(to); inDegree[to]++; // 目标节点的入度增加 } // 小顶堆（优先队列）保证字典序最小 priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; q; // 将所有入度为 0 的节点入队 for (int i = 0; i \u0026lt; n; i++) { if (inDegree[i] == 0) { q.push(i); } } vector\u0026lt;int\u0026gt; topoOrder; // 记录拓扑排序结果 while (!q.empty()) { int node = q.top(); q.pop(); topoOrder.push_back(node); for (int neighbor : graph[node]) { inDegree[neighbor]--; // 删除当前节点的出边 if (inDegree[neighbor] == 0) { // 若入度变为 0，则加入队列 q.push(neighbor); } } } // 如果排序结果中的节点数小于总节点数，说明有环 if (topoOrder.size() \u0026lt; n) { cout \u0026lt;\u0026lt; \u0026#34;unworkable project\u0026#34; \u0026lt;\u0026lt; endl; } else { for (int node : topoOrder) { cout \u0026lt;\u0026lt; node \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } } return 0; } 动态规划 # 那么在这道题中，如果为所有状态添加一个入度表，就可以做到上述的剪枝。\n同样的，我们选择自顶向下，初始状态为：\n老鼠成功进洞，即 result[0][j][1] = 1 （贪心可知，老鼠赢的下一回合一定是猫的回合） 猫捉到老鼠，即 result[i][i][1] = 2 result[i][i][0] = 2 其他状态设置为 0，即平局。 而对于入度的初始化为：\ndegree[i][j][0] = len(graph[i])\ndegree[i][j][1] = len(graph[j])\ndegree[i][j][1] -= 1 if j in graph[0] （猫不能在洞里）\n那么状态转移可以理解为：\n从最终状态遍历每一个前置状态： 若遍历到该前置状态的必胜态，则使其入度为零。 如没遍历到必胜态，则每次遍历使得其入度减一，知道其度为零，则设置其为必败态。 将已经确定必败或必胜的状态加入 queue 中， BFS 遍历其前置状态。 该转移没有遍历到的状态即平局状态。 当然此题还有些细节需要注意，可以看题解中的注释:\nclass Solution: def catMouseGame(self, graph: List[List[int]]) -\u0026gt; int: n = len(graph) queue = deque() # 状态为 degree[i][j][k] 表示: # 老鼠在 i , 猫在 j, 谁先手为 k (0 表示老鼠回合，1 表示猫回合) degree = [[[0, 0] for _ in range(n)] for _ in range(n)] result = [[[0, 0] for _ in range(n)] for _ in range(n)] def init(): for i in range(n): for j in range(1, n): degree[i][j][0] = len(graph[i]) degree[i][j][1] = len(graph[j]) # 猫不能在洞里，所以要减去这种特殊情况 for i in range(n): for j in graph[0]: degree[i][j][1] -= 1 for i in range(n): for j in range(1, n): if i == 0: result[i][j][1] = 1 # result[i][j][0] = 1 queue.append([i, j, 1]) # queue.append([i, j, 0]) elif i == j: result[i][j][1] =2 result[i][j][0] =2 queue.append([i, j, 1]) queue.append([i, j, 0]) init() # 检查前一个状态是否已经能被确定 def preCheck(preMouse, preCat, preTurn, result_state): if result[preMouse][preCat][preTurn] != 0: return # 如果下一个状态能赢，则直接确定为赢 win = True if result_state == 1 + preTurn else False if win: # 如果能赢，则入度直接归零 result[preMouse][preCat][preTurn] = result_state queue.append((preMouse, preCat, preTurn)) degree[preMouse][preCat][preTurn] = 0 # 避免重复处理 else: degree[preMouse][preCat][preTurn] -= 1 if degree[preMouse][preCat][preTurn] == 0: result[preMouse][preCat][preTurn] = 2 - preTurn queue.append((preMouse, preCat, preTurn)) # queue 中都是已经确定结果的状态 while queue: mouse, cat, turn = queue.popleft() result_state = result[mouse][cat][turn] preTurn = 1 - turn # 换手 if preTurn == 0: # 前一个回合是老鼠 for preMouse in graph[mouse]: preCheck(preMouse, cat, preTurn, result_state) else: # 前一个回合是猫 for preCat in graph[cat]: if preCat == 0: continue preCheck(mouse, preCat, preTurn, result_state) return result[1][2][0] 总结 # 此题综合了博弈论、搜索剪枝、动态规划、拓扑排序。有一定的难度，可以时常复习。\n","date":"2025 年 2 月 10 日","externalUrl":null,"permalink":"/posts/%E7%8C%AB%E5%92%8C%E8%80%81%E9%BC%A0-lc/","section":"","summary":"","title":"从“猫和老鼠”题解看博弈题型","type":"posts"},{"content":"","date":"2025 年 2 月 10 日","externalUrl":null,"permalink":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","section":"","summary":"","title":"动态规划","type":"tags"},{"content":"","date":"2025 年 2 月 10 日","externalUrl":null,"permalink":"/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/","section":"","summary":"","title":"拓扑排序","type":"tags"},{"content":"","date":"2025 年 2 月 10 日","externalUrl":null,"permalink":"/tags/%E5%9B%BE%E8%AE%BA/","section":"","summary":"","title":"图论","type":"tags"},{"content":"","date":"2025 年 2 月 8 日","externalUrl":null,"permalink":"/posts/%E5%85%B3%E4%BA%8E%E6%88%91/","section":"","summary":"","title":"关于我","type":"posts"},{"content":"","date":"2025 年 2 月 8 日","externalUrl":null,"permalink":"/categories/%E6%9D%82%E8%B0%88/","section":"","summary":"","title":"杂谈","type":"categories"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]