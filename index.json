
[{"content":" 文章分类 # ","date":"2025 年 11 月 21 日","externalUrl":null,"permalink":"/categories/","section":"","summary":"","title":"","type":"categories"},{"content":" 最近文章 # ","date":"2025 年 11 月 21 日","externalUrl":null,"permalink":"/posts/","section":"","summary":"","title":"","type":"posts"},{"content":"","date":"2025 年 11 月 21 日","externalUrl":null,"permalink":"/","section":"陈驰水-个人博客","summary":"","title":"陈驰水-个人博客","type":"page"},{"content":"","date":"2025 年 11 月 21 日","externalUrl":null,"permalink":"/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","section":"","summary":"","title":"算法与数据结构","type":"categories"},{"content":" HOT100 复习笔记：题干 + 思路 + 代码\nHOT100 从 23 年开始零零散散做过很多遍。\n但其中 trick 与脑筋急转弯比较多，还是很容易忘。\n因此特意花了一周的时间重新全部做了一边，用了同一的思路和代码风格方便复习。\n此外，还有些面试常见题也会写在后面。\n和 \u0026lsquo;算法题 - 分类索引\u0026rsquo; 有一定的重复。\nHOT 100 的分类其实有点问题，暂时先按顺序写了，比如很多题的知识点和类别就关系不大。\n此文章全部用 python，我也建议面试全部使用 python，原因如下：\n现在很多面试会搓 torch，直接用 python 写代码题避免切换麻烦 python 功能更强大且写的快，比如切片和 @cache 等 面试一般不要求大样本，python 的速度劣势体现不出来 python 语法不严格，避免了面试看到编译错误紧张 哈希 # 1. 两数之和\n题干：给一个数组，找的任意两数之和等于目标值\n思路：一轮遍历，用哈希记录当前遍历过哪些数，然后当前元素查哈希表即可\nclass Solution: def twoSum(self, nums: List[int], target: int) -\u0026gt; List[int]: m = defaultdict(lambda : -1) # 哈希表缺省值 n = len(nums) for i in range(n): if m[target - nums[i]] != -1: return [i, m[target - nums[i]]] m[nums[i]] = i return [] 49. 字母异位词分组\n题干：有字符串数组,对其中每个字符串按其中出现的元素分类\n输入: strs = [\u0026ldquo;eat\u0026rdquo;, \u0026ldquo;tea\u0026rdquo;, \u0026ldquo;tan\u0026rdquo;, \u0026ldquo;ate\u0026rdquo;, \u0026ldquo;nat\u0026rdquo;, \u0026ldquo;bat\u0026rdquo;]\n输出: [[\u0026ldquo;bat\u0026rdquo;],[\u0026ldquo;nat\u0026rdquo;,\u0026ldquo;tan\u0026rdquo;],[\u0026ldquo;ate\u0026rdquo;,\u0026ldquo;eat\u0026rdquo;,\u0026ldquo;tea\u0026rdquo;]]\n思路：对每个字符串排序后，哈希 key 为排序后的值\nclass Solution: def groupAnagrams(self, strs: List[str]) -\u0026gt; List[List[str]]: n = len(strs) m = defaultdict(list) for i in range(n): tmp_s = \u0026#39;\u0026#39;.join(sorted(strs[i])) # 注意下 str 的 join 用法 m[tmp_s].append(strs[i]) ans = [] for i, v in m.items(): ans.append(v) return ans 128. 最长连续序列\n题干：给一个数组，找的其中所有元素排序后最长的连续序列\n输入：nums = [100,4,200,1,3,2] 输出：4 解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。\n思路：不能使用排序。用桶重构数组，遍历每个连续序列的首值，记录每个序列的长度。最终使数组中每个元素最多遍历一边。\n# 桶 + 技巧 class Solution: def longestConsecutive(self, nums: List[int]) -\u0026gt; int: m = set(nums) ans = 0 for x in m: # !注意此处是在 set 中遍历，在 nums 中遍历最差是 On2 if x - 1 in m: continue xx = x length = 0 while xx in m: length += 1 xx += 1 ans = max(ans, length) return ans 双指针 # 283. 移动零\n题干：不改变数组顺序去情况下，将零全部移动到末尾，要求操作次数最少\n输入: nums = [0,1,0,3,12] 输出: [1,3,12,0,0]\n思路：将一个指针视作栈顶，即目前有多少非零的数，栈顶一定指向零，当遍历到非零元素交换。\n注意：和 荷兰国旗问题比较接近，但此题要求有序，因此解法不同。\nclass Solution: def moveZeroes(self, nums: List[int]) -\u0026gt; None: \u0026#34;\u0026#34;\u0026#34; Do not return anything, modify nums in-place instead. \u0026#34;\u0026#34;\u0026#34; n = len(nums) stack_size = 0 for i in range(n): if nums[i] != 0: nums[i], nums[stack_size] = nums[stack_size], nums[i] stack_size += 1 11. 盛最多水的容器\n题干：找数组两个“隔板”之间能容纳最多的水，注意不同与接雨水，不用考虑“隔板”本身的体积。\n输入：[1,8,6,2,5,4,8,3,7] 输出：49\n思路：双指针从两边向中间走，哪边数小就缩哪边\nclass Solution: def maxArea(self, height: List[int]) -\u0026gt; int: n = len(height) l = 0 r = n - 1 ans = 0 while l \u0026lt; r: ans = max(ans, (r - l) * min(height[l], height[r])) if height[l] \u0026lt; height[r]: l += 1 else: r -= 1 return ans 15. 三数之和\n题干：记录数组中所有 x + y + z == 0 的值，需要去重。\n思路：排序后三指针，遍历 x 作为基数，由于 y 和 z 一定有序，还是从两边缩小到中间的思路。此外可以遍历过程中去重，也可以用 tuple 做 hash 的 key，后者思维量小。\nclass Solution: def threeSum(self, nums: List[int]) -\u0026gt; List[List[int]]: n = len(nums) nums.sort() ans = set() for i, x in enumerate(nums): l = i + 1 r = n - 1 while l \u0026lt; r: if nums[l] + nums[r] == -x: ans.add((nums[i], nums[l], nums[r])) # break # 注意下此处不能直接 break，因为同一个 i，可以对应不同的 l r 做答案 l += 1 r -= 1 elif nums[l] + nums[r] \u0026lt; -x: l += 1 else: r -= 1 res = [] for x in ans: res.append([x[0], x[1], x[2]]) return res 42. 接雨水\n题干：过于经典，不赘述了\n思路：\n前缀后缀法：通法，思维量较小。统计每个数的最大前后缀 双指针实际上就说前缀后缀的优化版，核心就是哪侧前或后缀更小，就缩那测 单调递减栈，找上一个更大的，然后填坑 # 前缀后缀 class Solution: def trap(self, height: List[int]) -\u0026gt; int: n = len(height) pre = [0] * n pre[0] = height[0] suf = [0] * n suf[-1] = height[-1] for i in range(1, n): pre[i] = max(pre[i - 1], height[i]) for i in range(n - 2, -1, -1): suf[i] = max(suf[i + 1], height[i]) ans = 0 for i in range(n): ans += (min(pre[i], suf[i]) - height[i]) return ans # 双指针，谁小谁移动 class Solution: def trap(self, height: List[int]) -\u0026gt; int: n = len(height) l = 0 r = n - 1 pre_max = height[l] suf_max = height[r] ans = 0 while l \u0026lt; r: if pre_max \u0026lt; suf_max: ans += (pre_max - height[l]) l += 1 else: ans += (suf_max - height[r]) r -= 1 pre_max = max(pre_max, height[l]) suf_max = max(suf_max, height[r]) return ans # 单调栈做法 class Solution: def trap(self, height: List[int]) -\u0026gt; int: stack = [] n = len(height) ans = 0 for i, x in enumerate(height): while stack and x \u0026gt;= height[stack[-1]]: bottom = height[stack[-1]] stack.pop() if not stack: break l = stack[-1] h = min(height[l], x) - bottom ans += h * (i - l - 1) stack.append(i) return ans 滑动窗口 # 3. 无重复字符的最长子串\n题干：找到数组中无重复字符的最长子串\n思路：滑动窗口 + 哈希的模板题\nclass Solution: def lengthOfLongestSubstring(self, s: str) -\u0026gt; int: n = len(s) m = defaultdict(int) l = r = ans = 0 while l \u0026lt;= r and r \u0026lt; n: m[s[r]] += 1 # print(m) while l \u0026lt;= r and m[s[r]] != 1: # print(l, r, m) m[s[l]] -= 1 l += 1 ans = max(ans, r - l + 1) r += 1 return ans 438. 找到字符串中所有字母异位词\n题干：找到数组中所有 “目标字符 cnt ”等于”字串字符 cnt“ 的字串下标\n思路：稍微变形的滑窗板子，注意当缩减左窗口后，字串长度与目标相同时，一定两者 cnt 相同。\n# 滑动窗口板子 class Solution: def findAnagrams(self, s: str, p: str) -\u0026gt; List[int]: n = len(s) l = r = 0 t = defaultdict(int) for i in list(p): t[i] += 1 m = defaultdict(int) ans = [] while l \u0026lt;= r and r \u0026lt; n: m[s[r]] += 1 while l \u0026lt;= r and m[s[r]] \u0026gt; t[s[r]]: # 注意下缩左窗口的条件 m[s[l]] -= 1 l += 1 # print(r, l, m) if r - l + 1 == len(p): ans.append(l) r += 1 return ans 字串 # 560. 和为 K 的子数组\n题干：找子串和为 K 的数量\n思路：O1 求区间和 -\u0026gt; 需要前缀和 -\u0026gt; 哈希记录出现的指定前缀数量 -\u0026gt; 和两数之和思路一样\n# 求区间和 -\u0026gt; 前缀和 -\u0026gt; 哈希记录出现的指定前缀数量 class Solution: def subarraySum(self, nums: List[int], k: int) -\u0026gt; int: n = len(nums) prefix = [0] * (n + 1) m = defaultdict(int) m[0] = 1 ans = 0 # prefix[x] - prefix[y] == k # 即找 m[prefix[i] - k] 的数量 for i in range(1, n + 1): prefix[i] = prefix[i - 1] + nums[i - 1] ans += m[prefix[i] - k] m[prefix[i]] += 1 return ans 239. 滑动窗口最大值\n题干：找所有定长字串的最大值，要求 On\n思路：经典单调队列，仅字串中保持递减的一个队列，右侧插入与单调栈一致。当左侧和首元素下标相同时，队列进行 O1 移除。从而使每个队列的首元素一定是当前字串的最大值。\n单调队列相比单调栈出现的更少，注意其基本都是在栈中存下标，然后注意栈中的严格单调性。\n此外，此题还有个 ST 表 做法，但复杂度不比单调队列好。\n# 单调队列 class Solution: def maxSlidingWindow(self, nums: List[int], k: int) -\u0026gt; List[int]: arr = deque() n = len(nums) r = 0 ans = [] while r \u0026lt; n: # print(r, arr) if r \u0026gt;= k: ans.append(nums[arr[0]]) if arr[0] == r - k: # 维护左下标 arr.popleft() while arr and nums[r] \u0026gt;= nums[arr[-1]]: # 入队列操作和单调栈一样 arr.pop() arr.append(r) r += 1 ans.append(nums[arr[0]]) return ans 76. 最小覆盖子串\n题干：找到所有字串中，“目标串元素 cnt “ 能覆盖的”长度最小字串元素 cnt “是什么？\n输入：s = \u0026ldquo;ADOBECODEBANC\u0026rdquo;, t = \u0026ldquo;ABC\u0026rdquo; 输出：\u0026ldquo;BANC\u0026rdquo;\n思路：如果只要 O(52*n) 即滑窗的过程每次遍历单词表，那就是滑窗板子，和438. 找到字符串中所有字母异位词 完全一样。\n但如果想 O(n) 还是有些难度，新提出一个 less 字符标志，判断单词表中有多少词仍未被覆盖，从而代替遍历单词表。\n但要注意 less 的维护方法。\nclass Solution: def minWindow(self, s: str, t: str) -\u0026gt; str: n = len(s) l = r = 0 target = defaultdict(int) for i in list(t): target[i] += 1 m = defaultdict(int) less = len(target) # 开始时 target 中每个词都没被满足 ans_l, ans_r = 0, inf while l \u0026lt;= r and r \u0026lt; n: m[s[r]] += 1 if m[s[r]] == target[s[r]]: # 注意此处一定是等于，只想让 less 更新一次 less -= 1 while l \u0026lt;= r and less == 0: # print(l, r, less, ans_l, ans_r) if (ans_r - ans_l) \u0026gt; (r - l): # 注意此时内层循环才满足答案吗要求 ans_l = l ans_r = r m[s[l]] -= 1 if m[s[l]] == target[s[l]] - 1: less += 1 # 同样的，保证 less 只更新一次 l += 1 r += 1 return s[ans_l:ans_r + 1] if ans_r != inf else \u0026#34;\u0026#34; 普通数组 # 53. 最大子数组和\n题干：找字串中最大的 sum 是多少？\n思路：前缀和 + 空间优化（也可以简单 DP）。记录前缀和的最小值即可，简单优化下就能空间 O1。\n# 找个前缀就可以 class Solution: def maxSubArray(self, nums: List[int]) -\u0026gt; int: n = len(nums) prefix = 0 pre_min = inf ans = -inf for i in range(1, n + 1): pre_min = min(prefix, pre_min) prefix = prefix + nums[i - 1] ans = max(ans, prefix - pre_min) return ans 56. 合并区间\n题干：合并所有有重叠的区间\n思路：对原始区间排序后，比较当前区间的右侧和下一个区间的左侧。大部分语言之间排就可以，小部分要写 lambda。\nclass Solution: def merge(self, intervals: List[List[int]]) -\u0026gt; List[List[int]]: intervals.sort() ans = [] l = intervals[0][0] r = intervals[0][1] for x, y in intervals: if x \u0026lt;= r: r = max(y, r) else: ans.append([l, r]) l = x r = y ans.append([l, r]) return ans 189. 轮转数组\n题干：将数组右移动 k 位\n思路：三次反转，先转最大区间，再转两个小区间\n提示：如果是左移，其实就等于右移 -k 位\nclass Solution: def rotate(self, nums: List[int], k: int) -\u0026gt; None: \u0026#34;\u0026#34;\u0026#34; Do not return anything, modify nums in-place instead. \u0026#34;\u0026#34;\u0026#34; # 自带的 reverse 会产生多余空间，自己用双指针搓更合适 def reverse(l, r): while l \u0026lt; r: nums[l], nums[r] = nums[r], nums[l] l += 1 r -= 1 n = len(nums) k %= n reverse(0, n - 1) reverse(0, k - 1) reverse(k, n - 1) 238. 除自身以外数组的乘积\n题干：获得每个数对应的除了他自己以外全部元素的乘积。\n思路：明显的前后缀，题目要求只使用一个额外数组，先后缀后前缀直接得到答案就可以\n# 前缀后缀积，最好用一个数组解决 class Solution: def productExceptSelf(self, nums: List[int]) -\u0026gt; List[int]: n = len(nums) suf = [1] * n for i in range(n - 1, 0, -1): suf[i - 1] = suf[i] * nums[i] # print(suf) pre = 1 for i in range(n): suf[i] *= pre pre *= nums[i] return suf 41. 缺失的第一个正数\n题干：找数组中没出现的最小正数，要求 O(n) 时间，O1 空间。\n思路： 经典技巧题，想让每个符合条件的位置满足 nums[i] == nums[nums[i]]。\n这样就相当于让位置 i 的 x 一定回到 x 的位置上，此外交换过程中要考虑 swap 依赖问题。\nclass Solution: def firstMissingPositive(self, nums: List[int]) -\u0026gt; int: n = len(nums) for i in range(n): # 对齐下标 nums[i] -= 1 for i in range(n): while 0 \u0026lt;= nums[i] \u0026lt; n and nums[i] != nums[nums[i]]: j = nums[i] # 要让 swap 不被依赖 nums[i], nums[j] = nums[j], nums[i] # print(nums) for i in range(n): if nums[i] != i: return i + 1 return n + 1 矩阵 # 73. 矩阵置零\n题干：如果出现零，则将该 行/列 全部置零，要求 O1 空间复杂度。\n思路：用原本的第一行和第一列的来记录本行或列是否要归零，用 bool 记录第一行或列自己是否要归零。\nclass Solution: def setZeroes(self, matrix: List[List[int]]) -\u0026gt; None: \u0026#34;\u0026#34;\u0026#34; Do not return anything, modify matrix in-place instead. \u0026#34;\u0026#34;\u0026#34; n = len(matrix) m = len(matrix[0]) col_0 = False raw_0 = False # 用 bool 记录第一行或列自己是否要归零 for i in range(n): if matrix[i][0] == 0: raw_0 = True break for i in range(m): if matrix[0][i] == 0: col_0 = True break # 用第一行和第一列的来记录本行或列是否要归零 for i in range(n): for j in range(m): if matrix[i][j] == 0: matrix[0][j] = 0 matrix[i][0] = 0 # 从第二行列开始进行实际归零 for i in range(1, n): for j in range(1, m): if matrix[i][0] == 0: matrix[i][j] = 0 if matrix[0][j] == 0: matrix[i][j] = 0 # 修改第一行列 for i in range(n): if raw_0: matrix[i][0] = 0 for i in range(m): if col_0: matrix[0][i] = 0 54. 螺旋矩阵\n题干：顺时针向内旋转的遍历矩阵，输出遍历顺序。\n思路：模拟题，记录每行列的起始和方向，特别是循环后要把位置挪到下一个的起始点。\n# 走格子模拟，要注意些细节。注意要记录每行列的起始和方向。 class Solution: def spiralOrder(self, matrix: List[List[int]]) -\u0026gt; List[int]: direction = [[0, 1], [1, 0], [0, -1], [-1, 0]] index = 0 ans = [] m = len(matrix) n = len(matrix[0]) px = py = 0 left_m, right_m = 0, m left_n, right_n = 0, n while len(ans) != n * m: # print(ans, px, py, left_m, right_m, left_n, right_n) dx = direction[index][0] dy = direction[index][1] while left_m \u0026lt;= px \u0026lt; right_m and left_n \u0026lt;= py \u0026lt; right_n: # print(ans, px, py, left_m, right_m, left_n, right_n) ans.append(matrix[px][py]) px += dx py += dy px -= dx # 循环后要把位置挪到下一个的起始点 py -= dy ne = (index + 1) % 4 px += direction[ne][0] py += direction[ne][1] if index == 0: # 维护边界 left_m += 1 if index == 1: right_n -= 1 if index == 3: left_n += 1 if index == 2: right_m -= 1 index = (index + 1) % 4 return ans 48. 旋转图像\n题干：矩阵原地顺时针旋转 90°\n思路：\n顺时针旋转90°，等于 先沿主对角线反转 + 后左右反转。\n逆时针选择90°，等于 先沿主对角线反转 + 后上下反转。\n旋转 180°，等于 左右反转 + 上下反转\nclass Solution: def rotate(self, matrix: List[List[int]]) -\u0026gt; None: \u0026#34;\u0026#34;\u0026#34; Do not return anything, modify matrix in-place instead. \u0026#34;\u0026#34;\u0026#34; m, n = len(matrix), len(matrix[0]) for i in range(m): for j in range(i + 1, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # print(matrix) mid = n // 2 for i in range(m): for j in range(mid): matrix[i][j], matrix[i][n-j-1] = matrix[i][n-j-1], matrix[i][j] 240. 搜索二维矩阵 II\n题干：矩阵每行从左到右升序，每列从上到下升序，找目标元素\n思路：和二分查找树一样，注意右上角是根\nclass Solution: def searchMatrix(self, matrix: List[List[int]], target: int) -\u0026gt; bool: m, n = len(matrix), len(matrix[0]) x, y = 0, n - 1 while x \u0026lt; m and y \u0026gt;= 0: if matrix[x][y] == target: return True elif matrix[x][y] \u0026gt; target: y -= 1 elif matrix[x][y] \u0026lt; target: x += 1 return False 链表 # 160. 相交链表\n题干：找两条链表相交的第一个节点（相交后一直相交），注意其不一定相交。要求时间 O(m+n) 空间 O(1)。\n思路：同时遍历两条链表，如果遍历到空，则从另一条头开始遍历，直到两者相遇。（和经典的 O1 空间判断环入口的思路其实一样）\n原理：设两条链表的重复部分为 Z，则 链表a 为 X+Z；链表b 为 Y+Z。让两者都走 X+Y+Z，相撞一定在 Z 的入口。不相交就是 Z == 0 的情况。\nclass Solution: def getIntersectionNode(self, headA: ListNode, headB: ListNode) -\u0026gt; Optional[ListNode]: p = headA q = headB while p != q: p = p.next if p else headB q = q.next if q else headA return p 206. 反转链表\n思路：分成递归和迭代，建议直接记住吧\nclass Solution: def reverseList(self, head: Optional[ListNode]) -\u0026gt; Optional[ListNode]: pre = None cur = head while cur: tmp = cur.next cur.next = pre pre = cur cur = tmp return pre class Solution: def reverseList(self, head: Optional[ListNode]) -\u0026gt; Optional[ListNode]: if head == None or head.next == None: return head nxt = self.reverseList(head.next) head.next.next = head head.next = None return nxt 234. 回文链表\n题干：空间 O1 的判断一个链表是否是回文链表\n思路：快慢指针判断中点，对后半段反转，之后双指针判断是否前后一致\n# Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def isPalindrome(self, head: Optional[ListNode]) -\u0026gt; bool: # 快慢指针找中点 fast = slow = head while fast and fast.next: slow = slow.next fast = fast.next.next def reverse(head): cur = head pre = None while cur: tmp = cur.next cur.next = pre pre = cur cur = tmp return pre # 反转后半段 right = reverse(slow) left = head # 判断前后是否相同 while right: if left.val != right.val: return False left = left.next right = right.next return True 141. 环形链表\n题干：链表判断有环，典中典\nclass Solution: def hasCycle(self, head: Optional[ListNode]) -\u0026gt; bool: if not head or not head.next: return False slow = fast = head fast = slow.next while slow != fast and slow and fast and fast.next: slow = slow.next fast = fast.next.next return True if slow == fast else False 更加优雅的版本\nclass Solution: def hasCycle(self, head: Optional[ListNode]) -\u0026gt; bool: slow = fast = head # 乌龟和兔子同时从起点出发 while fast and fast.next: slow = slow.next # 乌龟走一步 fast = fast.next.next # 兔子走两步 if fast is slow: # 兔子追上乌龟（套圈），说明有环 return True return False # 访问到了链表末尾，无环 142. 环形链表 II\n题干：空间 O1 找环入口\n思路：先找快慢指针相撞的位置，之后将快指针挪到头，之后和慢指针一步步走，再次相撞就是环入口\n原理：假设进环前的路程为 a，环长为 b。设慢指针走了 x 步时，快慢指针相遇，此时快指针走了 2x 步。显然 2x-x=kb（快指针比慢指针多走了 k 圈），即 x=kb。也就是说慢指针总共走过的路程是 kb，但这 kb 当中，实际上包含了进环前的一个小 a，因此慢指针在环中只走了 kb-a 步，再往前走 a 步，就得到完整的 k 圈，即环入口。\nclass Solution: def detectCycle(self, head: Optional[ListNode]) -\u0026gt; Optional[ListNode]: fast = slow = head while fast and fast.next: fast = fast.next.next slow = slow.next if fast == slow: break if not fast or not fast.next: return fast = head while fast != slow: fast = fast.next slow = slow.next return fast 21. 合并两个有序链表\n题干：两个有序链表合成一个有序链表\n思路：用一个 pre 节点来连整个链表，两条链表的节点谁小谁移动。注意最后剩下的也要连到后面。\nclass Solution: def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -\u0026gt; Optional[ListNode]: prehead = ListNode(-1) pre = prehead # 用一个 pre 来链接链表 cur1 = list1 cur2 = list2 while cur1 and cur2: if cur1.val \u0026lt;= cur2.val: # 谁小谁移动 pre.next = cur1 cur1 = cur1.next pre = pre.next else: pre.next = cur2 cur2 = cur2.next pre = pre.next if cur1: pre.next = cur1 else: pre.next = cur2 return prehead.next 2. 两数相加\n题干：将两个链表诸位相加，大于10则进一位，返回相加完的最终链表。\n思路：以其中一条链表为基准，另一条逐位加到上面，当出现长度不同和进位问题时，延长该链表。\nclass Solution: def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -\u0026gt; Optional[ListNode]: cur1 = l1 cur2 = l2 # 将 cur1 的值加到 cur2 中，注意如果 cur1 更长或者有进位，需要加节点 while cur1 and cur2: if not cur2.next and cur1.next: cur2.next = ListNode(0) cur2.val += cur1.val if cur2.val \u0026gt;= 10: cur2.val %= 10 if cur2.next: cur2.next.val += 1 else: node = ListNode(1) cur2.next = node cur2 = cur2.next cur1 = cur1.next # 如果 cur2 最后还是大于 10，则反复加节点 while cur2 and cur2.val \u0026gt;= 10: cur2.val %= 10 if cur2.next: cur2.next.val += 1 else: node = ListNode(1) cur2.next = node cur2 = cur2.next return l2 19. 删除链表的倒数第 N 个结点\n题干：一次遍历删除倒数第 N 个结点。\n思路：快指针先走 N 步，然后慢指针启动，当快指针到头，慢指针就是倒数第 N 个。\nclass Solution: def removeNthFromEnd(self, head: Optional[ListNode], n: int) -\u0026gt; Optional[ListNode]: fast = head for _ in range(n): fast = fast.next slow = head prehead = ListNode(-1) pre = prehead pre.next = head while fast: fast = fast.next pre = slow slow = slow.next pre.next = slow.next del slow return prehead.next 24. 两两交换链表中的节点\n题干：将每相邻的两个节点反转，后续不足两个的不变。\n思路：用三个指针模拟 pre, cur, nx ，其中反转 cur 和 nx 即可。\nclass Solution: def swapPairs(self, head: Optional[ListNode]) -\u0026gt; Optional[ListNode]: prehead = ListNode(-1) pre = prehead pre.next = head cur = head while cur: nx = cur.next if not nx: return prehead.next pre.next = nx tmp = nx.next nx.next = cur cur.next = tmp pre = cur cur = cur.next return prehead.next 25. K 个一组翻转链表\n题干：将连续的 k 个链表反转，后续不足 k 的不变。\n思路：\n实现 start 到 tail 的链表反转，实现如上述 206. 反转链表 用 pre 指针和 nx 指针维护反转后的链表连接，参考 24. 两两交换链表中的节点 class Solution: def reverseKGroup(self, head: Optional[ListNode], k: int) -\u0026gt; Optional[ListNode]: guard = ListNode(-1) guard.next = head def reverse(head: Optional[ListNode], k: int): cur = head pre = None kk = k while cur and k: k -= 1 tmp = cur.next cur.next = pre pre = cur cur = tmp # print(pre, head) return pre, head cur = head pre = guard while cur: tail = cur for i in range(k - 1): tail = tail.next if not tail: return guard.next tail = tail.next l, r = reverse(cur, k) pre.next = l r.next = tail # print(tail) pre = r cur = tail return guard.next 138. 随机链表的复制\n题干：有一条链表在 next 之外，每个节点多存一个指针 random，其可能指向该链表的任意位置或空。要求深拷贝这条链表。\n思路：\n由于新链表在创建过程中，random 可能指向还没创建的链表，因此需要想办法存新链表的每个节点，然后至少两轮遍历。 如果用哈希表，空间复杂度 O(N)，即一轮创建新节点，第二轮连接新节点。哈希表的 key 是 node 地址，value 也是 node 地址。 也可以用另一种方法，在每个 cur 后面存对应的新 cur，相当于用 链表 模拟出了一种哈希，如果返回值不记录复杂度，则可以视作 空间复杂度 O1。 class Solution: def copyRandomList(self, head: \u0026#39;Optional[Node]\u0026#39;) -\u0026gt; \u0026#39;Optional[Node]\u0026#39;: m = defaultdict(Node) cur = head pre = Node(-1) pre.next = cur while cur: new_node = Node(cur.val, None, None) m[cur] = new_node cur = cur.next cur = head print(m[head]) while cur: if cur.next: m[cur].next = m[cur.next] if cur.random: m[cur].random = m[cur.random] cur = cur.next return m[head] if head else None 148. 排序链表\n题干：根据值对链表排序\n思路：归并排序用链表实现，分成递归和迭代，递归空间复杂度 O(logN)，迭代法是 O1\n# 递归法更好写 class Solution: def sortList(self, head: Optional[ListNode]) -\u0026gt; Optional[ListNode]: # 合并链表 def mergeList(head1, head2): prehead = ListNode(-1) pre = prehead cur1 = head1 cur2 = head2 while cur1 and cur2: if cur1.val \u0026lt;= cur2.val: pre.next = cur1 cur1 = cur1.next else: pre.next = cur2 cur2 = cur2.next pre = pre.next pre.next = cur1 if cur1 else cur2 return prehead.next def merge_sort(head, tail): if not head: return head if head.next == tail: head.next = None # 注意遍历到 tail 时要断开链表 return head fast = head slow = head while fast != tail and fast.next != tail: slow = slow.next fast = fast.next.next left = merge_sort(head, slow) right = merge_sort(slow, tail) return mergeList(left, right) return merge_sort(head, None) # 细节还是很多的 class Solution: def sortList(self, head: Optional[ListNode]) -\u0026gt; Optional[ListNode]: # 合并链表，要返回合并后的 head 和 tail def mergeList(head1, head2): prehead = ListNode(-1) pre = prehead cur1 = head1 cur2 = head2 while cur1 and cur2: if cur1.val \u0026lt;= cur2.val: pre.next = cur1 cur1 = cur1.next else: pre.next = cur2 cur2 = cur2.next pre = pre.next pre.next = cur1 if cur1 else cur2 while pre.next: pre = pre.next return prehead.next, pre def getlenght(head) -\u0026gt; int: cur = head ans = 0 while cur: cur = cur.next ans += 1 return ans # 分割 head 链表的第 k 个节点，返回分割后的头 def split(head, k) -\u0026gt; ListNode: # 这里不能复用 getlength，否则会导致 logN 退化为 N2 # length = getlenght(head) cur = head for _ in range(k - 1): if cur == None: return None cur = cur.next if not cur or not cur.next: return None tmp = cur.next cur.next = None return tmp # 倍增法实现迭代归并排序 prehead = ListNode(next=head) step = 1 length = getlenght(head) while step \u0026lt; length: pre = prehead # 记录需要合并链表的 pre cur = prehead.next while cur: head1 = cur # 两个 head 是切下来的两个 list head2 = split(head1, step) cur = split(head2, step) # cur 是合并后的 next newhead, newtail = mergeList(head1, head2) # print(newhead, newtail, step, cur) pre.next = newhead newtail.next = cur pre = newtail # pre 编程 merge 后的 tail step *= 2 # 倍增 return prehead.next 23. 合并 K 个升序链表\n题干：之前是合并 两个链表，现在合并 k 个链表。共有 L 个元素，则时间复杂度最好 O(L log k)。\n思路：\n堆法，用 val 对做排序，把每个链表的头堆中，如果最小则弹出该节点，然后节点向后移动一次，由于原始列表有序，则包装栈中一定是最小的，空间复杂度 O(K）。 递归分治，和上面的归并排序差不多，不过这次的是对 k 进行分治。空间复杂度 O(logK） 倍增法分治，同样的用 step 对 k 分治，空间复杂度 O(1） class Solution: def mergeKLists(self, lists: List[Optional[ListNode]]) -\u0026gt; Optional[ListNode]: def mergeList(head1, head2): prehead = ListNode(-1) pre = prehead cur1 = head1 cur2 = head2 while cur1 and cur2: if cur1.val \u0026lt;= cur2.val: pre.next = cur1 cur1 = cur1.next else: pre.next = cur2 cur2 = cur2.next pre = pre.next pre.next = cur1 if cur1 else cur2 while pre.next: pre = pre.next return prehead.next # 倍增法 n = len(lists) step = 1 while step \u0026lt; n: for i in range(0, n - step, step * 2): lists[i] = mergeList(lists[i], lists[i + step]) step *= 2 return lists[0] if lists else None 146. LRU 缓存\n题干：实现一个 LRU 缓存，需要有考虑 cache 大小，有 get 和 put 操作。其中如果 cache 满了，则删掉最久没用到的节点，如果 put 一个已有的 node 则相当于 update。此外，每个节点有 key 。\n思路：\n双向链表 + 哈希表。链表头代表最近使用，用 map 来 O1 找到节点的位置，并记录链表长度。\n用哨兵来维护头和尾，哨兵的 next 是 head， 哨兵的 pre 是 tail。\nget 需要两步，先找到节点，再把节点挪到头。\nput 先判断是不是 update，如果不是，根据 cache 容量来创建新 node，并可能删除 tail\nclass Node: def __init__(self, key=0, value=0, pre=None, next=None): self.key = key self.value = value self.pre = pre self.next = next class LRUCache: def __init__(self, capacity: int): self.capacity = capacity # 双向链表哑节点一定在固定的 head # 则 dummy.pre 就是 tail 节点 self.dummy = Node() self.dummy.next = self.dummy self.dummy.pre = self.dummy self.map = defaultdict(lambda : -1) # 将 node 挪到链表头 # 注意不管是挪节点还是 remove，都只对指针操作，创建节点在 put 中 def node_front(self, node): if node == None: return node.pre = self.dummy node.next = self.dummy.next node.next.pre = node node.pre.next = node # 删去 node def remove(self, node): node.pre.next = node.next node.next.pre = node.pre # 用 map 查找节点是否在链表中，同时要注意维护 map # 如何有，则将其挪到最前 def get_node(self, key): if self.map[key] == -1: del self.map[key] return None node = self.map[key] self.remove(node) self.node_front(node) return node # 用 get_node 返回 value def get(self, key: int) -\u0026gt; int: node = self.get_node(key) return node.value if node else -1 # 如果当前节点已经在链表中，相当于查找更新并 # 否则相当于添加节点，则需要维护 map def put(self, key: int, value: int) -\u0026gt; None: node = self.get_node(key) if node: node.value = value else: new_node = Node() new_node.value = value new_node.key = key self.map[key] = new_node self.node_front(new_node) if len(self.map) \u0026gt; self.capacity: last_node = self.dummy.pre del self.map[last_node.key] self.remove(last_node) 二叉树 # 94. 二叉树的中序遍历\n# 别忘了怎么构建 TreeNode 就行 # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def inorderTraversal(self, root: Optional[TreeNode]) -\u0026gt; List[int]: ans = [] def dfs(node): if node == None: return node dfs(node.left) ans.append(node.val) dfs(node.right) dfs(root) return ans 104. 二叉树的最大深度\n思路：层级遍历\nclass Solution: def maxDepth(self, root: Optional[TreeNode]) -\u0026gt; int: if root == None: return 0 queue = deque() queue.append(root) ans = 0 while queue: ans += 1 k = len(queue) for i in range(k): tmp = queue[0] queue.popleft() if tmp.left: queue.append(tmp.left) if tmp.right: queue.append(tmp.right) return ans 226. 翻转二叉树\n题干：将二叉树沿中轴线 左右反转。\n思路：dfs 时候交换左右指针即可。\nclass Solution: def invertTree(self, root: Optional[TreeNode]) -\u0026gt; Optional[TreeNode]: if not root: return None def dfs(node): if not node: return node.left, node.right = node.right, node.left dfs(node.left) dfs(node.right) dfs(root) return root 101. 对称二叉树\n题干：判断二叉树是否左右对称\n思路：递归稍微有一点难度，检查左右节点的关系\nclass Solution: def isSymmetric(self, root: Optional[TreeNode]) -\u0026gt; bool: if not root: return True def check(l, r): if not l and not r: # 到叶子了 return True if not l or not r or l.val != r.val: return False return check(l.left, r.right) and check(l.right, r.left) return check(root.left, root.right) 543. 二叉树的直径\n题干：直径指的是 树中任意两个节点之间最长路径的长度，注意其未必经过 root\n思路：遍历每个点深度，左右子树深度差的最大值就是直径\n# 把下面两个写在一个函数就是一轮遍历 class Solution: def diameterOfBinaryTree(self, root: Optional[TreeNode]) -\u0026gt; int: m = defaultdict(int) def depth(node): if not node: m[node] = 0 return 0 de = max(depth(node.left), depth(node.right)) + 1 m[node] = de return de depth(root) # print(m) ans = 0 def dfs(node): nonlocal ans if not node: return ans = max(ans, m[node.left] + m[node.right]) dfs(node.left) dfs(node.right) dfs(root) return ans 102. 二叉树的层序遍历\nclass Solution: def levelOrder(self, root: Optional[TreeNode]) -\u0026gt; List[List[int]]: if root == None: return [] queue = deque() queue.append(root) ans = [] while queue: k = len(queue) res = [] for i in range(k): tmp = queue[0] res.append(tmp.val) queue.popleft() if tmp.left: queue.append(tmp.left) if tmp.right: queue.append(tmp.right) ans.append(res) return ans 108. 将有序数组转换为二叉搜索树\n题干：用有序数组创建一颗 二叉查找树，要求平衡（左右深度不超过1）\n思路：二分分治，每次用 mid 做根，左右二分做左右子树\nclass Solution: def sortedArrayToBST(self, nums: List[int]) -\u0026gt; Optional[TreeNode]: n = len(nums) if n == 0: return None def dfs(l, r): nonlocal nums if l \u0026gt; r: return None mid = l + r \u0026gt;\u0026gt; 1 node = TreeNode(nums[mid]) node.left = dfs(l, mid - 1) node.right = dfs(mid + 1, r) return node return dfs(0, n - 1) 98. 验证二叉搜索树\n思路：注意只查看左右子树是否为满足二叉搜索性质是错的，因为二叉搜索树要求左边全部元素小于跟。\n具体思路很多：\n由于中跟遍历是有序数组，因此只需要维护中跟的前一个数，然后判断当前是否比前面大即可。 前跟或后跟 遍历同时记录最大最小值，判断是否满足。 # 中跟 class Solution: def isValidBST(self, root: Optional[TreeNode]) -\u0026gt; bool: if not root: return True pre = -inf # pre 是中跟遍历的上一个元素 def dfs(node) -\u0026gt; bool: nonlocal pre if not node: return True l_ans = dfs(node.left) # 中跟遍历 if pre \u0026gt;= node.val: # 如果当前小于上个元素就错了 return False pre = node.val return l_ans and dfs(node.right) return dfs(root) 230. 二叉搜索树中第 K 小的元素\n思路：中跟遍历到的第 K 个就是答案\n思考题：如果要频繁查找第 K 个，可以预处理每个节点下面的子节点数量，从而在一棵平衡树中做到查找 O(logN)。\nclass Solution: def kthSmallest(self, root: Optional[TreeNode], k: int) -\u0026gt; int: if not root: return -1 ans = -1 def dfs(node): nonlocal ans, k if not node: return dfs(node.left) k -= 1 if k == 0: ans = node.val return # 提前返回 dfs(node.right) dfs(root) return ans 199. 二叉树的右视图\n题干：从右向左看一颗二叉树，返回看到的 list\n思路：层级遍历记录最后一个值。\nclass Solution: def rightSideView(self, root: Optional[TreeNode]) -\u0026gt; List[int]: if root == None: return [] queue = deque() queue.append(root) ans = [] while queue: res = -1 k = len(queue) for i in range(k): tmp = queue[0] res = tmp.val queue.popleft() if tmp.left: queue.append(tmp.left) if tmp.right: queue.append(tmp.right) ans.append(res) return ans 114. 二叉树展开为链表\n题干：将链表用前跟遍历的顺序连接成链表，用树中左指针置空，右指针作为链表 next 来实现，要求原地修改。\n思路：\n按 右左跟 的后跟遍历是正常前跟遍历的 reverse，因此可以从后向前构建链表。 分治法，维护左右子链表的最后一个元素，用最后一个元素连接。前跟遍历即可。 # 逆序头插法 class Solution: def flatten(self, root: Optional[TreeNode]) -\u0026gt; None: \u0026#34;\u0026#34;\u0026#34; Do not return anything, modify root in-place instead. \u0026#34;\u0026#34;\u0026#34; head = None def dfs(node): nonlocal head if node == None: return dfs(node.right) dfs(node.left) node.left = None node.right = head head = node dfs(root) return head # 分治法 class Solution: def flatten(self, root: Optional[TreeNode]) -\u0026gt; None: if not root: return None def dfs(node) -\u0026gt; TreeNode: if not node: return None l_tail = dfs(node.left) r_tail = dfs(node.right) if l_tail: # 连接左右两个子链表 l_tail.right = node.right node.right = node.left node.left = None if r_tail: return r_tail elif l_tail: return l_tail else: return node return dfs(root) 105. 从前序与中序遍历序列构造二叉树\n思路：递归构造二叉树，输入是前序和中序的左右边界（共四个边界），每轮前序的第一个元素是下一轮的根，用 hash O1 查到 inorder 中的位置，然后就能推出四个边界。\nclass Solution: def buildTree(self, preorder: List[int], inorder: List[int]) -\u0026gt; Optional[TreeNode]: m = defaultdict(int) n = len(preorder) for i in range(len(inorder)): m[inorder[i]] = i if len(preorder) == 0: return None # root = TreeNode(preorder[0]) def dfs(lp, rp, li, ri): nonlocal m, preorder, inorder if lp \u0026gt; rp or li \u0026gt; ri: return None node = TreeNode(preorder[lp]) x = m[node.val] length_l = x - li length_r = ri - x node.left = dfs(lp + 1, lp + length_l, li, x - 1) node.right = dfs(lp + length_l + 1, rp, x + 1, ri) return node return dfs(0, n - 1, 0, n - 1) 437. 路径总和 III\n题干：二叉树里节点值之和等于 targetSum 的 路径 的数目。路径指任意两节点相连的过程，此题中只考虑从上往下的路径。\n思路：和 560. 和为 K 的子数组 一样用前缀和，但此处由于树的递归操作，因此要在左右递归后恢复现场，比较综合的题。\nclass Solution: def pathSum(self, root: Optional[TreeNode], targetSum: int) -\u0026gt; int: prefix = defaultdict(int) prefix[0] = 1 num = 0 ans = 0 def dfs(node): nonlocal prefix, num, targetSum, ans if not node: return None # print(node.val, prefix, num, ans) num += node.val ans += prefix[num - targetSum] prefix[num] += 1 dfs(node.left) # 注意此题是要等左右都遍历完才恢复现场 dfs(node.right) prefix[num] -= 1 num -= node.val dfs(root) return ans 236. 二叉树的最近公共祖先\n题干：找二叉树两点的最近祖先\n思路：用后跟遍历 find 判断最近公共祖先。\n由于后跟遍历到 node 时，已知其下面的情况，如果找不到两节点中的任意一个，则代表其不是祖先，返回找到的那个。\n如果该节点左右都能找到节点，说明他就是答案，返回自己，而其父节点一定只能找到一边，最终返回该答案。\n此题思路相当优雅，值得多看。\nclass Solution: def lowestCommonAncestor(self, root: \u0026#39;TreeNode\u0026#39;, p: \u0026#39;TreeNode\u0026#39;, q: \u0026#39;TreeNode\u0026#39;) -\u0026gt; \u0026#39;TreeNode\u0026#39;: def find(node, p, q): if not node: return None if node == p or node == q: return node left = find(node.left, p, q) right = find(node.right, p, q) if left and right: return node return left if left else right return find(root, p, q) 124. 二叉树中的最大路径和\n题干：找路径中最大的，注意会出现负数。此题路径距离在 node 上的 val。\n思路：depth 记录包含该点的最大值，第二轮遍历中，此点最大路径就是 左右 depth + 该点值。也可以用一轮遍历。\n注意：存在大量负数，需要每次保证 max(depth, 0)\nclass Solution: def maxPathSum(self, root: Optional[TreeNode]) -\u0026gt; int: m = defaultdict(lambda : 0) def depth(node): nonlocal m if not node: return 0 m[node] = max(max(depth(node.left), 0), max(depth(node.right), 0)) + node.val return m[node] depth(root) # print(m[root]) ans = -inf def dfs(node): nonlocal m, ans if not node: return ans = max(ans, max(m[node.left], 0) + max(m[node.right], 0) + node.val) dfs(node.left) dfs(node.right) dfs(root) return ans 图论 # 200. 岛屿数量\n题干：\n给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。\n岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。\n样例：\n输入：grid = [\r[\u0026#39;1\u0026#39;,\u0026#39;1\u0026#39;,\u0026#39;0\u0026#39;,\u0026#39;0\u0026#39;,\u0026#39;0\u0026#39;],\r[\u0026#39;1\u0026#39;,\u0026#39;1\u0026#39;,\u0026#39;0\u0026#39;,\u0026#39;0\u0026#39;,\u0026#39;0\u0026#39;],\r[\u0026#39;0\u0026#39;,\u0026#39;0\u0026#39;,\u0026#39;1\u0026#39;,\u0026#39;0\u0026#39;,\u0026#39;0\u0026#39;],\r[\u0026#39;0\u0026#39;,\u0026#39;0\u0026#39;,\u0026#39;0\u0026#39;,\u0026#39;1\u0026#39;,\u0026#39;1\u0026#39;]\r]\r输出：3 思路：DFS，BFS 都可以，最简单的图\nclass Solution: def numIslands(self, grid: List[List[str]]) -\u0026gt; int: direction = [[0, 1], [0, -1], [1, 0], [-1, 0]] m = len(grid) n = len(grid[0]) def dfs(i: int, j: int) -\u0026gt; None: if i \u0026lt; 0 or i \u0026gt;= m or j \u0026lt; 0 or j \u0026gt;= n or grid[i][j] != \u0026#39;1\u0026#39;: return grid[i][j] = \u0026#39;0\u0026#39; # 淹了陆地 dfs(i, j - 1) dfs(i, j + 1) dfs(i - 1, j) dfs(i + 1, j) ans = 0 for i in range(m): for j in range(n): if grid[i][j] == \u0026#39;1\u0026#39;: dfs(i, j) ans += 1 return ans 994. 腐烂的橘子\n题干：\n在给定的 m x n 网格 grid 中，每个单元格可以有以下三个值之一：\n值 0 代表空单元格； 值 1 代表新鲜橘子； 值 2 代表腐烂的橘子。 每分钟，腐烂的橘子 周围 4 个方向上相邻 的新鲜橘子都会腐烂。\n返回 直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1 。\n# BFS 遍历 class Solution: def orangesRotting(self, grid: List[List[int]]) -\u0026gt; int: directionX = [1, 0, -1, 0] directionY = [0, 1, 0, -1] q = deque() m = len(grid) n = len(grid[0]) for i in range(0, m): for j in range(0, n): if grid[i][j] == 2: q.append([i, j]) # 此题初始状态不算第一步 ans = -1 if q else 0 while q: k = len(q) ans += 1 for _ in range(k): temp = q[0] q.popleft() for i in range(4): dx = temp[0] + directionX[i] dy = temp[1] + directionY[i] if 0 \u0026lt;= dx \u0026lt; m and 0 \u0026lt;= dy \u0026lt; n and grid[dx][dy] == 1: grid[dx][dy] = 2 q.append([dx, dy]) # 如果还有走不到的橘子 for i in range(0, m): for j in range(0, n): if grid[i][j] == 1: return -1 return ans 207. 课程表\n题干：找图中是否由环\n# 拓扑排序 class Solution: def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -\u0026gt; bool: grid = [[] for _ in range(numCourses)] indegree = [0] * numCourses for x, y in prerequisites: grid[y].append(x) indegree[x] += 1 # print(grid) queue = deque() for i in range(numCourses): if indegree[i] == 0: queue.append(i) while queue: node = queue[0] queue.popleft() for to in grid[node]: indegree[to] -= 1 if indegree[to] == 0: queue.append(to) for i in range(numCourses): if indegree[i] != 0: return False return True 208. 实现 Trie (前缀树)\n思路：多维护一个 isEnd 即可，其他都是工程问题\nN = 26 class Trie: def __init__(self): # isEnd 判断每个单词的结尾 # next 数组表示该字符可能的下一个字符 self.isEnd = False self.next = [None] * N def insert(self, word: str) -\u0026gt; None: node = self for c in word: index = ord(c) - ord(\u0026#39;a\u0026#39;) if not node.next[index]: node.next[index] = Trie() node = node.next[index] # 标记每个单词的结尾 node.isEnd = True def search(self, word: str) -\u0026gt; bool: node = self for c in word: # 先前进再判空 index = ord(c) - ord(\u0026#39;a\u0026#39;) node = node.next[index] if not node: return False # 遍历到底 但不是结尾 return node.isEnd def startsWith(self, prefix: str) -\u0026gt; bool: node = self for c in prefix: index = ord(c) - ord(\u0026#39;a\u0026#39;) node = node.next[index] if not node: return False # 判读前缀不用管 isEnd return True 回溯 # 46. 全排列\n输入：nums = [1,2,3]\r输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] # 用 path 维护选了哪些，每轮遍历 nums class Solution: def permute(self, nums: List[int]) -\u0026gt; List[List[int]]: ans = [] n = len(nums) def dfs(i: int, path: list): nonlocal ans, n if i == n: ans.append(path.copy()) for idx in range(n): if nums[idx] not in path: path.append(nums[idx]) dfs(i + 1, path) path.pop() dfs(0, []) return ans 78. 子集\n输入：nums = [1,2,3]\r输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]] # 选或不选维护 arr 即可，注意深拷贝 class Solution: def subsets(self, nums: List[int]) -\u0026gt; List[List[int]]: ans = [] n = len(nums) def dfs(index, arr): if index == n: ans.append(arr) return # 下面是深拷贝 new_arr = copy.deepcopy(arr) new_arr.append(nums[index]) dfs(index + 1, arr) dfs(index + 1, new_arr) dfs(0, []) return ans 17. 电话号码的字母组合\n题干：分块遍历回溯，只能选而不能不选\n有：\rm = {\u0026#39;2\u0026#39;:[\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;],\r\u0026#39;3\u0026#39;:[\u0026#39;d\u0026#39;,\u0026#39;e\u0026#39;,\u0026#39;f\u0026#39;],\r\u0026#39;4\u0026#39;:[\u0026#39;g\u0026#39;,\u0026#39;h\u0026#39;,\u0026#39;i\u0026#39;],\r\u0026#39;5\u0026#39;:[\u0026#39;j\u0026#39;,\u0026#39;k\u0026#39;,\u0026#39;l\u0026#39;],\r\u0026#39;6\u0026#39;:[\u0026#39;m\u0026#39;,\u0026#39;n\u0026#39;,\u0026#39;o\u0026#39;],\r\u0026#39;7\u0026#39;:[\u0026#39;p\u0026#39;,\u0026#39;q\u0026#39;,\u0026#39;r\u0026#39;,\u0026#39;s\u0026#39;],\r\u0026#39;8\u0026#39;:[\u0026#39;t\u0026#39;,\u0026#39;u\u0026#39;,\u0026#39;v\u0026#39;],\r\u0026#39;9\u0026#39;:[\u0026#39;w\u0026#39;,\u0026#39;x\u0026#39;,\u0026#39;y\u0026#39;,\u0026#39;z\u0026#39;]}\r输入：digits = \u0026#34;23\u0026#34;\r输出：[\u0026#34;ad\u0026#34;,\u0026#34;ae\u0026#34;,\u0026#34;af\u0026#34;,\u0026#34;bd\u0026#34;,\u0026#34;be\u0026#34;,\u0026#34;bf\u0026#34;,\u0026#34;cd\u0026#34;,\u0026#34;ce\u0026#34;,\u0026#34;cf\u0026#34;] class Solution: def letterCombinations(self, digits: str) -\u0026gt; List[str]: n = len(digits) if n == 0: return [] # 分块 m = {\u0026#39;2\u0026#39;:[\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;], \u0026#39;3\u0026#39;:[\u0026#39;d\u0026#39;,\u0026#39;e\u0026#39;,\u0026#39;f\u0026#39;], \u0026#39;4\u0026#39;:[\u0026#39;g\u0026#39;,\u0026#39;h\u0026#39;,\u0026#39;i\u0026#39;], \u0026#39;5\u0026#39;:[\u0026#39;j\u0026#39;,\u0026#39;k\u0026#39;,\u0026#39;l\u0026#39;], \u0026#39;6\u0026#39;:[\u0026#39;m\u0026#39;,\u0026#39;n\u0026#39;,\u0026#39;o\u0026#39;], \u0026#39;7\u0026#39;:[\u0026#39;p\u0026#39;,\u0026#39;q\u0026#39;,\u0026#39;r\u0026#39;,\u0026#39;s\u0026#39;], \u0026#39;8\u0026#39;:[\u0026#39;t\u0026#39;,\u0026#39;u\u0026#39;,\u0026#39;v\u0026#39;], \u0026#39;9\u0026#39;:[\u0026#39;w\u0026#39;,\u0026#39;x\u0026#39;,\u0026#39;y\u0026#39;,\u0026#39;z\u0026#39;]} ans = [] def dfs(index, myStr: str): if index == n: ans.append(myStr) return for letter in m[digits[index]]: dfs(index + 1, myStr + letter) dfs(0, \u0026#34;\u0026#34;) return ans 39. 组合总和\n题干：在 30 个数中选任意个数（可重复），使其综合等于 target，返回全部可能的序列（去重）\n# 数据量小 能直接递归回溯 class Solution: def combinationSum(self, candidates: List[int], target: int) -\u0026gt; List[List[int]]: ans = set() # 去重用，注意其中不能装可变元素 n = len(candidates) def dfs(array: List[int], sum: int): nonlocal ans if sum \u0026gt; target: return if sum == target: array.sort() ans.add(tuple(array)) # 使 array 转成元组并哈希 return for i in range(n): newArray = array + [candidates[i]] dfs(newArray, sum + candidates[i]) dfs([], 0) output = [] for i in ans: output.append(i) return output 22. 括号生成\n题干：向生成 n 组合法的括号（n \u0026lt; 9），可能有哪些组合方法\n思路：暴力 + 剪枝，用省的左右括号数量做递归输入，如果剩下的右括号少于左括号，则不合法。\nclass Solution: def generateParenthesis(self, n: int) -\u0026gt; List[str]: ans = [] path = [] def dfs(l, r, path): nonlocal ans # print(l, r, path) if l \u0026lt; 0 or r \u0026lt; 0: return if l == 0 and r == 0: ans.append(deepcopy(path)) return if l \u0026gt; r: return path.append(\u0026#39;(\u0026#39;) dfs(l - 1, r, path) path.pop() path.append(\u0026#39;)\u0026#39;) dfs(l, r - 1, path) path.pop() dfs(n, n, path) output = [] for i in ans: s = \u0026#34;\u0026#34; for j in i: s += j output.append(s) return output 79. 单词搜索\n题干：想在单词矩阵中找“贪吃蛇”形状的某单词，不能走回头路\n输入： board = [[\u0026#39;A\u0026#39;,\u0026#39;B\u0026#39;,\u0026#39;C\u0026#39;,\u0026#39;E\u0026#39;], [\u0026#39;S\u0026#39;,\u0026#39;F\u0026#39;,\u0026#39;C\u0026#39;,\u0026#39;S\u0026#39;], [\u0026#39;A\u0026#39;,\u0026#39;D\u0026#39;,\u0026#39;E\u0026#39;,\u0026#39;E\u0026#39;]], word = \u0026#34;ABCCED\u0026#34; 输出：true 提示： [\u0026#39;*\u0026#39;,\u0026#39;*\u0026#39;,\u0026#39;*\u0026#39;,\u0026#39;E\u0026#39;], [\u0026#39;S\u0026#39;,\u0026#39;F\u0026#39;,\u0026#39;*\u0026#39;,\u0026#39;S\u0026#39;], [\u0026#39;A\u0026#39;,\u0026#39;*\u0026#39;,\u0026#39;*\u0026#39;,\u0026#39;E\u0026#39;] 思路：剪枝 + 回溯 DFS\n# 走格子回溯，注意优化和剪枝 class Solution: def exist(self, board: List[List[str]], word: str) -\u0026gt; bool: DIRS = [[0, 1], [1, 0], [-1, 0], [0, -1]] n = len(board) m = len(board[0]) t = len(word) ans = False # 下面是两个小优化 cnt = Counter(c for row in board for c in row) if not cnt \u0026gt;= Counter(word): # 如果 word 中的词频大于 board 直接返回 return False if cnt[word[-1]] \u0026lt; cnt[word[0]]: # 将词频更大的元素作为头 word = word[::-1] def dfs(i: int, x: int, y: int): nonlocal ans if ans: # 剪枝 return if i == t: ans = True return tmp = board[x][y] # 不走重复路，因此要回溯 board[x][y] = \u0026#34;.\u0026#34; for dx, dy in DIRS: nx = x + dx ny = y + dy if 0 \u0026lt;= nx \u0026lt; n and 0 \u0026lt;= ny \u0026lt; m: if board[nx][ny] == word[i]: dfs(i + 1, nx, ny) board[x][y] = tmp # 找字母的头 for i in range(n): for j in range(m): if board[i][j] == word[0]: dfs(1, i, j) return ans 131. 分割回文串\n题干：将一个字符串，切割为 N 个子字符串，保证每个子字符串是回文串，有多少种切割方法。\n输入：s = \u0026#34;aab\u0026#34;\r输出：[[\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;],[\u0026#34;aa\u0026#34;,\u0026#34;b\u0026#34;]] # 枚举字串结束的位置 class Solution: def partition(self, s: str) -\u0026gt; List[List[str]]: ans = [] path = [] n = len(s) def dfs(index): nonlocal s, ans # print(index, path) if index == n: ans.append(deepcopy(path)) for j in range(index + 1, n + 1): t = s[index:j] # 注意要先切片后再 reverse，否则切片值不一样 if t[::-1] == t: path.append(t) dfs(j) path.pop() dfs(0) return ans 51. N 皇后\n题干：经典中的经典，N 最大值是 9，返回棋盘\n思路：\n状态简化为 path，每个皇后情况其实就是长度为 N 的一维数组，其中 i，x 表示第 i 行的皇后在第 j 列。 记录 visited 的皇后位置，保证下一行皇后不与列重复。 用 check 检查对角线是否满足，其中 abs(new_x - old_x) == abs(new_y - old_y) 表示对角线有重叠。 递归输入当前到第 i 行，回溯并找到满足条件 23 的 path 即可，最后转化为棋盘。 class Solution: def solveNQueens(self, n: int) -\u0026gt; List[List[str]]: ans = [] path = [] visit = set() def check(arr: List[int]): # print(arr) if len(arr) == 0: return True last = arr[-1] last_i = len(arr) - 1 for i, x in enumerate(arr): if i == last_i: continue if abs(last_i - i) == abs(last - x): return False return True def dfs(i: int): if i == n: ans.append(path.copy()) for idx in range(n): if idx not in visit: # print(idx) path.append(idx) visit.add(idx) if check(path): # print(path, i) dfs(i + 1) path.pop() visit.remove(idx) dfs(0) output = [] for line in ans: line_output = [] for idx in line: s = \u0026#34;\u0026#34; # print(line) for i in range(n): if i != idx: s += \u0026#34;.\u0026#34; else: s += \u0026#39;Q\u0026#39; line_output.append(s) output.append(line_output) return output 二分查找 # 35. 搜索插入位置\n题干：找第一个大于等于 target 的下标\nclass Solution: def searchInsert(self, nums: List[int], target: int) -\u0026gt; int: l = 0 r = len(nums) while l \u0026lt; r: mid = l + r \u0026gt;\u0026gt; 1 if nums[mid] \u0026lt; target: # 如果找第一个大于 target，就此处改为 \u0026lt;= 。 l = mid + 1 else: r = mid return l # 等价库函数 # return bisect.bisect_left(nums, target) 74. 搜索二维矩阵\n题干：\n每行中的整数从左到右按非严格递增顺序排列。 每行的第一个整数大于前一行的最后一个整数。 找是否有一个数为 target\n思路：\n先根据每行最后一个数做二分查找，得到该数应该在那行，然后对该行二分查找。\nclass Solution: def searchMatrix(self, matrix: List[List[int]], target: int) -\u0026gt; bool: m = len(matrix) n = len(matrix[0]) l = 0 r = m while l \u0026lt; r: mid = l + r \u0026gt;\u0026gt; 1 if matrix[mid][-1] \u0026lt; target: l = mid + 1 else: r = mid line = l if line \u0026gt;= m: return False l = 0 r = n while l \u0026lt; r: mid = l + r \u0026gt;\u0026gt; 1 if matrix[line][mid] \u0026lt; target: l = mid + 1 else: r = mid if matrix[line][l] == target: return True return False 34. 在排序数组中查找元素的第一个和最后一个位置\n题干：找 bisect_left 和 bisect_right 的区间\n# 此题用于区分四种二分板子 （yxc 模板) class Solution: def searchRange(self, nums: List[int], target: int) -\u0026gt; List[int]: n = len(nums) if n == 0: return[-1, -1] # yxc 板子 # 这种写法是第一个大于等于 target # 若写出 nums[mid] \u0026lt;= target 则为第一个大于 target # 下面这种是 lower_bound 写出 \u0026lt;= 是 upper_bound l = 0 r = n - 1 while l \u0026lt; r : mid = l + r \u0026gt;\u0026gt; 1 if nums[mid] \u0026lt; target: l = mid + 1 else: r = mid first = l if nums[first] != target: return [-1 , -1] # 这种写法是最后一个小于等于 target # 若写出 nums[mid] \u0026gt;= target 则为第一个小于 target l = 0 r = n - 1 while l \u0026lt; r : mid = l + r + 1 \u0026gt;\u0026gt; 1 if nums[mid] \u0026gt; target: r = mid - 1 else: l = mid return [first, l] 33. 搜索旋转排序数组\n题干：一个有序数组，随机旋转了一次，O(logN) 找目标值\n输入：nums = [4,5,6,7,0,1,2], target = 0\r输出：4 思路：还是二分查找，但 check 的条件比较复杂，先判断左右哪边有序（一定有一边有序），然后在判断 target 应该在哪边。\n# 需要考虑很多边界值的二分查找 class Solution: def search(self, nums: List[int], target: int) -\u0026gt; bool: l = 0 r = len(nums) - 1 while l \u0026lt; r: mid = l + r \u0026gt;\u0026gt; 1 if target == nums[mid]: return mid # 若右半段有序 if nums[mid] \u0026lt; nums[r]: if nums[mid] \u0026lt; target \u0026lt;= nums[r]: l = mid + 1 else: r = mid else: if nums[l] \u0026lt;= target \u0026lt; nums[mid]: r = mid else: l = mid + 1 return l if nums[l] == target else -1 153. 寻找旋转排序数组中的最小值\n题干：有序数组旋转后，O(logN) 找最小值\n思路：上面那题的简化版\nclass Solution: def findMin(self, nums: List[int]) -\u0026gt; int: n = len(nums) l = 0 r = n - 1 while l \u0026lt; r: mid = l + r \u0026gt;\u0026gt; 1 if nums[mid] \u0026gt; nums[r]: l = mid + 1 else: r = mid return nums[l] 4. 寻找两个正序数组的中位数\n题干：找两个递增数组的中位数，要求O(log (m+n))\n思路：\n① 若 a=b，则a或b为所求中位数，算法结束。\n② 若a\u0026lt;b，则舍弃序列A中较小的一半，同时舍弃序列 B中较大的一半。\n③ 若a\u0026gt;b，则舍弃序列A中较大的一半，同时舍弃序列 B中较小的一半。\n注意：下面代码实际上不是严格 O(log (m+n))。\n# ① 若 a=b，则a或b为所求中位数，算法结束。 # ② 若a\u0026lt;b，则舍弃序列A中较小的一半，同时舍弃序列 B中较大的一半。 # ③ 若a\u0026gt;b，则舍弃序列A中较大的一半，同时舍弃序列 B中较小的一半。 class Solution: def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -\u0026gt; float: def get_mid(arr, l, r): if (r - l + 1) % 2 == 0: return (arr[(l + r) // 2] + arr[(l + r) // 2 + 1]) / 2 else: return arr[(l + r) // 2] n1 = len(nums1) n2 = len(nums2) l1, l2 = 0, 0 r1, r2 = n1 - 1, n2 - 1 # 只要有一个数组长度降到了 2 或更少 就停止 while (r1 - l1 \u0026gt; 1) and (r2 - l2 \u0026gt; 1): m1 = get_mid(nums1, l1, r1) m2 = get_mid(nums2, l2, r2) mid1_index = (l1 + r1) // 2 mid2_index = (l2 + r2) // 2 # 步长必须由较短的那一半决定，防止长数组切多了，或者短数组切空了 shift = min(mid1_index - l1, mid2_index - l2) # 步长至少为 1 if shift == 0: shift = 1 if m1 == m2: return m1 if m1 \u0026lt; m2: # 舍弃 nums1 左边，nums2 右边 l1 = l1 + shift r2 = r2 - shift else: # 舍弃 nums1 右边，nums2 左边 r1 = r1 - shift l2 = l2 + shift # 此时至少有一个数组长度 \u0026lt;= 2。 # 由于剩余元素很少（对于 LeetCode 数据规模），直接合并排序是安全的。 last = nums1[l1:r1+1] + nums2[l2:r2+1] last.sort() n = len(last) if n == 0: return 0 if n % 2 == 1: return last[n // 2] else: return (last[n // 2 - 1] + last[n // 2]) / 2 return -1 栈 # 20. 有效的括号\n题干：判断括号串有“（{[”是否合法，其中不能出现交错\nclass Solution: def isValid(self, s: str) -\u0026gt; bool: stack = [] for c in s: if c == \u0026#39;(\u0026#39;: stack.append(0) if c == \u0026#39;[\u0026#39;: stack.append(1) if c == \u0026#34;{\u0026#34;: stack.append(2) if c == \u0026#39;)\u0026#39;: if not stack or stack[-1] != 0: return False stack.pop() if c == \u0026#39;]\u0026#39;: if not stack or stack[-1] != 1: return False stack.pop() if c == \u0026#39;}\u0026#39;: if not stack or stack[-1] != 2: return False stack.pop() if not stack: return True return False 155. 最小栈\n题干：构造一个可以 O1 找到最小元素的栈\n思路：用原始栈 + 单调栈模拟，此题单调栈是非严格单调递减。如果插入小于等于单调栈尾，插入两个栈。如果普通栈尾和单调栈尾相同，弹出两者。\n# 用栈 + 单调栈模拟 # 此题单调栈是非严格单调递减，记录当前最小值 class MinStack: def __init__(self): self.stack = [] self.min_stack = [] # 如果插入小于等于单调栈尾，插入单调栈 def push(self, val: int) -\u0026gt; None: if not self.min_stack: self.stack.append(val) self.min_stack.append(val) return if val \u0026lt;= self.min_stack[-1]: self.stack.append(val) self.min_stack.append(val) else: self.stack.append(val) # 如果普通栈尾和单调栈尾相同，弹出两者 def pop(self) -\u0026gt; None: if self.stack[-1] == self.min_stack[-1]: self.min_stack.pop() self.stack.pop() else: self.stack.pop() def top(self) -\u0026gt; int: return self.stack[-1] def getMin(self) -\u0026gt; int: self.min_stack.append(self.stack[-1]) return self.min_stack[-1] 394. 字符串解码\n题干：\n给定一个经过编码的字符串，返回它解码后的字符串。\n编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。\n输入：s = \u0026#34;3[a]2[bc]\u0026#34;\r输出：\u0026#34;aaabcbc\u0026#34; 输入：s = \u0026#34;3[a2[c]]\u0026#34;\r输出：\u0026#34;accaccacc\u0026#34; 输入：s = \u0026#34;2[abc]3[cd]ef\u0026#34;\r输出：\u0026#34;abcabccdcdcdef\u0026#34; 思路：维护当前字符串和 栈，栈里面维护之前的字符串和需要重复的数量，优雅写法如下\nclass Solution: def decodeString(self, s: str) -\u0026gt; str: stack = [] current_num = 0 current_str = \u0026#34;\u0026#34; for c in s: if \u0026#39;0\u0026#39; \u0026lt;= c \u0026lt;= \u0026#39;9\u0026#39;: current_num = current_num * 10 + int(c) elif c == \u0026#39;[\u0026#39;: # 数字和当前字符串入栈 stack.append((current_str, current_num)) current_str = \u0026#34;\u0026#34; current_num = 0 elif c == \u0026#39;]\u0026#39;: # 出栈并构造新的字符串 last_str, repeat_num = stack.pop() current_str = last_str + current_str * repeat_num else: # 普通字符追加 current_str += c return current_str 739. 每日温度\n题干：找数组中 “下一个更大” 的位置，返回每个点和下一个更大的距离。\n思路：标准单调栈，记录一个单调递减栈，当有大于顶的元素时，弹出栈并维护答案。\nclass Solution: def dailyTemperatures(self, temperatures: List[int]) -\u0026gt; List[int]: n = len(temperatures) stack = [] ans = [0] * n for i in range(n): # print(i, stack) while stack and temperatures[stack[-1]] \u0026lt; temperatures[i]: ans[stack[-1]] = i - stack[-1] stack.pop() stack.append(i) return ans 84. 柱状图中最大的矩形\n题干：获取一个柱状图中的最大矩阵\n输入：heights = [2,1,5,6,2,3] 输出：10 解释：最大的矩形为图中*区域，面积为 10 高度 6 | █ 5 | * * 4 | * * 3 | * * █ 2 | █ * * █ █ 1 | █ █ * * █ █ █ 0 1 2 3 4 5 思路：\n和接雨水思路一样用前缀后缀，但由于需要记录第一个小于 X 的位置，不能和接雨水一样直接双指针。\n记录每个点前第一个和后第一个比他小的位置，对每个元素，由于左右区间内一定大于等于 height[i]，因此则 heights[i] * (right[i] - left[i] - 1) 就是以改点为基准的最大值。遍历所有的最大值的就是答案。\n想找到每个点前第一个和后第一个比他小的位置，就用到单调递增栈。\nclass Solution: def largestRectangleArea(self, heights: List[int]) -\u0026gt; int: stack = [] n = len(heights) left = [-1] * n # 用单调栈找左边第一个比自身小的 # ans = 0 for i in range(n): while stack and heights[stack[-1]] \u0026gt;= heights[i]: stack.pop() if stack: left[i] = stack[-1] stack.append(i) right = [n] * n # 用单调栈找右边第一个比自身小的 stack.clear() for i in range(n - 1, -1, -1): while stack and heights[stack[-1]] \u0026gt;= heights[i]: stack.pop() if stack: right[i] = stack[-1] stack.append(i) # 对每个元素，由于左右区间内一定大于等于 height[i] # 则 heights[i] * (right[i] - left[i] - 1) 就是包含区间的答案 ans = 0 for i in range(n): ans = max(ans, heights[i] * (right[i] - left[i] - 1)) return ans 堆 # 215. 数组中的第K个最大元素\ntopK 问题，长度 N 的数组中找到第 K 个元素。\n堆：时间 O(N*logK)，空间 O(K) 快速选择：时间平均 ON，最坏 ON2，空间 O1 BFPRT：用五分中位数的中位数做 pivot，最坏 ON # 第 K 大用 小跟堆 class Solution: def findKthLargest(self, nums: List[int], k: int) -\u0026gt; int: pq = [] for i, x in enumerate(nums): if len(pq) \u0026gt;= k: heapq.heappush(pq, x) heapq.heappop(pq) else: heapq.heappush(pq, x) return pq[0] 347. 前 K 个高频元素\n题干：找数组前 K 个频率的元素。\n思路：Counter 后找 TopK 即可，注意 heapq 中用 cnt 做 key。\nclass Solution: def topKFrequent(self, nums: List[int], k: int) -\u0026gt; List[int]: m = Counter(nums) pq = [] for i, j in m.items(): if len(pq) \u0026gt;= k: heapq.heappush(pq, (j, i)) heapq.heappop(pq) else: heapq.heappush(pq, (j, i)) ans = [] while pq: ans.append(pq[0][1]) heapq.heappop(pq) return ans 295. 数据流的中位数\n题干：想让 O logN 插入，能 O1 找到当前数据流的中位数\n思路：一半大根堆，一半小根堆。想让两者长度相同，在遇到一个新元素时候，现在对面的堆里面洗一下，然后弹出到另一边。\nclass MedianFinder: def __init__(self): # 小顶堆（存较大的一半） self.smallPQ = [] # 大顶堆（存较小的一半，存入负数以模拟大顶堆） self.bigPQ = [] def addNum(self, num: int) -\u0026gt; None: if len(self.smallPQ) != len(self.bigPQ): # 先将 num 放入小顶堆，然后将堆顶移到大顶堆 heapq.heappush(self.smallPQ, num) heapq.heappush(self.bigPQ, -heapq.heappop(self.smallPQ)) else: # 先将 num 放入大顶堆，然后将堆顶移到小顶堆 heapq.heappush(self.bigPQ, -num) heapq.heappush(self.smallPQ, -heapq.heappop(self.bigPQ)) def findMedian(self) -\u0026gt; float: if len(self.smallPQ) != len(self.bigPQ): return self.smallPQ[0] else: return (self.smallPQ[0] - self.bigPQ[0]) / 2.0 贪心 # 121. 买卖股票的最佳时机\n题干：\n给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n返回你可以从这笔交易中获取的最大利润。\n输入：[7,1,5,3,6,4] 输出：5 解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。 思路：直接找前缀最小即可，或者如果递增直接卖。这道题应该和股票买卖234一起看。\nclass Solution: def maxProfit(self, prices: List[int]) -\u0026gt; int: pre_min = inf n = len(prices) ans = 0 for i in range(n): pre_min = min(pre_min, prices[i]) ans = max(ans, prices[i] - pre_min) return ans 55. 跳跃游戏\n题干：数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够从第一个下标到达最后一个下标。\n思路：遍历并维护当前能跳到的最远下标，如果当前下标大于之前能跳到的最远下标，说明不能完成任务。注意不要遍历到最后一个点。\nclass Solution: def canJump(self, nums: List[int]) -\u0026gt; bool: fast = 0 n = len(nums) # 遍历到 n - 2 for i in range(0, n - 1): fast = max(fast, i + nums[i]) # 如果到最后一个之前就卡住了 if fast \u0026lt;= i: return False return True 45. 跳跃游戏 II\n题干：包装上面情景下一定能走到最后下标，想得到最短的跳跃次数。\n输入: nums = [2,3,1,1,4]\r输出: 2\r解释: 跳到最后一个位置的最小跳跃数是 2。\r从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。 思路：同样维护当前能走到的最远位置 fast 和上一次跳跃到的最远位置 slow，如果 i 走到上一次跳跃的最短位置 slow，则说明需要再跳一次，就跳到当前可以跳到的最远位置 fast。\nclass Solution: def jump(self, nums: List[int]) -\u0026gt; int: fast = 0 slow = 0 ans = 0 n = len(nums) # 遍历到 n - 2 for i in range(0, n - 1): fast = max(fast, i + nums[i]) if i == slow: ans += 1 slow = fast return ans 763. 划分字母区间\n题干：想让尽可能多的切割一个字符串，让同一字母最多出现在一个子字符串中。\n思路：记录每个字母的第一次出现和最后一次出现，就是一个字母的最小区间，之后思路和合并区间完全一样。\nclass Solution: def partitionLabels(self, s: str) -\u0026gt; List[int]: m = defaultdict(lambda : [-1, -1]) for i, c in enumerate(list(s)): if m[c][0] == -1: m[c][0] = i m[c][1] = i else: m[c][1] = i intervals = list(m.values()) # print(intervals) def merge(intervals: List[List[int]]) -\u0026gt; List[List[int]]: intervals.sort() ans = [] l = intervals[0][0] r = intervals[0][1] for x, y in intervals: if x == -1 or y == -1: continue if x \u0026lt;= r: r = max(y, r) else: ans.append([l, r]) l = x r = y ans.append([l, r]) return ans ans = [] res = merge(intervals) for i, j in res: ans.append(j - i + 1) return ans 动态规划 # 70. 爬楼梯\n题干：求斐波那契数列\n思路：最简单的 DP，如果用通式或者矩阵快速幂可以做到 OlogN\nclass Solution: def climbStairs(self, n: int) -\u0026gt; int: dp = [0] * (n + 1) dp[0] = 1 dp[1] = 1 for i in range(2, n + 1): dp[i] = dp[i - 1] + dp[i - 2] return dp[n] 118. 杨辉三角\n题干：模拟一个杨辉三角\nclass Solution: def generate(self, numRows: int) -\u0026gt; List[List[int]]: ans = [[] for _ in range(numRows)] ans[0].append(1) for i in range(1, numRows): ans[i].append(1) for y in range(1, len(ans[i - 1])): ans[i].append(ans[i - 1][y - 1] + ans[i - 1][y]) ans[i].append(1) return ans 198. 打家劫舍\n题干：典中典的 打家劫舍，即不能偷两个相邻的房子，问最大能偷多少。\n输入：[1,2,3,1]\r输出：4\r解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。\r偷窃到的最高金额 = 1 + 3 = 4 。 思路：DP 维护 “到该点最多偷多少”\n状态转移：dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\nclass Solution: def rob(self, nums: List[int]) -\u0026gt; int: ans = 0 n = len(nums) if n == 1: return nums[0] if n == 2: return max(nums[0], nums[1]) dp = [0] * n dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, n): dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]) ans = max(ans, dp[i]) print(dp) return ans 思考：如果是环形，则直接讨论第一个位置有没有被打，如果被打了就对后面 [2 , n - 2] 做打家劫舍，如果没有，就对后面 [2, n - 1] 做打家劫舍。\n279. 完全平方数\n题干：给你一个整数 n ，返回 和为 n 的完全平方数的最少数量。\n思路：明显的完全背包，其中 1 - int(sqrt(n)) 是可以选的物品，n 是背包容量。因此用 DP 表示背包容量为 i 时，正好填满的物品最小数量。\n状态转移方程 dp[i + j * j] = min(dp[i + j * j], dp[i] + 1)\n此外，此题也可以数学 O1 做出来。\nclass Solution: def numSquares(self, n: int) -\u0026gt; int: high = int(sqrt(n)) dp = [inf] * (n + 1) dp[0] = 0 for i in range(n + 1): for j in range(1, high + 1): if i + j * j \u0026lt;= n: dp[i + j * j] = min(dp[i + j * j], dp[i] + 1) return dp[n] 322. 零钱兑换\n题干：给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额，计算凑到总金额的最小硬币个数。\n思路：还是完全背包问题，多了一个可能背包凑不满的情况\n状态转移方程：dp[i + j] = min(dp[i + j], dp[i] + 1)\nclass Solution: def coinChange(self, coins: List[int], amount: int) -\u0026gt; int: n = amount dp = [inf] * (n + 1) dp[0] = 0 for i in range(n + 1): for j in coins: if i + j \u0026lt;= n: dp[i + j] = min(dp[i + j], dp[i] + 1) return dp[n] if dp[n] != inf else -1 思考：零钱兑换Ⅱ是返回凑到amount的硬币种类的数量，那么此题就要先遍历coins 再遍历 i，然后用状态转移方程 dp[i + j] += dp[i]\nclass Solution: def change(self, amount: int, coins: List[int]) -\u0026gt; int: n = amount dp = [0] * (n + 1) dp[0] = 1 for j in coins: for i in range(n + 1): if i + j \u0026lt;= n: dp[i + j] += dp[i] # print(dp) print(dp) return dp[n] 139. 单词拆分\n题干：给你一个字符串 s 和一个字符串列表 wordDict 。如果可以利用wordDict中出现的一个或多个单词拼接出 s 则返回 true。可以重复使用。\n思路：同样还是类似完全背包的动态规划，其中 dp 表示以 i 为截至的字符串能不能被凑出来。如果想节省复杂度，可以用 wordDict 记录每个的长度，然后切片得到子字符串，这样就和完全背包几乎一样。\n状态转移方程 ：dp[j] = dp[i] or dp[j] if s[i:j] in m\nclass Solution: def wordBreak(self, s: str, wordDict: List[str]) -\u0026gt; bool: m = set(wordDict) n = len(s) dp = [False] * (n + 1) dp[0] = True for i in range(n + 1): for j in range(i + 1, n + 1): if s[i:j] in m: dp[j] = dp[i] or dp[j] print(dp) return dp[n] 300. 最长递增子序列\n题干：找到最长递增子序列的长度（子序列是指对每个元素选或不选而不改变顺序的集合）。\n思路：\nDP + 二分查找，遍历并用 tails 记录当前 i 下所有可能的子序列长度对应的最小值。\n比如 [1, 3, 4, 2, 5] 遍历完后，tails 应该是 [1, 2, 4, 5]，所以 tails 一定是单调递增的。\n遍历过程中可以对其二分查找，找 nums[i] 在 tails 对应的位置，如果最后 l 与 tails 长度相同，则说明 tails 可以扩充，否则修改 tails[l] 的最小值\nclass Solution: def lengthOfLIS(self, nums: List[int]) -\u0026gt; int: n = len(nums) tails = [] tails.append(nums[0]) for i in range(1, n): l = 0 r = len(tails) while l \u0026lt; r: mid = l + r \u0026gt;\u0026gt; 1 if tails[mid] \u0026lt; nums[i]: l = mid + 1 else: r = mid # print(tails, l, nums[i]) if l == len(tails): tails.append(nums[i]) else: tails[l] = min(nums[i], tails[l]) return len(tails) 152. 乘积最大子数组\n题干：找出数组中乘积最大的非空连续 子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。\n思路：用二维 DP 记录包含 i 位置的最大和最小元素，如果是 num 就向前对应，如果是负数就 相互取反。\nclass Solution: def maxProduct(self, nums: List[int]) -\u0026gt; int: # dp 表示包含 i 位置的最大和最小元素 n = len(nums) dp = [[0, 0] for _ in range(n + 1)] dp[0] = [1, 1] ans = nums[0] # 初始化为第一个元素 for i in range(1, n + 1): cur = nums[i - 1] if cur \u0026lt; 0: dp[i][0] = max(cur, dp[i - 1][1] * cur) dp[i][1] = min(cur, dp[i - 1][0] * cur) elif cur \u0026gt; 0: dp[i][0] = max(cur, dp[i - 1][0] * cur) dp[i][1] = min(cur, dp[i - 1][1] * cur) else: dp[i][0] = 0 dp[i][1] = 0 ans = max(ans, dp[i][0]) print(dp) return ans 416. 分割等和子集\n题干：给你一个 只包含正整数 的 数组 nums 。判断是否可以将这个数组分割成两个子集使其 sum 相等。\n思路：目标是在数组中选到和为 sum(nums) // 2 的数，本质上还是一个物品只能选一次的背包问题，如果一开始 sum 是偶数直接返回。\ndp[i][j] 表示为，前 j 个数能否表达出 sum 为 i 。\n因此状态转移方程为：dp[i][j] = dp[i][j - 1] or dp[i - x][j - 1] or dp[i][j] 即不选 j 和选 j 的情况。\n# 目标是在数组中选到和为 sum(nums) // 2 的数 # 本质上还是一个物品只能选一次的背包问题 class Solution: def canPartition(self, nums: List[int]) -\u0026gt; bool: all = sum(nums) n = len(nums) if all % 2 == 1: # all 必须为偶数 return False target = all // 2 # 前 j 个数能否表达出 sum 为 i dp = [[False] * n for _ in range(target + 1)] for i in range(n): if nums[i] \u0026gt; target: return False dp[0][i] = True for i in range(target + 1): for j in range(1, n): x = nums[j] dp[i][j] = dp[i][j - 1] if i - x \u0026gt;= 0: dp[i][j] = dp[i - x][j - 1] or dp[i][j] return dp[-1][-1] 32. 最长有效括号\n题干：找括号串中，有效部分的最长大小\n输入：s = \u0026#34;)()())\u0026#34;\r输出：4\r解释：最长有效括号子串是 \u0026#34;()()\u0026#34; 思路：用 stack 模拟找到出错的位置，之后就变成找未错位置中最长的串就可以。这题和动态规划关系不大。\nclass Solution: def longestValidParentheses(self, s: str) -\u0026gt; int: n = len(s) unmatch = [0] * n stack = [] for i in range(n): c = s[i] if not stack and c == \u0026#39;)\u0026#39;: unmatch[i] = 1 # 出错 elif c == \u0026#39;)\u0026#39;: stack.pop() if c == \u0026#39;(\u0026#39;: stack.append(i) for i in stack: # 剩下的栈也是错的 unmatch[i] = 1 # 找最长的连续零 l = -1 r = -1 ans = 0 for i in range(n): if unmatch[i]: r = i ans = max(ans, r - l - 1) l = i return max(ans, n - r - 1) 多维动态规划 # 62. 不同路径\n题干：一个机器人位于一个 m x n 网格的左上角，可以向左或向右走一步，问一共有多少条不同的路径。\n思路：组合数即可，机器人共走 m + n - 2 步，总步数中选 m - 1 步就是答案（理解为找出机器人向右走的占总步数中的哪些部分，就是一共多少路径）\nclass Solution: def uniquePaths(self, m: int, n: int) -\u0026gt; int: return comb(m + n - 2, m - 1) 64. 最小路径和\n题干：给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左t上角到右下角的路径，使得路径上的数字总和为最小。\n输入：grid = [[1,3,1],[1,5,1],[4,2,1]]\r输出：7\r解释：因为路径 1→3→1→1→1 的总和最小。 思路：记忆化搜索走迷宫，相当于每次只有向右和向下两种选择。\nclass Solution: def minPathSum(self, grid: List[List[int]]) -\u0026gt; int: m = len(grid) n = len(grid[0]) @cache def dfs(i: int, j: int) -\u0026gt; int: if i == 0 and j == 0: return grid[i][j] elif i == 0: return dfs(i, j - 1) + grid[i][j] elif j == 0: return dfs(i - 1, j) + grid[i][j] return min(dfs(i - 1, j), dfs(i, j - 1)) + grid[i][j] return dfs(m - 1, n - 1) 5. 最长回文子串\n题干：找数组中的最长回文子串（子串一定连续）\n思路：\n中心扩散动态规划，即区间 DP 的一种，dp[i][j] 表示从 i - j 的回文字串长度，先遍历 j ，再从 j 向前遍历 i，从而实现从中间遍历到两边。时间复杂度 ON2 马拉车算法实现 ON class Solution: def longestPalindrome(self, s: str) -\u0026gt; str: n = len(s) dp = [[-inf] * n for _ in range(n)] mx = 0 index = 0 # 用 index 维护最大值的位置 for j, y in enumerate(s): for i in range(j, -1, -1): x = s[i] if j \u0026lt; i: continue if i == j: dp[i][j] = 1 if mx \u0026lt; 1: index = i mx = 1 if i == j - 1 and x == y: dp[i][j] = 2 if mx \u0026lt; 2: index = i mx = 2 if x == y and j - i \u0026gt;= 2: if mx \u0026lt; dp[i + 1][j - 1] + 2: index = i mx = dp[i + 1][j - 1] + 2 dp[i][j] = max(dp[i + 1][j - 1] + 2, dp[i][j]) # print(dp) return s[index:index + mx] 1143. 最长公共子序列\n题干：给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度\n输入：text1 = \u0026#34;abcde\u0026#34;, text2 = \u0026#34;ace\u0026#34; 输出：3 解释：最长公共子序列是 \u0026#34;ace\u0026#34; ，它的长度为 3 。 思路：用 dp[i][j] 表示遍历到 i j 时最长公共序列长度，当 t1[i] == t2[j] 的时候 +1, 然后分别跳过 i 和 j。\n下面用记忆化搜索，写起来简单点\nclass Solution: def longestCommonSubsequence(self, text1: str, text2: str) -\u0026gt; int: @cache def dfs(i, j): if i \u0026lt; 0 or j \u0026lt; 0: return 0 if text1[i] == text2[j]: return dfs(i - 1, j - 1) + 1 return max(dfs(i, j - 1), dfs(i - 1, j)) return dfs(len(text1) - 1, len(text2) - 1) 72. 编辑距离\n给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数 。\n你可以对一个单词进行如下三种操作：\n插入一个字符 删除一个字符 替换一个字符 输入：word1 = \u0026#34;horse\u0026#34;, word2 = \u0026#34;ros\u0026#34;\r输出：3\r解释：\rhorse -\u0026gt; rorse (将 \u0026#39;h\u0026#39; 替换为 \u0026#39;r\u0026#39;)\rrorse -\u0026gt; rose (删除 \u0026#39;r\u0026#39;)\rrose -\u0026gt; ros (删除 \u0026#39;e\u0026#39;) 思路：\n状态机 DP，dp[i][j]设置为前 i 个 word1 转变为 前 j 个 word2 的编辑距离。\n有初始化：当 i == 0 时 dp[i][j] = j 同样，j == 0 时 dp[i][j] = i，这可以理解为全部删除 word1 串，和将空串添加为 word2 串。\n如果 word1[i ] == word2[j] 则不需要增加编辑距离，其他情况下，有状态转移方程 min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1 可以视作分别做 ”删、增、改“\n# 记忆化搜索 class Solution: def minDistance(self, word1: str, word2: str) -\u0026gt; int: n = len(word1) m = len(word2) @cache def dfs(i, j): if i \u0026lt; 0: return j + 1 if j \u0026lt; 0: return i + 1 if word1[i] == word2[j]: return dfs(i - 1, j - 1) return min(dfs(i - 1, j), dfs(i, j - 1), dfs(i - 1, j - 1)) + 1 return dfs(n - 1, m - 1) # 递推 class Solution: def minDistance(self, word1: str, word2: str) -\u0026gt; int: n = len(word1) m = len(word2) dp = [[0] * (m + 1) for _ in range(n + 1)] for i in range(n + 1): dp[i][0] = i # 将 word1 的前 i 个字符变为空字符串，需要 i 次删除 for j in range(m + 1): dp[0][j] = j # 将空字符串变为 word2 的前 j 个字符，需要 j 次插入 for i in range(1, n + 1): for j in range(1, m + 1): if word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + 1) return dp[n][m] 技巧 # 136. 只出现一次的数字\n题干：数组除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。\n思路：异或和即可\nclass Solution: def singleNumber(self, nums: List[int]) -\u0026gt; int: ans = 0 for num in nums: ans ^= num return ans 169. 多数元素\n题干：找数组中大于等于一半数量的元素\n思路：摩尔计数法，记录当前最多元素 X。当出现 X，则 cnt + 1， 出现其他元素则 cnt - 1。当 cnt \u0026lt;= 0 时候，改 X 为当前遍历到的元素。\nclass Solution: def majorityElement(self, nums: List[int]) -\u0026gt; int: count = 0 candidate = nums[0] for num in nums: if num == candidate: count += 1 else: if count \u0026gt; 0: count -= 1 else: count = 1 candidate = num return candidate 75. 颜色分类\n题干：荷兰国旗问题，数组中只有 0, 1, 2 如何快速排序\n思路：用 p1，p2 记录当前遍历到的 0 和 2 的数量，分别指向前 p1 位置和后 p2 位置，swap 直到满足 nums[i] == 1。\n# 荷兰国旗问题 class Solution: def sortColors(self, nums: List[int]) -\u0026gt; None: n = len(nums) p0 = 0 p2 = n - 1 for i in range(n): while i \u0026lt; p2 and nums[i] == 2: nums[i], nums[p2] = nums[p2], nums[i] p2 -= 1 while nums[i] == 0 and i \u0026gt; p0: nums[i], nums[p0] = nums[p0], nums[i] p0 += 1 return nums 31. 下一个排列\n题干：找数组中下一个排序，希望原地修改。\n输入：nums = [1,2,3]\r输出：[1,3,2]\r找规律：\r[1, 2, 3, 4]\r[1, 2, 4, 3]\r[1, 3, 2, 4]\r[1, 3, 4, 2]\r[1, 4, 2, 3]\r[1, 4, 3, 2]\r[2, 1, 3, 4]\r[2, 1, 4, 3] 思路：\n由上面的规律，可以发现找下一个排序的规律：\n如果当前数组为全部降序，则说明此时已经最大，下一个是全部取反。 从后往前找第一个升序（arr[i] \u0026gt; arr[i + 1]）的位置 i，x。 从后往前找第一个比 x 大的位置：j，y。 交换 i， j 的位置，此时 i 之后的数一定是降序，将之后的的位置反转为升序。 思考：如果改成 “上一个排序”，则同样是找规律，把降序升序换一下就可以。\nclass Solution: def nextPermutation(self, nums: List[int]) -\u0026gt; None: \u0026#34;\u0026#34;\u0026#34; Do not return anything, modify nums in-place instead. \u0026#34;\u0026#34;\u0026#34; n = len(nums) # 从后向前找最后一个非升序的下标 idx1 = -1 for i in range(n - 2, -1, -1): if nums[i + 1] \u0026gt; nums[i]: idx1 = i break if idx1 == -1: # 如果全部降序，相当于是最大序列。下一个是最小序列，需要特判。 return nums.reverse() # 从后往前找最后一个大于 nums[idx1] 的 idx2 = -1 for i in range(n - 1, -1, -1): if nums[i] \u0026gt; nums[idx1]: idx2 = i break # 交互下标 nums[idx1], nums[idx2] = nums[idx2], nums[idx1] # 将 idx1 后面的降序子数组改成升序 nums[idx1+1:] = reversed(nums[idx1+1:]) # 实际上会产生临时内存，如果想空间 O1 可以双指针反转 287. 寻找重复数\n题干：数组中只有一个重复的数，想不修改数组的情况下 O1 空间找到该数。数组中全部数字都在 [1, n] 中。\n思路：将数字映射视为链表，然后和双指针找环入口一样。\n# 将数组映射视作链表，之后就与快慢指针找环入口一致 class Solution: def findDuplicate(self, nums: List[int]) -\u0026gt; int: n = len(nums) slow = fast = 0 while True: fast = nums[nums[fast]] slow = nums[slow] if fast == slow: break fast = 0 while True: fast = nums[fast] slow = nums[slow] if fast == slow: return fast return 0 备忘录 # 完整输入输出 # 尤其涉及到 class 的代码，类和完整输入输出可能会忘了怎么写。\n下面以反转链表的题目为例，完整版本如下。\nimport os class node(): def __init__(self, val = -1, next = None): self.val = val self.next = next def reversed_list(head): pre = None cur = head while cur: tmp = cur.next cur.next = pre pre = cur cur = tmp return pre def build(arr): dummy = node() cur = dummy for i in arr: tmp = node(i) cur.next = tmp cur = cur.next return dummy def print_node(head): cur = head while cur: print(cur.val, end=\u0026#34; \u0026#34;) cur = cur.next if __name__ == \u0026#39;__main__\u0026#39;: arr = list(map(int, input().split())) head = build(arr).next head_re = reversed_list(head) print_node(head_re) import 包 # import sys import math from collections import * from heapq import * from bisect import * from functools import * # 递归防止爆栈 sys.setrecursionlimit(10**6) ","date":"2025 年 11 月 21 日","externalUrl":null,"permalink":"/posts/hot100/","section":"","summary":"","title":"重生之我还在做 HOT100 ","type":"posts"},{"content":" 本文主要目前是让同学们减少些保研路上的焦虑。共两千字，需要阅读十分钟 本人背景 与 本文目的 # 我的最终去向是复旦机器人学院的电子信息（计算机技术），且导师比较符合我的期望。\n包括我之内的许多人都很喜欢看往届的经验贴，企图从中总结出一个 “bg → 去处” 的对应关系，但实际上保研是完全的混沌体系。与其看再多往届经验贴，不如想想保研经历能给自己带来什么？\n我希望看到的同学能减缓些焦虑，从“长期非功利”的角度思考，即使自己保研去处不够好，也能从保研过程中有所收获。（当然下面很多内容仅仅局限于计算机类专业，隔行如隔山，我只了解本专业的情况）\n（叠个甲，因为我是从个人视角看，因此可能无意冒犯到一些没有选择保研或者与我意见相左的同学。我非常尊重工作、留学、考研的同学，其中很多同学的能力都非常强，希望每个奋斗在前行路上的同学都能收获自己的理想果实。）\n保研明面上的收益 # 保研可以选择直博，如果自己目标明确且足够了解导师，那直博可以节省 1-3 年的时间，获得人类最高学历。当然“硕转博“在大部分组也有机会五年毕业。 稳定拿下硕博offer，即使有些学校不保护本校，有些人会在保研系统开始后赌鸽穿，但最后所有人都能有学上。（25年同样鸽穿了很多学校，比如北航ai、复旦cs、西交ailab联培等）。 拿到学硕的机会相比考研更大，虽然保研学硕的竞争还是比专硕大很多，但考研学硕都只招收个位数显然更加困难。（有传言未来将全面取消学硕）。 更简单的跨专业保研的能力，尤其本科计算机类转其他专业，ai4xx 几乎所有学科都在做。这意味着保研有更多的选择空间。 小部分项目仅招生保研学生（更多是联培）。 可以提前了解并选择老师，小部分强组强导更偏向保研或本校学生。 相比考研能多gap半年，无论是旅游、谈恋爱、实习、RA，都可以利用好这半年，之后gap的机会可能越来越少。 保研对我潜移默化的影响 # 那除了上述的明面上的好处，经历保研这一年还有一些潜移默化的影响：\n保研流程和简历都更接近找工作，尤其计算机类很大程度上抛弃了传统应试思维。有些同学的保研简历稍微改改就能投对口实习。 投项目、选offer等过程都是一个询问自己到底想要什么的机会，越早确定职业的规划，就越能专注于自己的目标。 提升面试、社交能力，不管是向上社交还是同届社交。我身边的同学去向很明显和社交能力正相关，信息获取和科研都严重依赖于社交能力。 祛魅与社会化。这条可能不针对于保研，从大三下开始，大部分同学的“学生气”明显减少。毕竟无论是工作还是读研，本质上都是老板与雇员的关系。本科中“自由人”的感觉都一去不复返。 抗压能力提升，保研这一年大部分人都会面对无数次的失败与拒绝，科研、陶瓷、入营、优营都可能面对大量的负反馈。能在负反馈强度高的情况下依然保持热情是一个很重要的能力。 由于保研过程中的社交行为非常普遍，因此大概率能收获一些新朋友。比如线下的夏令营与预推免都是很好的社交场合。 今年计算机类保研乱象还是比较夸张的，比如说老师学生互鸽、幻神海投集邮、学术造假、放假情报等等。能在焦虑环境下保持真诚与初心更值得尊敬。 如何选好自己的路（最建议看） # 如果有些同学的目标特别明确，就你的保研路会方便很多。\n要冲大厂算法的人才计划，那直博好方向的强组或者能推业界实习的老师可能更适合你。 如果想算法、且自己内驱力强，那羊导+企业科研/实习也是一种好选择。 稳一手选大厂开发，那更倾向羊导放实习加上学校有地域优势。 打算选调考公和央国企，那最好拿到专业代码0812、学校title、老师放羊。 打算冲教职，那可能强组硕/博 + 申海外博士/博士后的思路更加合适，同时可以选择容易出成果但业界应用少的“屠龙术”方向。 如果你就想去某些特定的企业（比如腾讯、三桶油、研究所等等），那选择对应联培的工程硕博是最好的思路。 打算摆烂回家继承家业，那必须选择好的城市和完全不管的老师。 为什么焦虑并没有意义 # 当然大部分同学可能没想好自己未来要做什么（想提前三五年预测未来也实在不太可能），所以大家会想让最终去处在各方面都是最优。学校title、专业代码、老师学术能力与资源、老师人品、研究方向、是否放实习、学校城市；甚至是不是在郊区、宿舍条件好不好、学费贵不贵、学校/组内氛围好不好、学院是不是正统、保研考研的门槛高不高，这些都会被反反复复的考虑。想在每个点上都做到很好，那必然会引起焦虑。\n但实际上在真正读研或者已经工作的人眼里，大部分上述焦虑的点，影响其实微乎其微。大部分学校/学院/项目之间的比较就是电子斗蛐蛐，本质上和看动画片比战斗力一样没什么意义。人生是不可量化的，只有适合你的才是最好的，比来比去只能徒增焦虑。\n我本科遇到的一位好老师曾说：“现在的学生不知道为什么，都不希望别人的去向比自己好”。在结束保研之后，我认为这完全是大家的焦虑导致的。客观上确实升学和就业压力都越来越大，加上自媒体喜欢散播焦虑，我也常常连刷两个小时xhs导致越来越焦虑。但我不认为随便走错一步都会导致满盘皆输，人生的容错远远比想象中大，永远是“成事在人”。现在回头看高考，我感觉 ±20分 都没什么区别。同样的，等各位真正工作后，也不会觉得保研去处好一点坏一点会有多大的影响。因此写下“反焦虑贴”，希望看到的同学能尽可能的减少些负面情绪。\n如果各位想知道更细节的BG可以私信我，如果实在焦虑也可以私信我聊一聊。\n","date":"2025 年 10 月 8 日","externalUrl":null,"permalink":"/posts/graduate_application_experience/","section":"","summary":"","title":"“保研为我带来了什么？“","type":"posts"},{"content":"","date":"2025 年 10 月 8 日","externalUrl":null,"permalink":"/categories/%E6%9D%82%E8%B0%88/","section":"","summary":"","title":"杂谈","type":"categories"},{"content":" 文章标签 # ","date":"2025 年 9 月 2 日","externalUrl":null,"permalink":"/tags/","section":"","summary":"","title":"","type":"tags"},{"content":" 此篇包含 CollabLLM: From Passive Responders to Active Collaborators 的原文内容，以 PPT 图片形式呈现。内容参考原文、网络博客与 GPT 老师。 论文阅读 # ","date":"2025 年 9 月 2 日","externalUrl":null,"permalink":"/posts/readpaper2/","section":"","summary":"","title":"CollabLLM - 论文阅读","type":"posts"},{"content":"","date":"2025 年 9 月 2 日","externalUrl":null,"permalink":"/tags/llm/","section":"","summary":"","title":"LLM","type":"tags"},{"content":"","date":"2025 年 9 月 2 日","externalUrl":null,"permalink":"/tags/%E5%A4%9A%E8%BD%AE%E5%AF%B9%E8%AF%9D/","section":"","summary":"","title":"多轮对话","type":"tags"},{"content":"","date":"2025 年 9 月 2 日","externalUrl":null,"permalink":"/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/","section":"","summary":"","title":"论文阅读","type":"categories"},{"content":"","date":"2025 年 7 月 17 日","externalUrl":null,"permalink":"/tags/attention/","section":"","summary":"","title":"Attention","type":"tags"},{"content":" 此篇包含 FlashAttention v1和v2 的原文内容，以 PPT 图片形式呈现。内容参考原文、网络博客与 GPT 老师。此外，FlashAttention 的环境安装经常出问题，下面也给出了解决方法。 环境安装 # 直接 pip install flash-atten 的编译时间会非常长，如果网络不好还会出更多问题/\n方法一，ninja加速（同时使用清华镜像）：\npython -m pip install ninja -i https://pypi.tuna.tsinghua.edu.cn/simple MAX_JOBS=4 pip install flash-attn --use-pep517 --no-build-isolation -i https://pypi.tuna.tsinghua.edu.cn/simple 方法二，直接下载编译好的 releases：\nhttps://github.com/Dao-AILab/flash-attention/releases\n找到符合自己的 torch 和 cuda 版本下载即可。\n论文阅读 # ","date":"2025 年 7 月 17 日","externalUrl":null,"permalink":"/posts/readpaper1/","section":"","summary":"","title":"FlashAttention - 论文阅读与安装技巧","type":"posts"},{"content":"","date":"2025 年 7 月 17 日","externalUrl":null,"permalink":"/tags/%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/","section":"","summary":"","title":"环境安装","type":"tags"},{"content":"","date":"2025 年 3 月 6 日","externalUrl":null,"permalink":"/tags/pytorch/","section":"","summary":"","title":"Pytorch","type":"tags"},{"content":" 本博客为 Pytorch 的一些基本操作的备忘录，会持续更新。 本文大多来自于 2023 年初学 pytorch 的笔记，后经过整理。\nLLM 生成过于方便，导致很多 pytorch 的操作都忘了很多。\n经常 Debug 很久才发现是很基础的调包问题。\n因此特意整理一些常用的操作作为备忘录。\n其中很多内容来自 2023 年看的 小土堆教程 和 李沐老师的动手学习深度学习\n非常推荐：pytorch 实用教程\ntensor 与 array # 相互转化如下：\nimport numpy as np import torch # numpy 转为 tensor x = np.ones(5) print(type(x)) x = torch.tensor(x) print(type(x)) # tensor 转为 numpy x = torch.ones(5) x_numpy = x.detach().numpy() # detach() 切断计算图，不再计算梯度，但仍共享存储 一般而言，在 cuda 加速时 tensor 在 GPU 上。\nx = torch.ones(5) x = x.detach().cpu().numpy() 当需要使用到标量 tensor 时（比如统计 loss 等），可以将 tensor 标量化。\nloss_value = loss.item() # 现在可以用 loss_value 进行日志记录或其他 Python 计算 print(f\u0026#34;Loss: {loss_value}\u0026#34;) 当然，tensor 和 array 的转化其实没那么简单，比如经常遇到一些类型问题。\n此外，数据从 GPU 到 CPU 转化往往会占用一定的性能，因此能在 tensor 上完成的操作尽量转成 array 再操作。\nPyTorch 操作 NumPy 操作 说明 tensor.clamp() np.clip() 将值限制在指定范围内 torch.cat() np.concatenate() 沿指定维度连接数组 tensor.view() array.reshape() 改变数组形状，不改变数据 tensor.permute() np.transpose() 维度重排 tensor.unsqueeze() np.expand_dims() 增加维度 tensor.repeat() np.tile() 重复数组 tensor.t() array.T 2D张量的转置 dataset 和 dataloader # 实例化 Dataset 作用是告诉程序数据集在哪 并进行转化\n其中 root 表示数据集本地位置，train 表示是否训练，download 表示在线下载\n使用 transforms 中的 Compose 并结合 ToTensor\n在载入数据中可以直接进行转化\n# 此节主要了解部分标准数据集的使用方法 import torchvision from torch.utils.tensorboard import SummaryWriter # 下面开始配合 transform dataset_transform = torchvision.transforms.Compose([ torchvision.transforms.ToTensor() ]) # 下面演示 CIFAR10 数据集 # 其中 root 表示数据集本地位置，train 表示训练，download 表示在线下载 train_set = torchvision.datasets.CIFAR10(root=\u0026#34;./dataset\u0026#34;, train=True, transform=dataset_transform, download=True) test_set = torchvision.datasets.CIFAR10(root=\u0026#34;./dataset\u0026#34;, train=False, transform=dataset_transform, download=True) # 可知数据集格式为 PIL 和 target print(test_set[0]) print(test_set.classes) # 显示数据集的分类 # 获取数据 体会数据类型 img, target = test_set[0] print(img) print(target) print(test_set.classes[target]) writer = SummaryWriter(\u0026#34;logs\u0026#34;) for i in range(10): img, target = test_set[i] writer.add_image(\u0026#34;test_img\u0026#34;, img, i) 相比 DataSet 其更像是一个分拣器，将数据集分成 n 个一组\n可以将 DataSet 理解为牌堆，将 DataLoader 理解为手牌\nDataLoader 也同样有着较多参数，下面进行介绍\nimport torchvision from torch.utils.tensorboard import SummaryWriter # datasets 实例化过程和上一节相同 dataset_transform = torchvision.transforms.Compose([ torchvision.transforms.ToTensor() ]) train_set = torchvision.datasets.CIFAR10(root=\u0026#34;./dataset\u0026#34;, train=True, transform=dataset_transform) test_set = torchvision.datasets.CIFAR10(root=\u0026#34;./dataset\u0026#34;, train=False, transform=dataset_transform) from torch.utils.data import DataLoader # dataset：输入已经实例化的数据集 # batch_size=4：这指定了每个批次中包含的样本数量，模型将会根据每个批次的数据计算梯度并更新模型参数 # shuffle=True：DataLoader 是否在每个 epoch 开始时打乱数据集，以增加训练的随机性 # 1. iteration：1个iteration等于使用batchsize个样本训练一次； # 2. epoch：1个epoch等于使用训练集中的全部样本训练一次； # num_workers=0：这是指定用于数据加载的子进程数量。默认值为 0，表示数据将在主进程中加载，增加 num_workers 可以加速数据加载 # drop_last=False：当数据集的样本数量不能被 batch_size 整除时，如果设置为 True，最后一个不完整的批次会被丢弃；如果设置为 False，最后一个不完整的批次仍然会被保留 test_loader = DataLoader(dataset=test_set, batch_size=4, shuffle=True, num_workers=0, drop_last=False) # 由于 batch_size 为四，则进行四个一组打包 for i, data in enumerate(test_loader): if i \u0026gt; 5: break imgs, targets = data print(\u0026#34;---------\u0026#34;) print(len(imgs)) print(targets) writer = SummaryWriter(\u0026#34;logs\u0026#34;) # 由于 batch_size 为四，则进行四个一组打包 for epoch in range(3): for i, (imgs, targets) in enumerate(test_loader): writer.add_images(\u0026#34;epoch:{}\u0026#34;.format(epoch), imgs, i) writer.close() tensor transforms\n# 注意 此处只是导入 vision 的 transforms # 还有其他领域 如 text 的 transforms from torchvision import transforms from torch.utils.tensorboard import SummaryWriter from PIL import Image writer = SummaryWriter(\u0026#34;tensor_logs\u0026#34;) # 先学习 tensor (张量) 的数据类型 image_path = \u0026#34;data/reality_data/train/ants_image/0013035.jpg\u0026#34; img = Image.open(image_path) print(type(img)) # 将变化工具实例化 tensor_trans = transforms.ToTensor() print(type(tensor_trans)) # 用 tensor_trans 变化 img tensor_img = tensor_trans(img) print(type(tensor_img)) # 可以看到 tensor 本质上是多维数组 可以理解为向量矩阵 print(tensor_img) # 下面结合 TensorBoard 表示 writer.add_image(\u0026#34;tensor\u0026#34;, tensor_img) # 下面演示 Normalize 设置均方和标准差都是 1/2 trans_norm = transforms.Normalize([0.5, 0.5, 0.5], [0.5, 0.5, 0.5]) print(trans_norm) img_norm = trans_norm(tensor_img) print(img_norm) writer.add_image(\u0026#34;Normalize\u0026#34;, img_norm) # 下面演示 Resize # 要注意 Resize 传入的是 PIL，而非 tensor # 其参数传入一个代表正方形 多个表示长宽 print(img.size) trans_resize = transforms.Resize((512, 512)) img_resize = trans_resize(img) print(img_resize.size) # 下一步将新图像转化为张量 img_resize = tensor_trans(img_resize) print(img_resize) writer.add_image(\u0026#34;Resize\u0026#34;, img_resize) # Compose - resize - 2 # Compose 实际上就是组合功能 下面组合 Resize 和 ToTensor trans_resize_2 = transforms.Resize(512) # 前面函数的输出要匹配后面函数的输入 trans_compose = transforms.Compose([trans_resize_2, tensor_trans]) img_resize_2 = trans_compose(img) writer.add_image(\u0026#34;Resize\u0026#34;, img_resize_2, 1) # RandomCrop 随机裁剪 trans_random = transforms.RandomCrop((128, 256)) trans_compose2 = transforms.Compose([trans_random, tensor_trans]) for i in range(10): img_crop = trans_compose2(img) writer.add_image(\u0026#34;RandomCrop\u0026#34;, img_crop, i) writer.close() tensorboard # TensorBoard 是 TensorFlow 中强大的可视化工具，支持标量、文本、图像、音频、视频 TensorBoard 可以为下面 Transforms 的使用铺路 在控制台输入 打开网页即可查看可视化结果\n其中 logs 为名字 需要匹配 SummaryWriter(\u0026quot;\u0026quot;)\ntensorboard --logdir=logs tensorboard --logdir=logs --port=6007 第二个为指定端口号\n当进行更新时 只需要刷新TB网页即可\nfrom torch.utils.tensorboard import SummaryWriter import numpy as np from PIL import Image writer = SummaryWriter(\u0026#34;logs1\u0026#34;) image_path = \u0026#34;data/reality_data/train/ants_image/0013035.jpg\u0026#34; img_PIL = Image.open(image_path) img_array = np.array(img_PIL) print(type(img_array)) # shape 得到的是高度 宽度 通道 # 通道是图像的属性 指的是 RGB print(img_array.shape) # 需要导入的图像是 numpy 类型的 # 需要指定 img_array 的 shape 类型为 H (height) W (weight) C (channel) writer.add_image(\u0026#34;test\u0026#34;, img_array, 1, dataformats=\u0026#39;HWC\u0026#39;) image_path = \u0026#34;data/reality_data/train/bees_image/16838648_415acd9e3f.jpg\u0026#34; img_PIL = Image.open(image_path) img_array = np.array(img_PIL) print(type(img_array)) writer.add_image(\u0026#34;test\u0026#34;, img_array, 2, dataformats=\u0026#39;HWC\u0026#39;) # 下面测试添加函数图像 # 要注意 TB 只支持一个函数一次拟合 多次 add_scalar 不会清空之前的数据 for i in range(100): writer.add_scalar(\u0026#34;y=2x\u0026#34;, -i, i) for i in range(1, 100): writer.add_scalar(\u0026#34;y=1/x\u0026#34;, 1 / i, i) writer.close() 经典 MLP # import torch import torch.nn as nn import torch.optim as optim from torch.utils.data import DataLoader, TensorDataset import matplotlib.pyplot as plt import numpy as np # 设置随机种子 torch.manual_seed(42) # 1. 定义MLP模型 class MLP(nn.Module): def __init__(self, input_size, hidden_size, output_size): super(MLP, self).__init__() # 定义网络层 self.layer1 = nn.Linear(input_size, hidden_size) self.relu = nn.ReLU() self.layer2 = nn.Linear(hidden_size, output_size) def forward(self, x): # 前向传播 x = self.layer1(x) x = self.relu(x) x = self.layer2(x) return x # 2. 生成一些示例数据 x_data = torch.linspace(-5, 5, 200).reshape(-1, 1) y_data = 2 * x_data + torch.randn_like(x_data) * 0.5 # 3. 创建数据集和数据加载器 dataset = TensorDataset(x_data, y_data) dataloader = DataLoader(dataset, batch_size=32, shuffle=True) # 4. 初始化模型、损失函数和优化器 input_size = 1 hidden_size = 10 output_size = 1 model = MLP(input_size, hidden_size, output_size) criterion = nn.MSELoss() optimizer = optim.SGD(model.parameters(), lr=0.01) # 5. 训练循环 num_epochs = 100 loss_history = [] for epoch in range(num_epochs): epoch_loss = 0.0 for batch_x, batch_y in dataloader: # 前向传播 outputs = model(batch_x) loss = criterion(outputs, batch_y) # 反向传播和优化 optimizer.zero_grad() # 清除梯度 loss.backward() # 计算梯度 optimizer.step() # 更新参数 epoch_loss += loss.item() # 记录每个epoch的平均损失 avg_loss = epoch_loss / len(dataloader) loss_history.append(avg_loss) # 每10个epoch打印一次损失 if (epoch + 1) % 10 == 0: print(f\u0026#39;Epoch [{epoch+1}/{num_epochs}], Loss: {avg_loss:.4f}\u0026#39;) # 6. 评估模型 model.eval() with torch.no_grad(): predictions = model(x_data) # 7. 可视化结果 plt.figure(figsize=(12, 5)) # 绘制损失曲线 plt.subplot(1, 2, 1) plt.plot(loss_history) plt.title(\u0026#39;Training Loss\u0026#39;) plt.xlabel(\u0026#39;Epoch\u0026#39;) plt.ylabel(\u0026#39;Loss\u0026#39;) # 绘制预测结果 plt.subplot(1, 2, 2) plt.scatter(x_data.numpy(), y_data.numpy(), label=\u0026#39;Data\u0026#39;, alpha=0.4) plt.plot(x_data.numpy(), predictions.numpy(), \u0026#39;r\u0026#39;, linewidth=2, label=\u0026#39;Prediction\u0026#39;) plt.title(\u0026#39;Model Prediction\u0026#39;) plt.xlabel(\u0026#39;x\u0026#39;) plt.ylabel(\u0026#39;y\u0026#39;) plt.legend() plt.tight_layout() plt.show() # 打印一些模型参数 print(\u0026#34;Model parameters:\u0026#34;) for name, param in model.named_parameters(): print(f\u0026#34;{name}: {param.data}\u0026#34;) 经典 CNN # 卷积层 # 不在此处写卷积原理了 一般在初始化中定义好卷积函数 conv1, conv2 一般调用 Conv2d 包，其他很少使用 卷积核由种子随机生成，在后续的反向传播中调整 Conv2d 使用方法\nin_channels 指输入通道 彩色图一般为 3\nout_channels 是输出通道 指的是用n个卷积核得到n个结果通道\nkernel_size 是卷积核的大小\nstride 是步长 默认为一\npadding 指是否填充原图像边缘 默认填充零\n池化层 # 常用最大池化，即在一定范围矩阵内取最大值\n主要目的是降低数据维度\n常用 MaxPool2d 其参数大部分和卷积相同\nceil_mode 当为True时，其输出大小为向上取整，简单来说，和 padding 类似，不足剩余卷积核的部分是否选最大值出\nimport torch import torchvision from torch import nn, reshape, flatten from torch.nn import Conv2d, MaxPool2d, ReLU, Linear, Flatten from torch.utils.data import DataLoader from torch.utils.tensorboard import SummaryWriter # 之前解释过的 dataset 和 dataloader dataset = torchvision.datasets.CIFAR10(\u0026#34;./dataset\u0026#34;, train=False, transform=torchvision.transforms.ToTensor()) dataloader = DataLoader(dataset, batch_size=64) class MY_NN(nn.Module): def __init__(self): super(MY_NN, self).__init__() # 第一个卷积卷积函数 # in_channels 指输入通道 彩色图一般为 3 # out_channels 是输出通道 指的是用n个卷积核得到n和结果通道 # kernel_size 是卷积核的大小 # stride 是步长 默认为一 # padding 指是否填充原图像边缘 默认填充零 self.conv1 = Conv2d(in_channels=3, out_channels=6, kernel_size=3, stride=1, padding=0) # 向前传播进行一层卷积 def forward(self, x): x = self.conv1(x) return x my_nn = MY_NN() writer = SummaryWriter(\u0026#34;logs\u0026#34;) for step, (imgs, targets) in enumerate(dataloader): if step == 0: print(imgs.shape) # 注意此处是 add_images writer.add_images(\u0026#34;input\u0026#34;, imgs, step) output = my_nn(imgs) if step == 0: print(output.shape) # 此处的 output 是六通道 无法直接输出 # 强制转化为三通道或一通道进行输出 # -1 表示自动判断批处理大小 output = reshape(output, (-1, 3, 30, 30)) writer.add_images(\u0026#34;output_conv\u0026#34;, output, step) # 最大池化层 class MY_NN_Pool(nn.Module): def __init__(self): super(MY_NN_Pool, self).__init__() # kernel_size stride padding 与卷积操作相同 # ceil_mode 当为True时，其输出大小为向上取整，简单来说，和 padding 类似，不足剩余卷积核的部分是否选最大值 self.maxpool1 = MaxPool2d(kernel_size=3, padding=0, ceil_mode=True) # 向前传播进行一层卷积 def forward(self, x): x = self.maxpool1(x) return x my_nn_pool = MY_NN_Pool() for step, (imgs, targets) in enumerate(dataloader): output = my_nn_pool(imgs) if step == 0: print(output.shape) output = reshape(output, (-1, 3, 30, 30)) writer.add_images(\u0026#34;output_pool\u0026#34;, output, step) # 激活函数 class MY_NN_Activitions(nn.Module): def __init__(self): super(MY_NN_Activitions, self).__init__() # inplace 为 True 时为浅拷贝，否则为深拷贝 self.relu1 = ReLU(inplace=False) # 向前传播进行一层卷积 def forward(self, x): x = self.relu1(x) return x class MY_NN_linear(nn.Module): def __init__(self): super(MY_NN_linear, self).__init__() # 注意线性变化是一维的 # in_features 要匹配输入大小，设置 out_features 是指定输出大小，bias 指是否偏置 # 此处的 196608 是为了适配输入 self.linear1 = Linear(in_features=196608, out_features=10, bias=False) # 向前传播进行一层卷积 def forward(self, x): # 我的 dataloader 会取不完整的一个 bitch_size 因此会导致最后一个保证 # 因此需要加一个判断 size 的操作 if x.shape == torch.Size([196608]): x = self.linear1(x) return x my_nn_linear = MY_NN_linear() for i, (imgs, targets) in enumerate(dataloader): # 由于输入要是一位的 则需要将其拍扁 output = flatten(imgs) if i == 0: print(output) output = my_nn_linear(output) if i == 0: print(output) writer.close() # 测试上面的方法 class NN_final_test(nn.Module): def __init__(self): super(NN_final_test, self).__init__() self.model1 = nn.Sequential( Conv2d(3, 32, 5, padding=2), MaxPool2d(2), Conv2d(32, 32, 5, padding=2), MaxPool2d(2), Conv2d(32, 64, 5, padding=2), Flatten(), Linear(4096, 64), Linear(64, 10), ) def forward(self, x): x = self.conv1(x) x = self.maxpool1(x) x = self.conv2(x) x = self.maxpool2(x) x = self.conv3(x) x = self.flatten(x) x = self.liner1(x) x = self.liner2(x) return x nn_final_test = NN_final_test() print(nn_final_test) for imgs, targets in dataloader: print(imgs) print(nn_final_test.model1(imgs)) break # 交叉熵损失函数 loss = nn.CrossEntropyLoss() # 优化器 也就是反向传播算法 # 此处用 SGD 随机梯度下降，传入参数与学习率 optim = torch.optim.SGD(nn_final_test.parameters(), lr=0.01) # 进行多轮学习 for epoch in range(20): run_loss = 0 # 计算累计损失率 for imgs, targets in dataloader: outputs = nn_final_test(imgs) result_loss = loss(outputs, targets) # 传入输入和目标函数 optim.zero_grad() # 将梯度清零 result_loss.backward() # 重新计算梯度 optim.step() # 执行 SGD run_loss += result_loss print(run_loss) ","date":"2025 年 3 月 6 日","externalUrl":null,"permalink":"/posts/pytorch_memo/","section":"","summary":"","title":"Pytorch 备忘录","type":"posts"},{"content":"","date":"2025 年 3 月 6 日","externalUrl":null,"permalink":"/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/","section":"","summary":"","title":"机器学习","type":"categories"},{"content":" “资源分配型” 动态规划的总结与例题，还包含背包问题的理解。 前言 # 资源分配型动态规划一般题目会表达为：在序列化结构（数组、字符串等）中，用有限的操作资源完成特定操作，使最终收益最大或代价最小。\n注意，这种题目也可能使用搜索，而使用动态规划的关键是：\n当前是否使用资源会影响后续状态 是否有重复子问题 此外，从时间复杂度也能看出该选择此类动态规划，一般该类问题复杂度为: $$O(m n)$$ 其中 n 是数组长度，m 是资源数量。\n通常模板 # 状态定义 # ​\tdp[i][j] = 处理前 i 个元素时，使用 j 次资源后的最优解（最大收益/最小代价）\n状态转移 # 决策 1：不使用资源\ndp[i][j] = dp[i-1][j] + 当前代价（如白砖 + 1，股票未交易保持状态等）\n决策 2：使用资源\nif j \u0026gt;= 1: dp[i][j] = max/min(dp[i - L][j - 1], \u0026hellip;) # L 为资源覆盖长度\n初始化 # 基准状态\ndp[0][0] = 初始代价/收益（如第一个元素是否被覆盖）\n资源越界处理\nfor i in range(L): # 比如前 L 个元素使用一次资源的情况\n用地毯覆盖后的最少白色砖块 # \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e 2209. 用地毯覆盖后的最少白色砖块 原题 # 给你一个下标从 0 开始的二进制字符串 floor，它表示地板上砖块的颜色。\nfloor[i] = '0' 表示地板上第 i 块砖块的颜色是黑色 floor[i] = '1' 表示地板上第 i 块砖块的颜色是白色 同时给你 numCarpets 和 carpetLen。你有 numCarpets 条黑色的地毯，每一条黑色的地毯长度都为 carpetLen 块砖块。请你使用这些地毯去覆盖砖块，使得未被覆盖的剩余白色砖块的数目最小。地毯相互之间可以覆盖。\n请你返回没被覆盖的白色砖块的最少数目。\n示例：\n输入：floor = \u0026#34;10110101\u0026#34;, numCarpets = 2, carpetLen = 2 输出：2 如右侧所示：░█▒▒█▒█░，灰色是被地毯覆盖 思路与题解 # 其中地砖为进度轴、地毯为资源轴。\n设置地砖为 i，地毯为 j，则状态定义为：前 i 个地砖用 j 个地毯后的最小白砖数量。\n状态转移方程见下面代码的注释：\n# 动态规划，有限资源分配问题 # 如果想到状态定义就不算难：前 i 个地砖用 j 个地毯后的最小白砖数量 class Solution: def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -\u0026gt; int: n = len(floor) dp = [[inf] * (numCarpets + 1) for _ in range(n)] dp[0][0] = int(floor[0]) for i in range(carpetLen): # 前 carpetLen 个白格被盖住 dp[i][1] = 0 for i in range(n): for j in range(numCarpets + 1): if floor[i] == \u0026#39;1\u0026#39;: # 如果是白格，最小格子数加一 dp[i][j] = min(dp[i][j], dp[i - 1][j] + 1) if floor[i] == \u0026#39;0\u0026#39;: # 黑格不加 dp[i][j] = min(dp[i][j], dp[i - 1][j]) if i - carpetLen \u0026gt;= 0 and j - 1 \u0026gt;= 0: # 贪心，尽量让地毯不重复铺 dp[i][j] = min(dp[i - carpetLen][j - 1], dp[i][j]) # 如果最后地毯没用完，说明一定可以使得白砖全部被铺满 return dp[n - 1][numCarpets] if dp[n - 1][numCarpets] != inf else 0 买卖股票的最佳时机 IV # \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e 188. 买卖股票的最佳时机 IV 原题 # 给你一个整数数组 prices 和一个整数 k，其中 prices[i] 是某支给定的股票在第 i 天的价格。\n设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。也就是说，你最多可以买 k 次，卖 k 次。\n注意：你不能同时参与多笔交易（即，你必须在再次购买之前出售掉之前的股票）。\n示例 1：\n输入：k = 2, prices = [2, 4, 1] 输出：2 解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4 - 2 = 2。 示例 2：\n输入：k = 2, prices = [3, 2, 6, 5, 0, 3] 输出：7 解释： 在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出，这笔交易所能获得利润 = 6 - 2 = 4。 随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出，这笔交易所能获得利润 = 3 - 0 = 3 提示：\n0 \u0026lt;= k \u0026lt;= 100\n0 \u0026lt;= prices.length \u0026lt;= 1000\n0 \u0026lt;= prices[i] \u0026lt;= 1000\n思路与题解 # 此题用 记忆化搜索 要简单一些，其原理和上面的动态规划相同。\n同样是 i 表示进度轴，j 表示 资源数量。\n根据题目要求，要多一个 当前是否持有股票 的状态。\n# 记忆化搜索或 DP # 此题记忆化搜索好想一点 class Solution: def maxProfit(self, k: int, prices: List[int]) -\u0026gt; int: n = len(prices) @cache # i 是数组下标即当前最后统计的元素，记忆化搜索从后向前容易 # j 是当前剩余的买卖次数 # hold 标记当前是否存有股票 # 如果转成 DP 需要三维 def dfs(i : int, j : int, hold : bool) -\u0026gt; int: if (j == -1): # 次数都用完了 直接返回 # 此处用 -inf 是防止 -inf + price[i] 超过 0 的情况 return -inf if (i == -1): # 返回 -1 代表不可能递归到第一个数时还持有股票 # 实际上存的是第 0 天的两个状态 return -inf if hold else 0 if hold: # 两种可能 前为刚买的 后为之前就存有的，j 只需要在购买时维护 return max(dfs(i - 1, j - 1, False) - prices[i], dfs(i - 1, j, True)) else: # 两种可能 前为刚卖的 后为之前就没有 return max(dfs(i - 1, j, True) + prices[i], dfs(i - 1, j, False)) return dfs(n - 1, k, False) # 最后一定是不持有股票 其他题目 # \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e 410. 分割数组的最大值 状态定义是：数组中前 i 个数在当前切割成 j 个数组\n此外，该题也需要使用前缀和来获取 o1 的区间求和。\n背包问题 # 背包问题，也可以看作这种类型的动态规划。\n一般而言分成 01背包 和 完全背包。\n01背包：每个物品只能选一次。\n完全背包：每个物品可以重复选。\n两者状态定义为：前 i 个物品在容量为 j 的背包中的最大价值\n状态转移方程分别为：（1为01背包、2为完全背包）\ndp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weights[i - 1]] + values[i - 1]) dp[i][j] = max(dp[i - 1][j], dp[i][j - weights[i - 1]] + values[i - 1]) 两道零钱兑换 # \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e 322. 零钱兑换 给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。\n计算并返回可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。\n你可以认为每种硬币的数量是无限的。\n示例 1：\n输入：`coins = [1, 2, 5]`, `amount = 11` 输出：`3` 解释：11 = 5 + 5 + 1 题解：\n此题是经典的完全背包问题。\n但由于其要得到的是最少硬币数量，因此可以看作每个硬币的价值相同（其中的价值不是 amount，而是上面状态转移方程中的 value[]）。\n因此可以节省一个维度，代码如下：\nclass Solution: def coinChange(self, coins: List[int], amount: int) -\u0026gt; int: # DP下标是当前金额 内容是硬币数量 dp = [inf] * (amount + 1) dp[0] = 0 for coin in coins: for i in range(1, amount + 1): if i \u0026lt; coin: continue dp[i] = min(dp[i], dp[i - coin] + 1) return dp[amount] if dp[amount] != inf else -1 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e 518. 零钱兑换 Ⅱ 给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。\n请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。\n假设每一种面额的硬币有无限个。\n题目数据保证结果符合 32 位带符号整数。\n示例 1：\n输入：amount = 5, coins = [1, 2, 5] 输出：4 解释：有四种方式可以凑成总金额： 5=5 5=2+2+1 5=2+1+1+1 5=1+1+1+1+1 题解：\n此题要的是凑出最大零钱的种类，那么为什么不能直接用Ⅰ的思路？ Ⅰ的遍历顺序无关：因为求的是最小值，无论是先遍历硬币还是金额，最终都能得到最少硬币数（例如 coins = [1,2,5]，amount=5，无论顺序如何，最少硬币数都是1）。 Ⅱ的遍历顺序关键：组合数的统计必须避免重复计数（例如 2+1+1 和 1+2+1 视为同一种组合）。 Ⅱ先遍历硬币，后遍历金额的遍历顺序，可以看作通过固定硬币的遍历顺序，保证组合的唯一性。 class Solution: def change(self, amount: int, coins: List[int]) -\u0026gt; int: dp = [0] * (amount + 1) dp[0] = 1 for coin in coins: for i in range(coin, amount + 1): dp[i] += (dp[i - coin]) return dp[amount] ","date":"2025 年 2 月 21 日","externalUrl":null,"permalink":"/posts/%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%BC%8F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","section":"","summary":"","title":"“资源分配型” 动态规划总结","type":"posts"},{"content":"","date":"2025 年 2 月 21 日","externalUrl":null,"permalink":"/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","section":"","summary":"","title":"背包问题","type":"tags"},{"content":"","date":"2025 年 2 月 21 日","externalUrl":null,"permalink":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","section":"","summary":"","title":"动态规划","type":"tags"},{"content":"","date":"2025 年 2 月 21 日","externalUrl":null,"permalink":"/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/","section":"","summary":"","title":"记忆化搜索","type":"tags"},{"content":"","date":"2025 年 2 月 19 日","externalUrl":null,"permalink":"/tags/%E5%8D%9A%E5%BC%88/","section":"","summary":"","title":"博弈","type":"tags"},{"content":" 原题链接：点击这里访问 题目描述 # 贝茜和埃尔茜发现了一行 \\(N\\) 个蛋糕（\\(N\\) 为偶数），大小依次为 \\(a_1, a_2, \\dots, a_N\\)。\n两头奶牛都想吃到尽可能多的蛋糕。但是，作为非常文明的奶牛，她们决定玩一个游戏来分割蛋糕！\n游戏在两头奶牛之间轮流进行回合。\n每个回合进行以下两者之一：\n贝茜 选择两个相邻的蛋糕并将它们堆叠起来，制造大小为两者大小之和的一个新蛋糕。 埃尔茜 选择最左边或最右边的蛋糕藏起来。 当只剩下一个蛋糕时，贝茜吃掉它，而埃尔茜吃掉她藏起来的所有蛋糕。\n如果两头奶牛都采取最优策略以最大化她们吃到的蛋糕量，并且贝茜先进行回合，那么每头奶牛将会吃到多少蛋糕？\n输入格式\n每个测试点包含 \\(T\\) 个独立的测试用例。\n每个测试用例的格式如下：\n第一行包含整数 \\(N\\)。 第二行包含 \\(N\\) 个空格分隔的整数 \\(a_1, a_2, \\dots, a_N\\)。 输出格式\n对于每个测试用例，输出一行，包含两个整数 (b) 和 (e)，表示贝茜和埃尔茜在两头奶牛都采取最优策略的情况下分别吃到的蛋糕量。\n数据范围\n\\(1 \\leq T \\leq 10\\) \\(2 \\leq N \\leq 5 \\times 10^5\\) \\(1 \\leq a_i \\leq 10^9\\) 输入保证一个测试点中的所有 \\(N\\) 之和不超过 \\(10^6\\)。 输入样例\n2 4 40 30 20 10 4 10 20 30 40 输出样例\n60 40 60 40 样例解释\n对于第一个测试用例，在最优策略下：\n贝茜将堆叠中间两个蛋糕。现在蛋糕的大小为 [40, 50, 10]。 埃尔茜将吃掉最左边的蛋糕。现在剩余的蛋糕的大小为 [50, 10]。 贝茜堆叠剩余的两个蛋糕。 最终，贝茜将吃到 \\(30+20+10=60\\) 的蛋糕，而埃尔茜将吃到 \\(40\\) 的蛋糕。\n第二个测试用例是第一个测试用例反转的情况，因此答案相同。\n解题思路 # 根据数据规模可知时间复杂度最多支持 nlogn 因此可以排除 博弈论 和 动态规划（DP） 这类通常需要 O(n²) 或更高复杂度的解法。我们需要找到更优的解法，如 贪心 或 二分查找 + 前缀和 等方法。\n因此想去找博弈通解：\n埃尔茜只能吃 n // 2 - 1 个\n埃尔茜每次都会吃当前左右两边中最小的蛋糕\n贝茜的最优策略是不合并靠近左右边界的蛋糕\n这样可以让埃尔茜的选择变得更有限，从而使她的总得分尽可能小\n因此贝茜吃到的是连续 n // 2 + 1 个蛋糕的最小和\no1区间求和 -\u0026gt; 前缀和\n题解 # import math t = int(input()) while t \u0026gt; 0: t -= 1 # python 循环输入不能写 while t -= 1 n = int(input()) arr = list(map(int, input().split())) sum_arr = sum(arr) sum_min = math.inf prefix = [0] * (n + 1) for i in range(1, n + 1): prefix[i] = prefix[i - 1] + arr[i - 1] for i in range(n // 2 + 1, n + 1): sum_min = min(sum_min, prefix[i] - prefix[i - n // 2 - 1]) # print(\u0026#34;@\u0026#34;, sum_min) print(sum_min, sum_arr - sum_min) ","date":"2025 年 2 月 19 日","externalUrl":null,"permalink":"/posts/cake-game/","section":"","summary":"","title":"蛋糕游戏题解 - 贪心博弈","type":"posts"},{"content":"","date":"2025 年 2 月 19 日","externalUrl":null,"permalink":"/tags/%E5%89%8D%E7%BC%80%E5%92%8C/","section":"","summary":"","title":"前缀和","type":"tags"},{"content":"","date":"2025 年 2 月 19 日","externalUrl":null,"permalink":"/tags/%E8%B4%AA%E5%BF%83/","section":"","summary":"","title":"贪心","type":"tags"},{"content":" 此博客为数论基础板子，以及一些注意事项和例题。 数论内容知识点比较零碎且容易遗忘，因此便对其进行总结。\n内容都为数论基础知识点，板子主要用 C++ 表示。\n快速幂 # 标准的 a ^ b mod p 形式的快速幂：\nlong long fast_pow(long long i, long long n, long long mod) { long long res = 1; i = i % mod; while (n) { if (n \u0026amp; 1) res = (res * i) % mod; i = (i * i) % mod; n \u0026gt;\u0026gt;= 1; } return res; } 时间复杂度为:\n$$ O(\\log b) $$\n如果要考虑非正数整数则：\ndouble newX = 0; if (b == 0) return 1; if (b \u0026lt; 0) { b = -b; newX = 1 / x; } C++ 的 pow() 库函数处理的是浮点数，因此在运行数值较大是会出现精度错误。在比赛或面试中，遇到指数大于十的幂运算时，就建议手搓快速幂。\npython 的 pow() 不会有这个问题，可以放心使用。\n标准的 a ^ b 形式的快速幂：\nlong long fast_pow(long long a, long long b) { long long res = 1; long long base = a; while (b) { if (b \u0026amp; 1) res = (res * base); base = (base * base); b \u0026gt;\u0026gt;= 1; } return res; } 最大公约数 # 一般而言，用库函数就可以了。\n注意 gcd() 在 c++17 才引用，C++11 用 __gcd()。\n辗转相除法的思想要了解下。\nlong long my_gcd(long long a, long long b) { return __gcd(a, b); // // 辗转相除法 // return b == 0 ? a : gcd(b, a % b); } 裴蜀定理 # 设 a 和 b 是两个不全为零的整数。\n对于任意整数 x 和 y ，都有：\n$$ \\gcd(a, b) \\mid ax + by $$\n也就是说，最大公约数 gcd(a, b) 总是整除形如 ax + by 的表达式。\n不仅如此，还存在某些整数 x 和 y ，使得：\n$$ ax + by = \\gcd(a, b) $$\n最小公倍数 # 最小公倍数为 abs(a * b) / __gcd(a, b)\nlong long lcm(long long a, long long b) { return abs(a * b) / __gcd(a, b); } 素数筛 # 素数筛目的是找出 2 到 n 的所有素数（即质数）。\n埃式筛 # 埃式筛的基本思想从 2 到 N 枚举，如果当前数未被标记为合数，则其为素数，并将它的倍数全部标记为合数。\nvector\u0026lt;bool\u0026gt; sieve_of_eratosthenes(int n) { vector\u0026lt;bool\u0026gt;is_prime(n + 1, true); // 0 和 1 不是素数 is_prime[0] = false; is_prime[1] = false; for(int i = 2; i * i \u0026lt;= n; i++) if (is_prime[i]) for (int j = i * i; j \u0026lt;= n; j += i) is_prime[j] = false; return is_prime; } 时间复杂度：\n$$O\\left(n \\log \\log n\\right)$$\n线性筛 # 相比埃式筛多维护一个已确定的质数数组。\nvector\u0026lt;bool\u0026gt; sieve_of_eratosthenes(int n) { vector\u0026lt;bool\u0026gt; is_prime(n + 1, true); vector\u0026lt;int\u0026gt; primes; is_prime[0] = is_prime[1] = false; for (int i = 2; i \u0026lt;= n; i++) { if (is_prime[i]) { primes.push_back(i); } for (int p : primes) { if (i * p \u0026gt; n) break; // 超出范围 is_prime[i * p] = false; // 标记 i * p 为非素数 if (i % p == 0) break; // 保证每个数只被其最小质因数筛选一次 } } return is_prime; // 返回布尔数组 } 时间复杂度：\n$$O(n)$$\n质因数分解 # 获取小于 n 的质因数集合。\n质因数：能整除 n 的质数。 基本思想如下：\nn 的质因数最大不会超过 sqrt(n)。 从小到大找 n 的因数，每找到一个就将 n 反复除去该因数。 vector\u0026lt;long long\u0026gt; primeDivide(long long n) { vector\u0026lt;long long\u0026gt;ans; for (long long i = 2; i * i \u0026lt;= n; i++) { if (n % i == 0) { ans.push_back(i); // 如果要统计每个质因数的个数要在此处计数 while (n % i == 0) { n /= i; } } } // n 本身是质数 要特判 if (n \u0026gt; 1) { ans.push_back(n); } return ans; } 时间复杂度：\n$$O(\\sqrt{n})$$\n例题：\n蓝桥杯 完全平方数 - 完全平方数的每个质因数的指数都是偶数\nCSP认证 因子化简 - 质因数板子加简单判断\n欧拉函数 # 求不超过 n 并且和 n 互为质数的个数。\n互质：n 不为 m 的因数，m 也不为 n 的因数。 上面的质因数分解得到了 n 因数中的质数。\n根据下面的欧拉函数：\n$$\\phi(n) = n \\prod_{p \\mid n} \\left( 1 - \\frac{1}{p} \\right)$$\n$$\\phi(n) = n \\left( 1 - \\frac{1}{p_1} \\right) \\left( 1 - \\frac{1}{p_2} \\right) \\cdots \\left( 1 - \\frac{1}{p_k} \\right)$$\nlong long euler(long long n, long long MOD) { // 1 的欧拉函数是 0 if (n == 1) return 0; vector\u0026lt;long long\u0026gt;factor; factor = primeDivide(n); // 如果 n 本身是质数，注意不能用 size 为 1 判断 if (factor[0] == n) { return (n - 1) % MOD; } long long ans = n; for (auto \u0026amp;i : factor) { // 欧拉函数的公式 ans = ans * (i - 1) / i % MOD; // 注意要这样写才能不触发向下取整 } return ans; } 时间复杂度：\n$$O(\\sqrt{n})$$\n例题：\n蓝桥杯 互质数的个数 - 欧拉函数板子\n逆元法求组合数 # 费马小定理：\n若 p 是素数，且 a 是整数，满足 \\( p \\nmid a \\) 即 a 不能被 p 整除，则有：\n$$ a^{p-1} \\equiv 1 \\pmod{p} \\ $$\n组合数公式：\n$$ \\text{comb}(n, m) \\equiv \\frac{n!}{m!(n - m)!} \\pmod{\\text{MOD}} $$\n$$ \\text{comb}(n, m) \\equiv \\text{fact}[n] \\cdot \\text{inv}[m] \\cdot \\text{inv}[n - m] \\pmod{\\text{MOD}} $$\n$$ 其中 \\ \\text{inv}[i] = \\left( \\text{fact}[i] \\right)^{-1} \\bmod \\text{MOD} $$\n根据费马小定理：\n$$ inv[i] = fact[i]^{-1} \\equiv fact[i]^{\\text{MOD} - 2} \\pmod{\\text{MOD}} $$\n此外有逆元递推式：\n$$\\text{inv}[i] = \\text{inv}[i + 1] \\times (i + 1) \\bmod \\text{MOD} \\quad $$\nconst int MOD = 998244353; // 需要保证 MOD 是质数 const int MAXN = 2 * 100000 + 10; vector\u0026lt;long long\u0026gt; inv(MAXN, 1); vector\u0026lt;long long\u0026gt; fact(MAXN, 1); // 快速幂 long long qpow(long long i, long long n, long long p) { i %= p; long long res = 1; while (n) { if (n \u0026amp; 1) { res = (res * i) % p; } i = (i * i) % p; n \u0026gt;\u0026gt;= 1; } return res; } // On 求阶乘数组 for (int i = 1; i \u0026lt; MAXN; i++) { fact[i] = (fact[i - 1] * i) % MOD; } // On 求逆元数组，inv[MAXN - 1] 用费马小定理 inv[MAXN - 1] = qpow(fact[MAXN - 1], MOD - 2, MOD); for (int i = MAXN - 2; i \u0026gt;= 0; i--) { // 递推求逆元 inv[i] = inv[i + 1] * (i + 1) % MOD; } // 也可以直接快速幂求 // inv[i] = qpow(fact[i], MOD - 2, MOD) // 组合数公式，分母两个阶乘变成逆元 long long comb(int m, int n) { return fact[m] * (inv[n] % MOD) % MOD * (inv[m - n] % MOD) % MOD; } python 的 pow 自带快速幂和逆元，能大大减小代码量（但 comb 对大数支持并不好）\nMOD = 998244353 MAXN = 2 * 10**5 + 10 fact = [1] * MAXN inv = [1] * MAXN for i in range(1, MAXN): fact[i] = fact[i - 1] * i % MOD inv[MAXN - 1] = pow(fact[MAXN - 1], MOD - 2, MOD) for i in range(MAXN - 2, -1, -1): inv[i] = inv[i + 1] * (i + 1) % MOD # 组合数 C(n, k) def comb(n, k): if k \u0026lt; 0 or k \u0026gt; n: return 0 return fact[n] * inv[k] % MOD * inv[n - k] % MOD ","date":"2025 年 2 月 15 日","externalUrl":null,"permalink":"/posts/%E6%95%B0%E8%AE%BA%E5%9F%BA%E7%A1%80/","section":"","summary":"","title":"基础数论 - 模板 \u0026 分析","type":"posts"},{"content":"","date":"2025 年 2 月 15 日","externalUrl":null,"permalink":"/tags/%E6%A8%A1%E6%9D%BF/","section":"","summary":"","title":"模板","type":"tags"},{"content":"","date":"2025 年 2 月 15 日","externalUrl":null,"permalink":"/tags/%E6%95%B0%E8%AE%BA/","section":"","summary":"","title":"数论","type":"tags"},{"content":"","date":"2025 年 2 月 14 日","externalUrl":null,"permalink":"/tags/%E9%9D%A2%E8%AF%95/","section":"","summary":"","title":"面试","type":"tags"},{"content":"","date":"2025 年 2 月 14 日","externalUrl":null,"permalink":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","section":"","summary":"","title":"设计模式","type":"tags"},{"content":" 本博客为吉林大学设计模式本科课程复习笔记。内容参考了教案和 gonghr 学长的博客。 如果你在准备考试，可以看下面根据历年题总结出的重点排序。\n吉林大学软件学院2022级考试几乎完美符合下面总结的重点。\n1.重要度从高到低：\n​\t组合 or 装饰\n​\t状态 or 策略\n​\t适配器 + 桥接（或其他）or 外观\n​\t观察者 or 中介者\n​\t抽象工厂 or 建造者（大概率抽象工厂）\n​\t其他小点：原型，代理，单例，命令，职责链，迭代器\n2.很少考察的内容：\n​\t模板方法不单独考（大概率配合策略模式）\n​\t简单工厂和工厂方法大概率被抽象工厂替代考察\n​\t迭代器和命令难度较高（没考过）\n3.多模式混用：\n​\t适配器 + 其他（大概率桥接）\n​\t模板方法 + 策略模式\n​\t装饰 + 组合\n​\t命令模式 + 其他（难度较高）\n面向对象七原则 # 1. 开闭原则 (OCP) # 定义：软件实体（类、模块、函数等）应该对扩展开放，对修改关闭。\n解释：需要对某个功能进行扩展时，不应该修改已有的代码，而应该通过增加新的代码。此外开闭原则较难实现，尽量接近满足开闭原则即可。\n举例：如果要添加一个三角形的面积计算功能，应该通过扩展一个新的类（如 TriangleAreaCalculator），而不是直接修改现有的 Shape 类。\n2. 里氏代换原则 ( LSP) # 定义：子类对象必须能够替换掉父类对象，并且程序的行为不会发生变化。\n解释：子类应该能够在任何使用父类的地方使用。即父类不应该有子类没实现的功能。\n举例：如果我们有一个父类 Bird，其中有一个方法 fly()，那么如果我们创建了一个 Penguin 子类，它不应该继承 fly() 方法（因为企鹅不能飞）。\n3. 迪米特原则 (LoD) # 定义：也称为“最少知识原则”，一个对象应该尽可能少地了解其他对象。不和陌生人说话，进而降低耦合。\n解释：不希望陌生的类之间建立直接的联系。如果真的有需要建立联系，也希望能通过它的友元类来转达。因此，应用迪米特法则有可能造成的一个后果就是：系统中存在大量的中介类。\n举例：假设有如下代码：a.getB().getC().method()。根据迪米特原则，这种深层次的链式调用是不推荐的。更好的方式是让 a 对象直接提供一个方法调用 method()，而不是通过 B 和 C 对象间接调用。\n4. 单一职责原则 (Single Responsibility Principle, SRP) # 定义：一个类应该只有一个引起变化的原因，或者说一个类应该只负责一件事。\n举例：假设有一个类 UserManager，它同时负责用户的管理和日志记录。根据单一职责原则，应该将日志记录的功能提取到一个独立的 Logger 类中，这样 UserManager 只负责用户管理。\n5. 接口隔离原则 (Interface Segregation Principle, ISP) # 定义：客户端不应该被迫依赖它不使用的接口。\n解释：不应该强迫子类实现其不需要的父类接口。\n举例：假设有一个接口 Worker，其中包含 work() 和 eat() 方法。如果 robot（机器人不需要吃饭）只需要 work() 方法而不需要 eat() 方法，那么应该将接口拆分为 Worker 和 Eater 两个接口。\n解决方法： 6. 依赖倒置原则 (Dependency Inversion Principle, DIP) # 定义：高层模块不应该依赖于低层模块，二者都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。此处的依赖不是面向对象关系的依赖，而与语义上的依赖。\n解释：这个原则提倡通过依赖接口或抽象类，而不是依赖具体实现类，来降低系统的耦合性和提高模块的可扩展性。高层模块不应该直接依赖于低层模块的具体实现，而应该依赖于抽象。\n举例： 7. 组合 / 聚合复用原则 (Composition/Aggregation Reuse Principle, CARP) # 定义：尽可能使用对象的组合/聚合，而不是通过继承来实现复用。\n解释：组合和聚合相比继承更加灵活，它们通过将现有类作为新的类成员来实现功能复用，而不是通过继承来扩展类的行为。这样可以避免因为继承而导致的类之间的强耦合和层次结构的僵化。\n举例：假设有一个类 Car，它需要具备 Engine 的功能，而不是通过继承 Engine 类来实现 Car 的动力系统功能，应该通过组合的方式，让 Car 包含一个 Engine 对象，这样可以更好地实现代码复用。\n通过组合/聚合复用的优缺点 优点：\n新对象存取成员对象的唯一方法是通过成员对象的接口； 这种复用是黑箱复用，因为成员对象的内部细节是新对象所看不见的； 这种复用更好地支持封装性； 这种复用实现上的相互依赖性比较小； 每一个新的类可以将焦点集中在一个任务上； 这种复用可以在运行时间内动态进行，新对象可以动态的引用与子对象类型相同的对象。 作为复用手段可以应用到几乎任何环境中去。 缺点: 就是系统中会有较多的对象需要管理。 通过继承来进行复用的优缺点 优点：\n新的实现较为容易，因为基类的大部分功能可以通过继承的关系自动进入派生类。 修改和扩展继承而来的实现较为容易。 缺点： 继承复用破坏封装性，因为继承将基类的实现细节暴露给派生类。由于基类的内部细节常常是对于派生类透明的，所以这种复用是透明的复用，又称“白箱”复用。 如果基类发生改变，那么派生类的实现也不得不发生改变。 从基类继承而来的实现是静态的，不可能在运行时间内发生改变，没有足够的灵活性。 UML图 # 基础画法如下：\n注意要区分实现和继承的核心是区分 interface 和 abstract 类。\n设计模式定义 # 设计模式的基本要素:\n•模式名称 (Pattern name)\n•问题 (Problem)\n•解决方案 (Solution)\n•效果 (Consequences)\n三大类模式 # 创建型模式主要用于创建对象。\n结构型模式主要用于处理类或对象的组合。\n行为型模式主要用于描述对类或对象怎样交互和怎样分配职责。\n类模式和对象模式 # 类模式处理类和子类之间的关系，这些关系通过继承建立，在编译时刻就被确定下来，是属于静态的。\n静态：你可以通过 Factory.create() 直接调用该方法，而不需要创建 Factory 的实例。\n// 静态工厂方法，通过传入的参数决定创建哪种对象 public static Animal createAnimal(String type) { if (\u0026#34;dog\u0026#34;.equalsIgnoreCase(type)) { return new Dog(); } else if (\u0026#34;cat\u0026#34;.equalsIgnoreCase(type)) { return new Cat(); } return null; } 对象模式处理对象间的关系，这些关系在运行时刻变化，更具动态性。\n类模式：主要解决类之间的继承和实现问题，通过继承和接口实现来复用和扩展行为。（extends和implements）\n对象模式：主要处理对象之间的组合、依赖、聚合等关系，通过组合对象来灵活地扩展功能和行为。（依赖、关联、组合、聚合）\nGoF设计模式（分类表格） # 创建型模式 # 创建型模式特点： # 客户不知道对象的具体类是什么：\n客户端代码不需要知道具体创建对象的类是什么，它只依赖于抽象类或接口。这种方式使得客户端代码与具体的实现类解耦，提升了代码的灵活性和可维护性。 好处：如果对象的具体实现发生变化，客户端代码不必修改，因为它依赖的是抽象接口，而不是具体类。 隐藏了对象实例是如何被创建和组织的：\n创建型模式将对象创建的逻辑封装在类或方法内部，客户端无需关心具体的创建细节。可以通过工厂方法、建造者模式等方式动态地创建不同类型的对象。 好处：对象的创建逻辑可以根据需求动态变化，并且可以轻松替换或扩展对象的创建方式，而不影响客户端代码。 使用场景：\n当你在代码中频繁使用 new 运算符来创建对象时，可以考虑使用创建型模式，将对象的创建逻辑抽象出来，从而提升代码的灵活性、可扩展性和可维护性。\n简单工厂模式（静态工厂方法） # 实现简单工厂模式的难点就在于 “如何选择”实现\n1. 优点： # 职责分离：工厂类负责产品对象的创建，客户端只需消费产品，无需关心创建细节。 降低耦合：客户端不需要知道具体产品类名，只需传递参数即可，减少了代码耦合。 提高灵活性：通过配置或参数化创建，可以动态更换或增加产品类，而无需修改客户端代码。 简化客户端代码：创建逻辑集中在工厂类中，简化了客户端的实现。 2. 缺点： # 单一故障点：工厂类集中所有创建逻辑，若出错会影响整个系统。 增加复杂度：增加了系统中的类，特别是当产品较少时，工厂类显得冗余。 扩展性差：每次新增产品都需修改工厂类，违背“开闭原则”，产品多时工厂逻辑复杂化。 无法继承：使用静态方法创建产品，限制了工厂类形成继承结构，降低了灵活性。 3. 适用场景： # 对象创建较少，逻辑简单。 客户端不关心创建细节，只需提供参数即可。 完整代码示例：\n// 注意静态体现在 public static // 简单工厂模式和工厂方式模式都是类模式，是静态的 public class TVFactory { public static TV produceTV(String brand) throws Exception { if(brand.equalsIgnoreCase(\u0026#34;Haier\u0026#34;)) { System.out.println(\u0026#34;电视机工厂生产海尔电视机！\u0026#34;); return new HaierTV(); } else if(brand.equalsIgnoreCase(\u0026#34;Hisense\u0026#34;)) { System.out.println(\u0026#34;电视机工厂生产海信电视机！\u0026#34;); return new HisenseTV(); } else { throw new Exception(\u0026#34;对不起，暂不能生产该品牌电视机！\u0026#34;); } } } public class HaierTV implements TV { public void play() { System.out.println(\u0026#34;海尔电视机播放中......\u0026#34;); } } public class HisenseTV implements TV { public void play() { System.out.println(\u0026#34;海信电视机播放中......\u0026#34;); }\t} public interface TV { public void play(); } // 在另一个样例中，product 可以用 abstract 类，使用实线空箭头 public abstract class User { public void sameOperation() { System.out.println(\u0026#34;修改个人资料！\u0026#34;); } public abstract void diffOperation(); } 工厂方法模式(Factory Method) # 工厂方法模式的本质是：延迟到子类来选择实现。\n工厂方法模式很好的体现了**“依赖倒置原则”和“开闭原则”**。\n工厂可以是抽象类，也可以是具体类\n代码示例：\n// 最上面和最下面的两个接口 public interface TV { public void play(); } public interface TVFactory { public TV produceTV(); } // 具体工厂 public class HisenseTVFactory implements TVFactory { public TV produceTV() { System.out.println(\u0026#34;海信电视机工厂生产海信电视机。\u0026#34;); return new HisenseTV(); } } // 具体产品 public class HisenseTV implements TV { public void play() { System.out.println(\u0026#34;海信电视机播放中......\u0026#34;); }\t} 抽象工厂模式(Abstract Factory) # 一个具体工厂可以 creat 多个具体产品，就是抽象工厂模式。\n抽象工厂模式的本质是：选择产品簇的实现。\n1. 模式优点： # 隔离具体类的生成：客户端无需知道具体的产品类名，只需要通过抽象工厂接口创建产品，降低了系统的耦合性。 易于更换具体工厂：通过更换具体工厂的实例，可以轻松改变整个系统的行为，增强系统的灵活性。 保证产品族一致性：确保客户端始终使用同一产品族中的对象，避免了产品混用带来的兼容性问题。 符合开闭原则：增加新的具体工厂和产品族无需修改已有系统，扩展方便，符合开闭原则（对扩展开放，对修改关闭）。 高内聚低耦合：通过抽象工厂隔离对象创建，提高了系统的内聚性，降低了耦合性，有助于系统的维护和扩展。 2. 模式缺点： # 扩展困难：抽象工厂规定了所有可能创建的产品集合，增加新的产品种类（产品等级结构）时，需要修改工厂接口和所有子类，扩展较为困难。 开闭原则的倾斜性：虽然增加新的工厂和产品族很方便，但增加新的产品等级结构（新种类产品）较麻烦，需要修改现有的工厂类，违反了开闭原则。 3. 适用环境： # 系统不应依赖产品实例的创建细节：适用于不关心产品类如何被创建、组合和表达的场景。 存在多个产品族：系统中有多于一个产品族，每次只使用其中一个产品族中的相关对象。 产品族的一致使用：同一产品族中的产品需要一起工作，系统设计时需保证这一约束。 提供统一接口的产品库：系统中所有产品通过同一个接口出现，客户端无需依赖具体的实现类。 只有具体工厂代码有区别：\n// 不过是一个工厂可以创造多个产品 public class HaierFactory implements EFactory { public Television produceTelevision() { return new HaierTelevision(); } public AirConditioner produceAirConditioner() { // 这个是空调 return new HairAirConditioner(); } } 建造者模式(Builder) # 核心是“组装”，一步一步创建一个复杂的对象，client 和最后的成品交互。\nBuilder（抽象建造者）： 提供一个用于创建产品各部件的抽象类，一般不是接口。\nConcreteBuilder（具体建造者）： 实现Builder接口，负责具体产品部件的构造和装配。\nDirector（指挥者）： 负责指挥建造的流程，安排复杂对象的建造顺序。通过调用建造者的部件构造和装配方法，完成产品的构建过程。\nProduct（产品角色）： 是最终被构建的复杂对象，通常由多个组成部件构成。\n1. 优点： # 封装性好：客户端无需知道产品内部细节 解耦性强：产品与创建过程分离 扩展性好：易于添加新的建造者，符合开闭原则 精细控制：创建步骤清晰可控 2. 缺点：（建造者类复杂） # 适用范围受限：仅适用于相似产品的创建 类数量增加：产品变化复杂时需要更多建造者类 3. 适用场景： # 产品结构复杂：包含多个组成部分 需要控制生成顺序：产品属性间存在依赖关系 创建过程独立：通过指挥者类统一管理创建过程 复用创建过程：相同流程可创建不同产品 建造者模式与抽象工厂模式的关键区别：\n产品维度不同： 建造者：返回单个完整产品 抽象工厂：返回一系列相关产品（产品族） 构建过程不同： 建造者：强调步骤化构建过程，通过指挥者协调 抽象工厂：直接通过工厂方法获取产品 形象比喻： 建造者：像汽车组装厂，组装完整汽车 抽象工厂：像零配件厂，生产相关配件 下图应该为实线继承，因为 builder 是抽象类\n// 客户端类 public class Client { public static void main(String args[]) { // 动态确定套餐种类，使用 XML 配置读取具体的建造者类 MealBuilder mb = (MealBuilder) XMLUtil.getBean(); KFCWaiter waiter = new KFCWaiter(); // 服务员是指挥者，负责构建套餐 waiter.setMealBuilder(mb); // 服务员设置当前的套餐建造者 Meal meal = waiter.construct();\t// 用 director 中的 construct 构造 Product System.out.println(meal.getFood()); System.out.println(meal.getDrink()); } } // 指挥者类 public class KFCWaiter { private MealBuilder mb; public void setMealBuilder(MealBuilder mb) { this.mb = mb; } // 构建套餐并返回 public Meal construct() { mb.buildFood(); // 构建主食 mb.buildDrink(); // 构建饮料 return mb.getMeal(); // 返回最终构建的套餐 } } // 产品类，表示套餐 public class Meal { // 套餐的部件：食物和饮料 private String food; private String drink; public void setFood(String food) { this.food = food; } public void setDrink(String drink) { this.drink = drink; } public String getFood() { return this.food; } public String getDrink() { return this.drink; } } // 抽象建造者类，定义构建流程的接口 public abstract class MealBuilder { // 需要构建的套餐对象，因此其和 Meal 是组合关系 protected Meal meal = new Meal(); public abstract void buildFood(); public abstract void buildDrink(); // 返回构建好的套餐 public Meal getMeal() { return meal; } } // 具体建造者A，实现套餐A的构建 public class SubMealBuilderA extends MealBuilder { public void buildFood() { meal.setFood(\u0026#34;一个鸡腿堡\u0026#34;); } public void buildDrink() { meal.setDrink(\u0026#34;一杯可乐\u0026#34;); } } // 具体建造者B，实现套餐B的构建 public class SubMealBuilderB extends MealBuilder { public void buildFood() { meal.setFood(\u0026#34;一个鸡肉卷\u0026#34;); } public void buildDrink() { meal.setDrink(\u0026#34;一杯果汁\u0026#34;); } } 原型模式(Prototype) # 模式动机与定义 # 原型模式通过复制对象自身来创建多个相同对象，适用于复杂且频繁创建的场景，节省资源。 不需关心对象类型，直接复制原型对象。符合里氏替换原则，即子类能实现父类所有的功能。 原型模式：通过原型实例指定对象种类，并复制原型创建新对象，无需了解创建细节。 优点 缺点 适用场景 # 优点：\n快速创建对象：能够通过克隆快速创建大量相同或相似的对象，简化了对象的创建过程。 保存对象状态：可以保存对象的中间状态，并基于该状态创建新的对象。 缺点：\n需要改造现有类：每个类都需要实现克隆方法，改造现有类时可能需要修改源代码，不满足开闭原则。 深克隆复杂：如下代码，确实复杂。 适用场景：\n创建成本较大：当创建新对象的成本较大时，通过克隆现有对象来创建新对象可以节省开销。 对象状态变化小：系统需要保存对象的状态，且状态变化较小时，可以使用相似对象的复制。 避免复杂的工厂模式：当不希望使用分层次的工厂类来创建对象时，原型模式可以通过复制原型对象来简化对象的创建过程。 分成两种：浅拷贝、深拷贝的区别如下下图所示\n核心区别是实现的接口不一样，浅拷贝是Cloneable，深拷贝是Serializable，且深拷贝组合的类也需要实现Serializable\n浅拷贝 # 演示代码中还有一个附件类，在 mail(ConcretePrototype) 中组合，用于解释深浅拷贝。\n上图的 object 和 Cloneable 二选一即可。一个是自己写的，一个是 java 带的。\n// 附件类 public class Attachment { // 模拟下载附件的方法 public void download() { System.out.println(\u0026#34;下载附件\u0026#34;); } } // 客户端类，测试克隆功能 public class Client { public static void main(String a[]) { Email email, copyEmail; email = new Email(); // 克隆原始邮件 copyEmail = (Email) email.clone() // 对象是深拷贝 System.out.println(\u0026#34;email==copyEmail?\u0026#34;); System.out.println(email == copyEmail); //false // 附件是同一个对象的浅拷贝 System.out.println(\u0026#34;email.getAttachment==copyEmail.getAttachment?\u0026#34;); System.out.println(email.getAttachment() == copyEmail.getAttachment());//true } } // 邮件类，实现了 Cloneable 接口，支持克隆 public class Email implements Cloneable { // 克隆方法，返回当前对象的浅拷贝 public Object clone() { Email clone = null; try { // 调用父类的 clone() 方法进行浅拷贝 clone = (Email) super.clone(); } catch (CloneNotSupportedException e) { System.out.println(\u0026#34;Clone failure!\u0026#34;); // 如果克隆失败，输出错误信息 } return clone; } // 获取附件的方法 public Attachment getAttachment() { return this.attachment; } // 显示邮件内容的方法 public void display() { System.out.println(\u0026#34;查看邮件\u0026#34;); } } 深拷贝 # import java.io.*; // 附件类，需要实现 Serializable public class Attachment implements Serializable { public void download() { System.out.println(\u0026#34;下载附件\u0026#34;); } } // 客户端类 public class Client { public static void main(String a[]) { Email email, copyEmail = null; email = new Email(); try { // 深克隆 email 对象，区别就在 deep copyEmail = (Email) email.deepClone(); } catch (Exception e) { e.printStackTrace(); } // 对象不是一个对象 System.out.println(\u0026#34;email==copyEmail?\u0026#34;); System.out.println(email == copyEmail); // false，表示是不同的对象 // 附件对象不是一个附件对象 System.out.println(\u0026#34;email.getAttachment==copyEmail.getAttachment?\u0026#34;); System.out.println(email.getAttachment() == copyEmail.getAttachment()); } } // 继承的是 public class Email implements Serializable { private Attachment attachment = null; public Email() { this.attachment = new Attachment(); } // 深克隆实现方法 public Object deepClone() throws IOException, ClassNotFoundException { // 将对象写入字节数组输出流 ByteArrayOutputStream bao = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bao); oos.writeObject(this); // 序列化当前对象到流中 // 从字节数组输入流中读取对象 ByteArrayInputStream bis = new ByteArrayInputStream(bao.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bis); return ois.readObject(); // 反序列化生成新的对象 } // 获取附件的方法 public Attachment getAttachment() { return this.attachment; } // 显示邮件内容的方法 public void display() { System.out.println(\u0026#34;查看邮件\u0026#34;); } } 带原型管理器的原型模式 # 一个维护原型对象集合的专用工厂，通过复制集合中的原型对象来提供克隆服务，并基于抽象原型类实现以支持扩展。本质上 Prototypeable 就是个哈希表。\nimport java.util.*; // 定义颜色接口,继承Cloneable接口以支持克隆 interface MyColor extends Cloneable { public Object clone(); // 克隆方法 public void display(); // 显示颜色 } // 实现红色类 class Red implements MyColor { // 实现克隆方法 public Object clone() { Red r = null; try { r = (Red)super.clone(); // 调用Object的clone()方法 } catch(CloneNotSupportedException e) { } return r; } public void display() { System.out.println(\u0026#34;This is Red!\u0026#34;); } } // 实现蓝色类,结构同Red类 class Blue implements MyColor { public Object clone() { Blue b = null; try { b = (Blue)super.clone(); } catch(CloneNotSupportedException e) { } return b; } public void display() { System.out.println(\u0026#34;This is Blue!\u0026#34;); } } // 原型管理器类 class PrototypeManager { private Hashtable ht = new Hashtable(); // 存储原型对象的哈希表 // 初始化,加入默认原型 public PrototypeManager() { ht.put(\u0026#34;red\u0026#34;, new Red()); ht.put(\u0026#34;blue\u0026#34;, new Blue()); } // 添加新原型 public void addColor(String key, MyColor obj) { ht.put(key, obj); } // 获取原型克隆 public MyColor getColor(String key) { return (MyColor)((MyColor)ht.get(key)).clone(); } } // 客户端测试类 class Client { public static void main(String args[]) { PrototypeManager pm = new PrototypeManager(); // 获取两个红色对象并显示 MyColor obj1 = (MyColor)pm.getColor(\u0026#34;red\u0026#34;); obj1.display(); MyColor obj2 = (MyColor)pm.getColor(\u0026#34;red\u0026#34;); obj2.display(); // 判断两个对象是否相同 System.out.println(obj1 == obj2); // 输出false,因为是克隆对象 } } 相似对象的复制 # 其实就是多个对象类似，一两个值不一样，先复制再改值。\npublic static void main(String args[]) { // 创建原型对象 stu1 = new Student(\u0026#34;张无忌\u0026#34;,\u0026#34;男\u0026#34;,24,\u0026#34;软件工程\u0026#34;,\u0026#34;软件学院\u0026#34;,\u0026#34;中南大学\u0026#34;); // 克隆两个新对象并修改部分属性 stu2 = stu1.clone(); // 克隆stu1 stu2.setStuName(\u0026#34;杨过\u0026#34;); // 只修改姓名 stu3 = stu1.clone(); // 再次克隆stu1 stu3.setStuName(\u0026#34;小龙女\u0026#34;); // 修改姓名和性别 stu3.setStuSex(\u0026#34;女\u0026#34;); } 单例模式(Singleton) # 三个要点：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。\n// 下面为懒汉式，第一次调用才创建对象 // 需要处理好多线程问题 public class Singleton { // 静态变量，保存类的唯一实例 private static Singleton instance = null; // 私有构造函数，防止外部实例化 private Singleton() { } // 静态方法，返回类的唯一实例 public static Singleton getInstance() { if(instance == null) { instance = new Singleton(); } return instance; } } // 下面是饿汉式，在类加载时，便将单例实例创建好 // 该方式的实现是线程安全的，但稍微浪费资源（实例可能用不到） public class HungrySingleton { // 在类加载时，立即初始化实例 private static final HungrySingleton instance = new HungrySingleton(); // 私有构造函数，防止外部实例化 private HungrySingleton() {} // 提供静态方法获取唯一实例 public static HungrySingleton getInstance() { return instance; } } // 哈希表多例模式，不指定数量，而是每个 key 对应一个多例 public class Multiton { // 存储不同实例的Map，按标识符存储 private static Map\u0026lt;String, Multiton\u0026gt; instances = new HashMap\u0026lt;\u0026gt;(); // 私有构造函数，防止外部实例化 private Multiton() { } // 获取多例实例的方法，根据标识符返回不同的实例 public static Multiton getInstance(String key) { if (!instances.containsKey(key)) { instances.put(key, new Multiton()); // 如果不存在，则创建并保存实例 } return instances.get(key); // 返回已有的实例 } } // 三例模式 public class Multiton { // 定义固定数量的实例（如三例） private static final int INSTANCE_COUNT = 3; // 用于存储三个实例的数组 private static final Multiton[] instances = new Multiton[INSTANCE_COUNT]; // 使用一个计数器来轮流分配实例 private static int currentInstanceIndex = 0; // 私有构造函数，防止外部通过 new 创建对象 private Multiton() { } // 获取下一个实例的方法 public static synchronized Multiton getInstance() { // 如果实例未被创建，先创建实例 if (instances[currentInstanceIndex] == null) { instances[currentInstanceIndex] = new Multiton(); } // 获取当前实例 Multiton instance = instances[currentInstanceIndex]; // 循环更新索引，以便下次调用时返回下一个实例 currentInstanceIndex = (currentInstanceIndex + 1) % INSTANCE_COUNT; return instance; } // 示例方法，模拟实例执行的操作 public void doSomething() { System.out.println(\u0026#34;实例 \u0026#34; + this + \u0026#34; 正在执行操作\u0026#34;); } } 结构型模式 # 适配器模式 # 转换匹配，复用功能。将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类 可以一起工作。\n**类适配器模式：**通过继承来实现适配，能更灵活地置换方法，但受限于多重继承和目标类的局限。 **对象适配器模式：**通过组合来实现适配，能够适配多个类，但置换方法较为复杂。\n适合场景：\n系统需要使用现有类，而这些类的接口不符合需求。 适配器模式适用于当系统中需要使用现有类，但它们的接口与系统不兼容的情况。 希望创建一个可复用的适配器类，用于与多个不相关的类（适配者类和目标类）一起工作。 包括将来可能引入的适配者类的子类也能一起适配。 类适配器 # // 被适配者类 (旧的接口) class Adaptee { public void specificRequest() { System.out.println(\u0026#34;Adaptee: Handling specific request\u0026#34;); } } // 目标接口 (客户端期望的接口) interface Target { void request(); } // 适配器类 (实现了Target接口，适配Adaptee) public class Adapter extends Adaptee implements Target { public void request() { specificRequest(); // 把客户端的request方法适配为Adaptee的specificRequest } } // 客户端类 public class Client { public static void main(String[] args) { Target target = new Adapter(); // 客户端通过Target接口使用Adapter target.request(); // 实际上调用的是Adaptee的specificRequest方法 } } 优点：\n灵活性更强 由于适配器类是适配者类的子类，因此可以在适配器类中置换一些适配者的方法 缺点\n多重继承限制，对于不支持多重继承的语言（如 Java、C#），类适配器模式一次最多只能适配一个适配者类。 目标类限制，目标抽象类只能是抽象类，不能是具体类，使用上有一定的局限性。 无法适配子类，不能将一个适配者类及其子类都适配到目标接口。 对象适配器 # // 目标接口 (客户端期望的接口) public class Target { public void request() { System.out.println(\u0026#34;Target: Handling request\u0026#34;); } } // 被适配者类 (旧的接口) public class Adaptee { public void specificRequest() { System.out.println(\u0026#34;Adaptee: Handling specific request\u0026#34;); } } // 适配器类 (通过组合方式实现适配) public class Adapter extends Target { private Adaptee adaptee; // 适配器持有被适配者的引用 // 构造函数，传入被适配者的实例 public Adapter(Adaptee adaptee) { this.adaptee = adaptee; } // 实现Target的request方法，实际上调用Adaptee的specificRequest方法 @Override public void request() { adaptee.specificRequest(); } } // 客户端类，和类对象一致 public class Client { public static void main(String[] args) { Adaptee adaptee = new Adaptee(); Target target = new Adapter(adaptee); target.request(); // 实际上调用的是Adaptee的specificRequest方法 } } 优点：\n适配多个类，一个对象适配器可以将多个不同的适配者适配到同一个目标，即同一个适配器可以将适配者类及其子类都适配到目标接口。 缺点：\n较难置换方法 与类适配器相比，对象适配器要想置换适配者类的方法较为不便。如果需要置换适配者类的一个或多个方法，必须先创建适配者类的子类，在子类中置换方法，再将该子类作为真正的适配者进行适配。 对象适配器还可能如下形式：\n其中 DataOperator 是 target，而两个 adapter 按情况分配适配接口。\n模型扩展 # 默认适配器模式\n双向适配器\n智能适配器\n适配多个适配者\n桥接模式 # 桥接模式的本质：分离抽象和实现\n需要将需求转化为两个维度，固有维度（比如毛笔尺寸）做抽象类，另一个维度（比如毛笔颜色）做接口实现类。\n// 实现部分：Color接口 public interface Color { void bepaint(String penType, String name); } public class Red implements Color { @Override public void bepaint(String penType, String name) { System.out.println(penType + \u0026#34; Red color \u0026#34; + name + \u0026#34;.\u0026#34;); } } public class Green implements Color { @Override public void bepaint(String penType, String name) { System.out.println(penType + \u0026#34; Green color \u0026#34; + name + \u0026#34;.\u0026#34;); } } // 抽象部分：Pen类 public abstract class Pen { protected Color color; // 设置颜色 public void setColor(Color color) { this.color = color; } // 抽象绘画方法 public abstract void draw(String name); } public class SmallPen extends Pen { @Override public void draw(String name) { color.bepaint(\u0026#34;SmallPen\u0026#34;, name); } } public class BigPen extends Pen { @Override public void draw(String name) { color.bepaint(\u0026#34;BigPen\u0026#34;, name); } } // 测试类 public class Client { public static void main(String[] args) { // 创建一种颜色（红色） Color red = new Red(); // 创建一种笔（大号笔），并设置颜色 Pen bigPen = new BigPen(); bigPen.setColor(red); bigPen.draw(\u0026#34;Flower\u0026#34;); // 创建另一种颜色（绿色） Color green = new Green(); // 使用小号笔，并设置为绿色 Pen smallPen = new SmallPen(); smallPen.setColor(green); smallPen.draw(\u0026#34;Tree\u0026#34;); } } 模式优点：\n桥接模式通过对象间的关联解耦了抽象与实现。符合组合/聚合复用原则 减少子类数量：桥接模式可以替代多重/多层继承，避免违背单一职责原则。 提高可扩展性：在任意维度上扩展时，不需修改原有系统，符合开闭原则，系统更具扩展性。 模式缺点：\n增加设计难度：桥接模式要求开发者从一开始就设计抽象层。 需要正确识别系统中的两个独立变化的维度，这需要一定的经验积累，否则使用范围有限。 模式适用环境：\n灵活性需求：当系统需要在抽象化和具体化之间增加更多灵活性，避免静态继承关系时，桥接模式可以通过关联关系实现动态耦合。 独立扩展：当一个类有两个或多个独立变化的维度，并且这些维度需要独立扩展时，桥接模式尤为适用。 避免多重继承：对于不希望使用多重/多层继承，或者因继承导致类急剧增加的系统，桥接模式是更好的选择。用聚合代替多重继承。 适配器模式与桥接模式的联用 # // 抽象部分：报表显示 abstract class ReportDisplay { protected DataCollector dataCollector; public ReportDisplay(DataCollector dataCollector) { this.dataCollector = dataCollector; } public abstract void display(); } // 具体实现：报表显示方式1 class ReportDisplayStyle1 extends ReportDisplay { public ReportDisplayStyle1(DataCollector dataCollector) { super(dataCollector); } @Override public void display() { System.out.println(\u0026#34;Displaying report in style 1:\u0026#34;); dataCollector.collectData(); } } // 实现部分：数据采集接口 interface DataCollector { void collectData(); } // 适配器类：读取Excel文件的适配器，适配Excel API class ExcelFileCollector implements DataCollector { private ExcelAPI excelAPI; public ExcelFileCollector(ExcelAPI excelAPI) { this.excelAPI = excelAPI; } @Override public void collectData() { excelAPI.readExcel(); } } // Excel API 模拟类 class ExcelAPI { public void readExcel() { System.out.println(\u0026#34;Collecting data from Excel file using Excel API.\u0026#34;); } } 组合模式 # 组合模式的本质：**统一叶子对象和组合对象。**处理了树状结构。\n// 抽象类 MyElement，定义 eat() 抽象方法 public abstract class MyElement { public abstract void eat(); } // Plate 类，包含 MyElement 对象的集合，并实现 eat() 方法 public class Plate extends MyElement { private List\u0026lt;MyElement\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); // 注意是私有列表 public void add(MyElement element) { // 组合模式标准的添加元素 list.add(element); } public void delete(MyElement element) { // 删除元素 list.remove(element); } // 实现 eat() 方法，调用每个元素的 eat() // 可以实现 eat() 盘子中的所有水果 @Override public void eat() { for (MyElement element : list) { element.eat(); } } } // Apple 类，具体实现 eat() 方法 public class Apple extends MyElement { @Override public void eat() { System.out.println(\u0026#34;Eating an apple!\u0026#34;); } } // Pear 类，具体实现 eat() 方法 public class Pear extends MyElement { @Override public void eat() { System.out.println(\u0026#34;Eating a pear!\u0026#34;); } } // 测试类 Client public class Client { public static void main(String[] args) { // 创建 MyElement 对象 MyElement obj1, obj2, obj3, obj4, obj5; Plate plate1, plate2, plate3; // 创建水果对象 obj1 = new Apple(); obj2 = new Pear(); // 创建盘子 plate1 并添加水果 plate1 = new Plate(); plate1.add(obj1); plate1.add(obj2); // 创建更多水果对象 obj3 = new Banana(); obj4 = new Banana(); // 创建盘子 plate2 并添加水果 plate2 = new Plate(); plate2.add(obj3); plate2.add(obj4); // 创建 plate3，它可以包含其他盘子和水果 obj5 = new Apple(); plate3 = new Plate(); plate3.add(plate1); plate3.add(plate2); plate3.add(obj5); // 调用 eat() 方法，演示组合模式的效果 System.out.println(\u0026#34;Plate 1 contents:\u0026#34;); plate1.eat(); // Plate 1 吃掉其包含的水果 System.out.println(\u0026#34;\\nPlate 3 contents:\u0026#34;); plate3.eat(); // Plate 3 吃掉 plate1, plate2 和一个 Apple } } 优点：\n统一对象操作：叶子对象与组合对象共享统一的接口，简化了客户端代码，无需区分具体类型。 递归结构：支持将对象组合成更复杂的结构，可以不断递归组合，形成整体-部分层次结构。 易于扩展：新增叶子或组合对象时，客户端无需修改，新的子类能够无缝集成。 缺点：\n类型限制难：很难在编译时限制组合中只能包含特定类型的组件，必须在运行时动态检查。 适用场景：\n表示整体-部分层次结构。 需要统一操作组合结构中的所有对象。 模型扩展 # 透明组合模式：在抽象类中包含了管理成员对象的方法（如包括add()、remove()以及getChild()等），使客户端可以平等的看待所有的对象，缺点是不够安全。\n安全组合模式：与透明组合相反，在抽象组件中没有声明任何用于管理成员对象的方法（水果篮例子就是如此），缺点是不够透明。\n更复杂的组合模式：叶子和 Composite 都可以继续继承，如下图：\n装饰模式 # 装饰模式的本质：**动态组合。**动态是手段，组合才是目的。\n形态上很像组合模式，在 Composite 中继续继承两个子类。\n变形金刚实例如下：\n// 定义基础接口 Transform public interface Transform { public void move(); } // Car 类，实现 Transform 接口，表示一辆车 public final class Car implements Transform { public Car() { System.out.println(\u0026#34;变形金刚是一辆车！\u0026#34;); } @Override public void move() { System.out.println(\u0026#34;在陆地上移动！\u0026#34;); } } // Changer 类，装饰器基类，持有一个 Transform 对象 public class Changer implements Transform { private Transform transform; // 私有变量 public Changer(Transform transform) { // 通过构造函数改变 transform this.transform = transform; } @Override public void move() { transform.move(); } } // Robot 类，继承 Changer，扩展了说话功能 public class Robot extends Changer { public Robot(Transform transform) { super(transform); // 调用父类的构造函数，改变父类的 transform，即改变其 move 函数 System.out.println(\u0026#34;变成机器人！\u0026#34;); } public void say() { System.out.println(\u0026#34;说话！\u0026#34;); } } // Client 测试类 public class Client { public static void main(String[] args) { // 创建一个基础的 Car 对象 Transform camaro = new Car(); camaro.move(); // 在陆地移动 System.out.println(\u0026#34;-----------------------------\u0026#34;); // 使用 Robot 装饰 Car 对象，添加说话功能 Robot optimus = new Robot(camaro); optimus.move(); //还是 Car 的移动功能 optimus.say(); // Robot 的说话功能 } } 多层装饰 # 当 decorator 有多个子类时，可以进行多重装饰。但装饰到最里面一定是某一个 ConcreteComponent。\n历年题中的例子如下：\npublic class Client { public static void main(String[] args) { Person p1, p2; p1 = new Person(\u0026#34;张三\u0026#34;, 5000, 1000, 10000); p2 = new Person(\u0026#34;李四\u0026#34;, 10000, 2000, 20000); Factory.addPerson(\u0026#34;张三\u0026#34;, p1); Factory.addPerson(\u0026#34;李四\u0026#34;, p2); Component e1, m1, personBusiness, personPayback, teamBusiness; String name; e1 = new Employee(); name = p1.getName(); personBusiness = new PersonBusiness(e1); // 张三是员工，装饰了一层 PersonPayback personPayback = new PersonPayback(personBusiness) // 再装饰一层 PersonPayback System.out.print(name); System.out.println(personPayback.getDes(name)); System.out.println(personPayback.getBonus(name)); m1 = new Manager(); name = p2.getName(); personBusiness = new PersonBusiness(m1); // 李四是员工，装饰一层 PersonPayback personPayback = new PersonPayback(personBusiness); // 再装饰一层 teamBusiness = new TeamBusiness(personPayback); System.out.print(name); System.out.println(teamBusiness.getDes(name)); System.out.println(teamBusiness.getBonus(name)); } } /* 张三普通员工获得个人业务奖金获得个人回款奖金 151.0 李四经理获得个人业务奖金获得个人回款奖金获得团队业务奖金 502.0 */ 模式优点\n灵活性高：相比继承，装饰模式更灵活。继承是静态的，而装饰模式通过将功能分离到不同的装饰器中，可以在运行时动态组合功能，决定最终的行为。 易于复用：装饰器将每个功能独立实现，简化了功能的复用。多个装饰器可以叠加在同一对象上，或者同一个装饰器可以用于不同对象，提升了功能的复用性。 简化高层定义：高层定义只需要定义基本功能，通过组合装饰器来动态增加功能，避免在高层设计时考虑所有功能需求。 模式缺点\n对象数量增加：每个装饰器负责不同功能，可能会导致大量细粒度对象的产生，增加系统资源消耗，影响性能。\n调试复杂：由于装饰模式涉及多次功能叠加，调试可能需要逐级排查装饰链。\n适用环境\n需要动态、透明地为单个对象添加职责，且不影响其他对象。 无法通过继承扩展系统，或继承不利于系统维护时，适合使用装饰模式。特别是当扩展过多或类被定义为不可继承（如 Java 中的 final 类）时，装饰模式是更好的选择。 模式扩展 # 半透明装饰模式：上面变形金刚的例子就是半透明，允许 client 调用具体的实现类（例子中是robot）。好处是可以添加新的功能，比如例子中的说话。\n透明装饰模式：所有的功能都在接口或抽象类中表现，client 只调用最高层的接口或抽象类，导致其不能添加新功能，只能在原有的功能上修改。在多重加密系统中使用。\n装饰模式简化：删去了最高层的接口或抽象类，转而用具体组件类来代替，要求具体组件功能实现较少：\n外观模式 # 外观模式的本质：封装交互，简化调用。\n外观模式是迪米特法则的具体体现。\n// Fan 类，表示风扇 public class Fan { public void on() { System.out.println(\u0026#34;风扇打开！\u0026#34;); } public void off() { System.out.println(\u0026#34;风扇关闭！\u0026#34;); } } // Light 类，表示灯光 public class Light { private String position; public Light(String position) { this.position = position; } public void on() { System.out.println(this.position + \u0026#34;灯打开！\u0026#34;); } public void off() { System.out.println(this.position + \u0026#34;灯关闭！\u0026#34;); } } // GeneralSwitchFacade 类，作为开关的外观模式 public class GeneralSwitchFacade { private Light[] lights = new Light[4]; // 用私有变量关联具体类 private Fan fan; private AirConditioner ac; private Television tv; public GeneralSwitchFacade() { // 组合成一个开关 lights[0] = new Light(\u0026#34;左前\u0026#34;); ... fan = new Fan(); ac = new AirConditioner(); tv = new Television(); } // 打开所有设备 public void on() { for (Light light : lights) { light.on(); } fan.on()；... } // 关闭所有设备 public void off() { for (Light light : lights) { light.off(); } fan.off(); ... } } // Client 测试类 public class Client { public static void main(String[] args) { GeneralSwitchFacade gsf = new GeneralSwitchFacade(); gsf.on(); // 打开所有设备 System.out.println(\u0026#34;-----------------------\u0026#34;); gsf.off(); // 关闭所有设备 } } 模式优点\n简化客户端代码：减少了客户端需要处理的对象数量. 降低耦合性：外观模式实现了客户端与子系统之间的松耦合。 分层结构清晰 需要暴露给外部的功能集中在外观类中，方便客户端使用，同时隐藏了系统内部的复杂细节。 不影响直接访问子系统：外观模式提供了访问子系统的统一入口，但并不限制用户直接使用子系统类，保留了系统的灵活性。 模式缺点\n对子系统类限制不严格：外观模式无法严格限制客户端直接访问子系统类，可能导致系统复杂度增加。 可能违背开闭原则：如果设计不当，增加新的子系统可能需要修改外观类的源代码，从而违背开闭原则。 适用环境\n当需要为复杂子系统提供一个简单接口时，可以使用外观模式。 当客户端程序与多个子系统之间存在很大依赖时，外观模式可以通过引入外观类将子系统与客户端解耦。 在层次化结构中，外观模式可以为每一层定义统一的入口。 模型扩展 # 一个系统有多个外观类：在通常情况下，只有一个外观类（使用单例），比如例子中只有一个开关。但实际上也有需要使用多个外观类的情况，每个外观类都负责和一些特定的子系统交互。不要试图通过外观类为子系统增加新行为。\n抽象外观类：若有多个外观类，单纯的设计会导致违反开闭原则，因此往往通过抽象外观类进行设计。使得在引入抽象外观类之后，不需要修改原有外观类。\n代理模式 # 代理模式的本质：控制对象访问。\n远程代理 (Remote Proxy)\n功能：为远程对象提供本地代理，简化跨网络的对象调用。 应用场景：分布式系统，如 DCOM、Web Service、Java RMI、CORBA。 优点：客户端可以像调用本地对象一样访问远程对象，隐藏了网络通信的复杂性。 虚拟代理 (Virtual Proxy)\n功能：延迟创建资源消耗大的对象，只有在需要时才真正创建。 应用场景：系统中有高成本对象（如图像、文件等）的按需加载。 优点：优化性能，减少系统初始开销，节省内存和计算资源。 保护代理 (Protect Proxy)\n功能：根据用户权限控制对对象的访问。 应用场景：需要基于角色或权限进行访问控制的系统。 优点：增强安全性，确保不同用户只能访问他们有权操作的功能。 缓冲代理 (Cache Proxy)\n功能：为目标操作的结果提供缓存，减少重复操作。 应用场景：频繁访问不经常变化的数据，如数据查询缓存。 优点：提高性能，减少计算或数据获取的开销。 智能引用代理 (Smart Reference Proxy)\n功能：在对象引用时，增加额外操作，如记录调用次数、管理对象生命周期。 应用场景：需要监控对象使用或增加引用管理的场景。 优点：增强对象管理功能，提供更多控制和监控能力。 防火墙代理 (Firewall Proxy)\n功能：控制对网络资源的访问，保护对象免受不可信客户端的侵害。 应用场景：网络安全系统，如公司的防火墙。 优点：提高系统安全性，限制对敏感资源的非法访问。 同步代理 (Synchronization Proxy)\n功能：在多线程环境下，确保对对象的安全访问。 应用场景：并发系统，如分布式系统中的同步访问控制。 优点：防止数据竞争，确保多线程的并发安全性。 写入时复制代理 (Copy-On-Write Proxy)\n功能：延迟对象的复制操作，直到真正需要时才进行复制。 应用场景：需要优化内存和性能的场景，特别是只读对象的复制。 优点：减少不必要的深拷贝操作，优化性能和资源使用。 // 客户端类 public class Client { public static void main(String[] args) { // 使用XMLUtil从配置中获取权限对象，假设返回的是代理类 AbstractPermission permission = (AbstractPermission) XMLUtil.getBean(); // 初始权限级别为0，尝试执行各种操作 permission.modifyUserInfo();... // 设置权限级别为1，再次尝试执行操作 permission.setLevel(1); permission.modifyUserInfo();... } } // 抽象权限接口，定义所有权限操作 public interface AbstractPermission { void modifyUserInfo(); // 修改用户信息权限 void viewNote(); // 查看帖子权限 void publishNote(); // 发布帖子权限 void modifyNote(); // 修改帖子权限 void setLevel(int level); // 设置权限级别 } // 真实权限类，实现具体的权限操作 public class RealPermission implements AbstractPermission { @Override public void modifyUserInfo() { // 需要权限的功能 System.out.println(\u0026#34;修改用户信息！\u0026#34;); } @Override public void viewNote() { // 不需要权限的功能 // 可以一直查看帖子，无需权限 } } // 权限代理类，控制访问权限 public class PermissionProxy implements AbstractPermission { // 私有变量，关联关系。虽然有 new，但从生命周期的角度看应该是关联而非组合。 private RealPermission permission = new RealPermission(); // 持有真实权限对象 private int level = 0; // 默认权限级别为0 @Override public void modifyUserInfo() { if (level == 0) { System.out.println(\u0026#34;对不起，你没有修改用户信息的权限!\u0026#34;); } else if (level == 1) { permission.modifyUserInfo(); } } @Override public void viewNote() { // 可以直接查看不需要权限 System.out.println(\u0026#34;查看帖子！\u0026#34;); } } 模式优点\n降低耦合性：代理模式在调用者和被调用者之间引入代理，减少了它们之间的直接依。 符合开闭原则：客户端针对抽象接口编程。 提升系统性能：远程代理和虚拟代理可以将资源密集型操作从本地转移或延迟执行。 权限控制：保护代理可以根据用户权限控制访问，提供不同级别的功能，增强系统的安全性。 缓存优化：缓冲代理通过缓存操作结果，提高重复操作的效率，缩短执行时间。 模式缺点\n性能开销：代理模式增加了一层间接性，可能导致请求处理变慢，尤其是在频繁调用时。 实现复杂：某些代理模式（如远程代理、缓存代理）的实现较为复杂，开发和维护成本较高。 适用环境\n当客户端需要访问远程对象时，可以使用远程代理，屏蔽网络通信的复杂性。 当需要延迟创建高成本对象时，可以使用虚拟代理，减少系统初始开销。 当需要为频繁访问的结果提供缓存时，适合使用缓冲代理，避免重复计算。 当需要控制权限访问时，适合使用保护代理，基于用户权限提供不同功能。 当需要在对象引用时执行额外操作（如计数、管理）时，可以使用智能引用代理。 模型扩展 # 动态代理： Java 反射机制（主要是 java.lang.reflect.Proxy 和 InvocationHandler）来实现。\n// 抽象主题接口，定义了代理类与真实主题类共有的行为 public interface AbstractSubject { void request(); // 抽象方法，代理类和真实主题类都会实现 } // 真实主题类A，实现了AbstractSubject接口 public class RealSubjectA implements AbstractSubject { @Override public void request() { System.out.println(\u0026#34;真实主题类A！\u0026#34;); } } // 真实主题类B，实现了AbstractSubject接口 public class RealSubjectB implements AbstractSubject { @Override public void request() { System.out.println(\u0026#34;真实主题类B！\u0026#34;); } } // 动态代理类，负责在真实对象方法调用前后执行额外操作 import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; public class DynamicProxy implements InvocationHandler { private Object obj; // 持有被代理的真实对象 // 无参构造方法 public DynamicProxy() {} // 有参构造方法，传入被代理对象 public DynamicProxy(Object obj) { this.obj = obj; } // 动态代理的核心方法，拦截对代理对象的所有方法调用 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { preRequest(); // 调用前操作 method.invoke(obj, args); // 调用真实对象的方法 postRequest(); // 调用后操作 return null; } public void preRequest() { // 调用前的操作（如日志记录） System.out.println(\u0026#34;调用之前！\u0026#34;); } public void postRequest() { // 调用后的操作（如日志记录） System.out.println(\u0026#34;调用之后！\u0026#34;); } } // 客户端类，演示如何使用动态代理 import java.lang.reflect.Proxy; public class Client { public static void main(String[] args) { InvocationHandler handler; // 动态代理的调用处理器 AbstractSubject subject; // 抽象主题接口 // 使用动态代理代理真实主题类A handler = new DynamicProxy(new RealSubjectA()); subject = (AbstractSubject) Proxy.newProxyInstance( AbstractSubject.class.getClassLoader(), new Class[]{AbstractSubject.class}, handler ); subject.request(); // 调用代理对象的方法，触发invoke方法 System.out.println(\u0026#34;------------------------------\u0026#34;); // 使用动态代理代理真实主题类B handler = new DynamicProxy(new RealSubjectB()); subject = (AbstractSubject) Proxy.newProxyInstance( AbstractSubject.class.getClassLoader(), new Class[]{AbstractSubject.class}, handler ); subject.request(); // 调用代理对象的方法，触发invoke方法 } } 行为型模式 # 行为型模式(Behavioral Pattern)是对在不同的对象之间划分责任和算法的抽象化。\n行为型模式不仅仅关注类和对象的结构，而且重点关注它们之间的相互作用。\n责任链模式 # 职责链模式的本质：分离职责，动态组合。\n职责链可以是直线，树，环等等，常见的是直线。\n和组合模式比较像，区别如下：\n处理方式不同：\n在 职责链模式 中，如果一个对象处理了请求，链条的传递就终止了，处理者唯一。 在 组合模式 中，操作会应用到所有子对象上，处理是递归的，可能会遍历整个树形结构。 应用场景不同：\n职责链模式 适用于多个对象都有机会处理请求的情况，但处理者不明确，希望请求自动沿着链传递直到找到合适的处理者。 组合模式 适用于需要表示部分-整体层次结构的场景，希望客户端无差别地处理单个对象和组合对象。 // 主任类，处理较短时间的请假 public class Director extends Leader { public Director(String name) { super(name); // 调用父类的构造函数 } // 处理请假请求 public void handleRequest(LeaveRequest request) { if (request.getLeaveDays() \u0026lt; 3) { // 如果请假天数少于3天，主任处理 System.out.println(\u0026#34;主任\u0026#34; + name + \u0026#34;审批员工\u0026#34; + request.getLeaveName() + \u0026#34;的请假条，请假天数为\u0026#34; + request.getLeaveDays() + \u0026#34;天。\u0026#34;); } else { if (this.successor != null) { // 如果超过3天，且有上级领导，交给下一个领导处理 this.successor.handleRequest(request); } } } } // 总经理类，处理较大时间范围的请假 ... // 抽象领导类，定义了职责链中的公共行为 public abstract class Leader { protected String name; // 领导的姓名，注意最好用 protected protected Leader successor; // 下一个处理请求的领导，最好用 protected，如果是树，应该用列表表示 public Leader(String name) { this.name = name; } public void setSuccessor(Leader successor) { // 设置下一个处理者 this.successor = successor; } public abstract void handleRequest(LeaveRequest request);// 抽象方法，处理请假请求 } // 请假请求类，封装请假者的姓名和请假天数 public class LeaveRequest { private String leaveName; // 请假者的姓名 private int leaveDays; // 请假天数 public LeaveRequest(String leaveName, int leaveDays) { // 构造函数 this.leaveName = leaveName; this.leaveDays = leaveDays; } // 经典 set 与 get public void setLeaveName(String leaveName) { this.leaveName = leaveName; } 。。。 public String getLeaveName() { return this.leaveName; } 。。。 } // 客户端类，模拟请假审批流程 public class Client { public static void main(String args[]) { // 创建各级审批领导 Leader objDirector, objManager, objGeneralManager, objViceGeneralManager; objDirector = new Director(\u0026#34;王明\u0026#34;); objManager = new Manager(\u0026#34;赵强\u0026#34;);... // 设置职责链，将各级领导串联起来，类似链表 objDirector.setSuccessor(objManager); objManager.setSuccessor(objViceGeneralManager); objViceGeneralManager.setSuccessor(objGeneralManager); LeaveRequest lr4 = new LeaveRequest(\u0026#34;赵六\u0026#34;, 25); // 赵六请假25天 objDirector.handleRequest(lr4); // 处理请求 } } 模式扩展： # 职责链模式分为纯的职责链模式和不纯的职责链模式：\n纯的职责链模式：每个处理者要么处理请求，要么将请求传递给下一个处理者，且不返回。（比如上面的请假例子） 不纯的职责链模式：每个处理者可以处理请求并将请求继续传递，或者在处理后终止传递。 优点缺点： # 模式优点\n降低耦合度：职责链模式将请求的发送者与处理者解耦，发送者无需知道具体的处理者是谁，只需将请求提交到链上。 简化对象连接：每个处理对象只需要保存对其后继者的引用，而不需要保存对所有可能处理者的引用，简化了对象之间的连接关系。 灵活性高：职责链结构可以在运行时动态修改，处理者可以在链中动态增加、删除或重新排序。 符合开闭原则：增加新的处理者时不需要修改现有代码，只需在客户端重新构建职责链即可。 模式缺点\n请求可能得不到处理：如果链末尾没有合适的处理者，或职责链配置不当，可能导致请求得不到任何处理。 性能开销：对于较长的职责链，处理请求需要经过多个对象，可能导致处理效率降低。 调试困难：链条过长时，调试和跟踪请求的处理过程可能会变得复杂。 可能产生循环调用：如果存在环形结构，可能会导致循环调用，进而引发系统死循环。 适用环境\n当有多个对象可以处理同一请求时，职责链模式适用于在请求发出时不明确指定请求的接收者。 当请求的处理对象在运行时动态确定时，职责链模式可以灵活地调整处理者的顺序或增加新的处理者。 当需要将请求提交给一组处理者中的某一个或某几个，而不必明确指定具体的处理者时，职责链模式适用。 当希望客户端只需将请求提交给职责链，而不关心具体的处理过程时。 命令模式 # 命令模式的本质：封装请求。\n// 命令模式的实现：将请求封装成对象，使得请求的发送者和接收者解耦。 // 这里的例子是电视遥控器控制电视的开、关、换台操作。 // 抽象命令接口，定义了所有具体命令类的统一操作接口 public interface AbstractCommand { public void execute(); } // 具体命令类：打开电视命令 public class TVOpenCommand implements AbstractCommand { private Television tv; // 构造方法中关联接收者（电视） public TVOpenCommand() { tv = new Television(); } // 执行命令，调用电视的开机方法 public void execute() { tv.open(); } } // 具体命令类：关闭电视命令 public class TVCloseCommand implements AbstractCommand { ... } // 具体命令类：切换电视频道命令 public class TVChangeCommand implements AbstractCommand { ... } // 接收者类：电视，包含具体的操作方法 public class Television { public void open() { System.out.println(\u0026#34;打开电视机！\u0026#34;); } public void close() { System.out.println(\u0026#34;关闭电视机！\u0026#34;); } public void changeChannel() { System.out.println(\u0026#34;切换电视频道！\u0026#34;); } } // 调用者类：遥控器，负责执行命令 public class Controller { private AbstractCommand openCommand, closeCommand, changeCommand; // 遥控器构造函数，传入具体的命令对象 public Controller(AbstractCommand openCommand, AbstractCommand closeCommand, AbstractCommand changeCommand) { this.openCommand = openCommand; this.closeCommand = closeCommand; this.changeCommand = changeCommand; } public void open() { // 调用打开电视的命令 openCommand.execute(); } public void change() { // 调用切换频道的命令 changeCommand.execute(); } public void close() { // 调用关闭电视的命令 closeCommand.execute(); } } // 客户端类：设置命令并触发请求 public class Client { public static void main(String[] args) { // 创建具体命令对象 AbstractCommand openCommand = new TVOpenCommand(); AbstractCommand closeCommand = new TVCloseCommand(); AbstractCommand changeCommand = new TVChangeCommand(); // 创建遥控器（调用者），并传入命令对象 Controller control = new Controller(openCommand, closeCommand, changeCommand); // 模拟使用遥控器控制电视操作 control.open(); // 打开电视 control.change(); // 切换频道 control.close(); // 关闭电视 } } 模型扩展 # 命令队列： # 它用于将多个命令对象按顺序存储在一个队列中，并在适当的时机依次执行这些命令。命令队列的主要作用是将命令的请求和执行解耦，允许命令的执行可以被延迟或批量处理。\nclass CommandQueue { //定义一个ArrayList来存储命令队列 private ArrayList\u0026lt;Command\u0026gt; commands = new ArrayList\u0026lt;Command\u0026gt;(); public void addCommand(Command command) { commands.add(command); } public void removeCommand(Command command) { commands.remove(command); } //循环调用每一个命令对象的execute()方法 public void execute() { for (Object command : commands) { ((Command)command).execute(); } } } class Invoker { private CommandQueue commandQueue; //维持一个CommandQueue对象的引用 //构造注入 public Invoker(CommandQueue commandQueue) { this.commandQueue =commandQueue; } //设值注入 public void setCommandQueue(CommandQueue commandQueue) { this.commandQueue = commandQueue; } //调用CommandQueue类的execute()方法 public void call() { commandQueue.execute(); } } 请求日志： # 模式通常用于记录系统中执行的命令或操作，以便后续进行操作的回放、撤销（undo）或恢复（redo）。\n// 配置文件操作类：请求接收者 // 实现Serializable接口，确保对象可以被序列化并写入文件 class ConfigOperator implements Serializable { // 插入新节点 public void insert(String args) { System.out.println(\u0026#34;增加新节点：\u0026#34; + args); } // 修改节点 public void modify(String args) { System.out.println(\u0026#34;修改节点：\u0026#34; + args); } // 删除节点 public void delete(String args) { System.out.println(\u0026#34;删除节点：\u0026#34; + args); } } // 配置文件设置窗口类：请求发送者 // 负责调用具体的命令对象并保存执行日志 class ConfigSettingWindow { // 定义一个集合来存储每一次操作时的命令对象 private ArrayList\u0026lt;Command\u0026gt; commands = new ArrayList\u0026lt;Command\u0026gt;(); private Command command; // 注入具体命令对象 public void setCommand(Command command) { this.command = command; } // 执行配置文件修改命令，同时将命令对象添加到命令集合中 public void call(String args) { command.execute(args); commands.add(command); } // 记录请求日志，生成日志文件，将命令集合写入日志文件 public void save() { FileUtil.writeCommands(commands); } // 从日志文件中提取命令集合，并循环调用每一个命令对象的execute()方法来实现配置文件的重新设置 public void recover() { ArrayList list; list = FileUtil.readCommands(); for (Object obj : list) { ((Command)obj).execute(); } } } // 工具类：文件操作类 // 负责将命令集合序列化写入日志文件及从日志文件中读取命令集合 class FileUtil { // 将命令集合写入日志文件 public static void writeCommands(ArrayList commands) { try { FileOutputStream file = new FileOutputStream(\u0026#34;config.log\u0026#34;); // 创建对象输出流用于将对象写入到文件中 ObjectOutputStream objout = new ObjectOutputStream(new BufferedOutputStream(file)); // 将对象写入文件 objout.writeObject(commands); objout.close(); } catch (Exception e) { System.out.println(\u0026#34;命令保存失败！\u0026#34;); e.printStackTrace(); } } // 从日志文件中提取命令集合 public static ArrayList readCommands() { try { FileInputStream file = new FileInputStream(\u0026#34;config.log\u0026#34;); // 创建对象输入流用于从文件中读取对象 ObjectInputStream objin = new ObjectInputStream(new BufferedInputStream(file)); // 将文件中的对象读出并转换为ArrayList类型 ArrayList commands = (ArrayList)objin.readObject(); objin.close(); return commands; } catch (Exception e) { System.out.println(\u0026#34;命令读取失败！\u0026#34;); e.printStackTrace(); return null; } } } 撤销操作： # // 抽象命令类：定义命令的接口，包含执行和撤销操作。 abstract class AbstractCommand { // 执行操作，传入参数并返回执行结果 public abstract int execute(int value); // 撤销操作，返回撤销后的结果 public abstract int undo(); } // 具体命令类：实现了抽象命令类，负责调用接收者（Adder）的具体操作。该类封装了对加法操作的请求并实现了撤销功能。 class ConcreteCommand extends AbstractCommand { private Adder adder = new Adder(); // 接收者（实际执行加法操作的类） // 存储上一次操作的值，用于撤销 private int value; // 执行加法操作，并存储当前操作的值 public int execute(int value) { this.value = value; return adder.add(value); } // 撤销上一次加法操作，通过加上一个相反的值 public int undo() { return adder.add(-value); } } // 调用者类：表示计算器窗口，通过命令对象来执行和撤销操作。 // 该类负责管理命令对象，并通过命令对象执行或撤销操作。 class CalculatorForm { private AbstractCommand command; // 设置具体的命令对象 public void setCommand(AbstractCommand command) { this.command = command; } public void compute(int value) { // 执行运算操作，并输出运算结果 int result = command.execute(value); System.out.println(\u0026#34;执行运算，运算结果为：\u0026#34; + result); } public void undo() { // 撤销上一次运算操作，并输出撤销后的结果 int result = command.undo(); System.out.println(\u0026#34;执行撤销，运算结果为：\u0026#34; + result); } } // 接收者类：实际执行加法操作的类。 class Adder { private int num = 0; // 记录当前的累计值 // 执行加法操作，并返回加法后的结果 public int add(int value) { num += value; return num; } } // 客户端类：负责创建命令对象和调用者，并触发操作。 class Client { public static void main(String args[]) { // 创建调用者（计算器窗口） CalculatorForm form = new CalculatorForm(); // 创建具体命令对象（加法命令） ConcreteCommand command = new ConcreteCommand(); // 将命令对象设置到调用者 form.setCommand(command); form.compute(10); // 输出：执行运算，运算结果为：10 form.undo(); // 输出：执行撤销，运算结果为：15 } } 宏命令： # 递归调用它所包含的每个成员命令的execute()方法。执行一个宏命令将触发多个具体命令的执行，从而实现对命令的批处理。\n优点缺点 # 模式优点\n更松散的耦合：命令模式将请求的发送者与接收者完全解耦，发送者只需要调用命令，而不需要知道具体的接收者是谁。相同的请求者可以使用不同的接收者，相同的接收者也可以为不同的请求者服务。 更动态的控制：命令模式可以将请求封装为对象，并动态进行参数化、队列化和日志化操作，使系统更加灵活。请求可以在不修改调用者的情况下被延迟执行或加入队列。 更容易的组合命令：命令模式允许你轻松实现命令队列或宏命令（组合多个命令的命令），使得系统可以执行复杂的操作序列。 更好的扩展性：命令模式符合“开闭原则”，可以轻松添加新的命令对象而无需修改现有代码。 模式缺点\n类的膨胀：命令模式可能会引入大量的具体命令类，每个操作对应一个具体的命令类，在一些复杂系统中可能导致类的数量急剧增加。 增大系统开销：由于命令对象的引入，系统需要为每个请求生成额外的命令对象，可能会导致一定的内存开销和处理开销，特别是当命令数量较多时。 请求排队的复杂性：如果命令模式与请求队列等复杂处理机制结合，可能会增加系统的复杂性，尤其是在管理命令的执行顺序和撤销操作时。 适用环境\n需要抽象出执行的动作：当需要将执行的动作抽象出来，并且将其参数化时，命令模式能够很好地将这些动作封装成命令对象，然后实现参数化配置。 需要在不同时间指定、排列和执行请求：如果系统要求在不同时间点指定请求并按照一定的顺序执行，命令模式可以将请求封装为命令对象，并通过队列或日志机制来管理它们的执行顺序。 需要支持撤销和重做操作：命令模式可以方便地实现撤销（Undo）和重做（Redo）操作。通过管理已执行的命令对象，可以支持对操作进行回滚或重做。 系统崩溃后的操作恢复：如果系统崩溃后需要恢复之前的操作，命令模式可以将操作请求封装成命令对象，并结合日志来记录命令列表，在系统恢复时重新执行这些命令。 事务性系统：在事务性系统中，命令模式能够将事务的操作封装为命令对象，正向遍历执行事务操作，出现异常时反向遍历进行回滚操作，实现事务管理。 迭代器模式 # 迭代器模式的本质：控制访问聚合对象中的元素。\n下图中使用内部类来实现上面 Concretelterator 关联 ConcreteAggregate\n而 createlterator 函数体现了依赖关系\n// 迭代器接口：定义用于遍历电视机频道的方法 public interface TVIterator { void setChannel(int i); // 设置当前频道 void next(); // 移动到下一个频道 void previous(); // 移动到上一个频道 boolean isLast(); // 判断是否为最后一个频道 Object currentChannel(); // 获取当前频道 boolean isFirst(); // 判断是否为第一个频道 } // 电视接口：提供创建迭代器的工厂方法 // 这是工厂方法模式的一部分，具体的电视机类将实现该接口，提供相应的迭代器 public interface Television { TVIterator createIterator(); } // TCL电视机类：实现Television接口并提供具体的频道及迭代器实现 public class TCLTelevision implements Television { private Object[] obj = { \u0026#34;湖南卫视\u0026#34;, \u0026#34;北京卫视\u0026#34;, \u0026#34;上海卫视\u0026#34;, \u0026#34;湖北卫视\u0026#34;, \u0026#34;黑龙江卫视\u0026#34; }; // 创建并返回具体的迭代器对象 public TVIterator createIterator() { return new TCLIterator(); } // TCL电视的迭代器实现：实现TVIterator接口，能够遍历TCL电视机的频道 class TCLIterator implements TVIterator { private int currentIndex = 0; // 移动到下一个频道 public void next() { if (currentIndex \u0026lt; obj.length) { currentIndex++; } } public void previous() { ... } } } // Skyworth电视机类：实现Television接口并提供具体的频道及迭代器实现 public class SkyworthTelevision implements Television { private Object[] obj = { \u0026#34;CCTV-1\u0026#34;, \u0026#34;CCTV-2\u0026#34;, \u0026#34;CCTV-3\u0026#34;, \u0026#34;CCTV-4\u0026#34;, \u0026#34;CCTV-5\u0026#34;, \u0026#34;CCTV-6\u0026#34;, \u0026#34;CCTV-7\u0026#34;, \u0026#34;CCTV-8\u0026#34; }; // 创建并返回具体的迭代器对象 public TVIterator createIterator() { return new SkyworthIterator(); } // Skyworth电视的迭代器实现：实现TVIterator接口，能够遍历Skyworth电视机的频道 private class SkyworthIterator implements TVIterator { private int currentIndex = 0; ... } } // 客户端类：模拟电视机操作，通过遍历器显示频道 public class Client // 正向遍历并显示所有频道 public static void display(Television tv) { TVIterator i = tv.createIterator(); System.out.println(\u0026#34;电视机频道：\u0026#34;); while (!i.isLast()) { System.out.println(i.currentChannel().toString()); i.next(); } } // 逆向遍历并显示频道 public static void reverseDisplay(Television tv) { TVIterator i = tv.createIterator(); i.setChannel(5); // 设置当前频道为第5个 System.out.println(\u0026#34;逆向遍历电视机频道：\u0026#34;); while (!i.isFirst()) { i.previous(); System.out.println(i.currentChannel().toString()); } } // 主程序入口，模拟从XML文件中获取具体的电视机对象并进行频道遍历 public static void main(String a[]) { Television tv; tv = (Television) XMLUtil.getBean(); // 动态获取具体的电视机对象 display(tv); System.out.println(\u0026#34;--------------------------\u0026#34;); reverseDisplay(tv); } } 模式扩展 # 内部迭代器和外部迭代器\n内部迭代器指的是由迭代器自己来控制迭代下一个元素的步骤，客户端无法干预，因此，如果想要在迭代的过程中完成工作的话，客户端就需要把操作传给迭代器，迭代器在迭代的时候会在每个元素上执行这个操作。\n外部迭代器指的是由客户端来控制迭代下一个元素的步骤，像前面的示例一样，客户端必须显示的调用next来迭代下一个元素。常见的实现多属于外部迭代器。\n带迭代策略的迭代器:\n实现的一个基本思路，就是先把聚合对象的聚合数据获取到，并存储到迭代器里面来，这样迭代器就可以按照不同的策略来迭代数据了。 双向迭代器: 可以同时向前或向后\n优点缺点： # 优点：\n支持多种遍历方式：通过替换不同的迭代器，可以在同一个聚合对象上使用不同的遍历算法。。 简化聚合类设计：迭代器模式将遍历逻辑从聚合类中分离，使得聚合类不再负责数据的遍历，简化了聚合类的设计。 符合开闭原则：引入抽象层后，新增聚合类和迭代器类时无需修改原有代码。 缺点：\n类的数量增加：由于职责分离，每增加一个新的聚合类通常需要对应增加一个迭代器类，导致类的数量成对增加，增加了系统的复杂性。 抽象迭代器设计难度高：设计一个通用的抽象迭代器并不容易，必须充分考虑未来的扩展需求，且这些子类不能用于所有类型的聚合结构。 适用环境：\n无须暴露内部结构：当需要访问聚合对象的内容，但不希望暴露其内部表示时，可以使用迭代器模式。 支持多种遍历方式：当需要为聚合对象提供多种遍历方式。 统一接口：为不同的聚合结构提供统一的遍历接口，客户端可以通过一致的方式操作不同的聚合结构。 中介者模式 # 中介者模式的本质：封装交互。\n// 中介者模式：抽象中介者 public abstract class AbstractChatroom { public abstract void register(Member member); // 注册成员 public abstract void sendText(String from, String to, String message); // 发送文本 public abstract void sendImage(String from, String to, String image); // 发送图片 } // 具体中介者：处理成员之间的消息传递 import java.util.*; public class ChatGroup extends AbstractChatroom { private Hashtable\u0026lt;String, Member\u0026gt; members = new Hashtable\u0026lt;\u0026gt;(); // 用哈希表存储对象 public void register(Member member) { // 注册成员，将成员加入聊天室 if (!members.contains(member)) { members.put(member.getName(), member); member.setChatroom(this); // 设置成员所属的聊天室 } } // 发送文本信息，并进行敏感词过滤 public void sendText(String from, String to, String message) { Member member = members.get(to); String newMessage = message.replaceAll(\u0026#34;C\u0026#34;, \u0026#34;*\u0026#34;); // 替换敏感词 member.receiveText(from, newMessage); // 接收文本 } // 发送图片，如果图片内容过长则发送失败 public void sendImage(String from, String to, String image) { Member member = members.get(to); if (image.length() \u0026gt; 5) { System.out.println(\u0026#34;图片太大，发送失败！\u0026#34;); } else { member.receiveImage(from, image); // 接收图片 } } } // 抽象同事类：成员基类 public abstract class Member { protected AbstractChatroom chatroom; // 中介者引用，用 protected protected String name; public Member(String name) { this.name = name; } ...// 经典 get 和 set public abstract void sendText(String to, String message); public abstract void sendImage(String to, String image); // 接收文本信息 public void receiveText(String from, String message) { System.out.println(from + \u0026#34;发送文本给\u0026#34; + this.name + \u0026#34;，内容为：\u0026#34; + message); } // 接收图片信息 public void receiveImage(String from, String image) { System.out.println(from + \u0026#34;发送图片给\u0026#34; + this.name + \u0026#34;，内容为：\u0026#34; + image); } } // 具体同事类：钻石会员 public class DiamondMember extends Member { public DiamondMember(String name) { super(name); } // 钻石会员可以发送文本 public void sendText(String to, String message) { System.out.println(\u0026#34;钻石会员发送信息：\u0026#34;); chatroom.sendText(name, to, message); // 通过中介者发送 } // 钻石会员可以发送图片 public void sendImage(String to, String image) { System.out.println(\u0026#34;钻石会员发送图片：\u0026#34;); chatroom.sendImage(name, to, image); // 通过中介者发送 } } // 具体同事类：普通会员 public class CommonMember extends Member { ... } // 客户端：模拟聊天室中的操作 public class Client { public static void main(String[] args) { // 创建具体中介者（聊天室） AbstractChatroom happyChat = new ChatGroup(); Member member1 = new DiamondMember(\u0026#34;张三\u0026#34;); // 创建多个会员（同事） Member member2 = new DiamondMember(\u0026#34;李四\u0026#34;); happyChat.register(member1); // 将会员注册到聊天室 happyChat.register(member2); // 模拟会员之间的消息传递 member1.sendText(\u0026#34;李四\u0026#34;, \u0026#34;李四，你好！\u0026#34;); member2.sendText(\u0026#34;张三\u0026#34;, \u0026#34;张三，你好！\u0026#34;); } } 优点缺点： # 优点：\n松散耦合：中介者模式通过将多个同事对象之间的交互逻辑封装到中介者对象中，减少了同事对象之间的直接依赖。各个同事对象可以独立变化或复用，避免了“牵一发而动全身”的问题。 集中控制交互：所有同事对象之间的交互逻辑由中介者集中管理，交互行为发生变化时，只需修改中介者对象，而无需修改同事对象，增强了系统的可扩展性和维护性。 多对多变成一对多：引入中介者后，同事对象之间的多对多关系变为中介者和同事对象之间的一对多关系，简化了对象间的关系，使系统结构更加清晰且易于理解和实现。 缺点：\n过度集中化：随着同事对象的交互复杂度增加，中介者对象可能变得非常复杂，承担过多的逻辑，导致中介者难以管理和维护，甚至出现“上帝对象”的问题。 适用环境：\n复杂的对象交互：当一组对象之间的通信方式复杂且相互依赖，导致系统难以维护时，可以采用中介者模式将交互逻辑集中管理，减少对象之间的直接依赖。 减少对象直接依赖：当一个对象需要与多个对象交互并导致耦合度过高时，可以使用中介者模式，将其与其他对象的交互封装到中介者中，降低耦合度并提高对象的复用性。 中介者模式和外观模式的区别\n备忘录模式 # 备忘录模式的本质：保存和恢复内部状态。\n// 备忘录模式：发起人类，负责创建和恢复备忘录 public class UserInfoDTO { private String account; private String password; private String telNo; ...//经典set get // 创建备忘录，保存当前状态 public Memento saveMemento() { return new Memento(account, password, telNo); } // 从备忘录中恢复状态 public void restoreMemento(Memento memento) { this.account = memento.getAccount(); this.password = memento.getPassword(); this.telNo = memento.getTelNo(); } // 显示当前状态 public void show() { System.out.println(\u0026#34;Account: \u0026#34; + this.account); System.out.println(\u0026#34;Password: \u0026#34; + this.password); System.out.println(\u0026#34;TelNo: \u0026#34; + this.telNo); } } // 备忘录模式：备忘录类，负责存储发起人的状态 class Memento { private String account; private String password; private String telNo; // 构造方法，保存状态 public Memento(String account, String password, String telNo) { this.account = account; this.password = password; this.telNo = telNo; } ...// 经典set get } // 备忘录模式：管理者类，负责保存和恢复备忘录 public class Caretaker { private Memento memento; // 获取备忘录 public Memento getMemento() { return memento; } // 保存备忘录 public void setMemento(Memento memento) { this.memento = memento; } } public class Client { public static void main(String[] args) { // 创建发起人（UserInfoDTO）和管理者（Caretaker） UserInfoDTO user = new UserInfoDTO(); Caretaker caretaker = new Caretaker(); // 设置初始状态 user.setAccount(\u0026#34;zhangsan\u0026#34;); user.setPassword(\u0026#34;123456\u0026#34;); user.setTelNo(\u0026#34;13000000000\u0026#34;); System.out.println(\u0026#34;状态一：\u0026#34;); user.show(); // 保存状态一到备忘录 // 把 save 里面 new 出来的 set 到caretaker 中 caretaker.setMemento(user.saveMemento()); user.setPassword(\u0026#34;111111\u0026#34;); user.setTelNo(\u0026#34;13100001111\u0026#34;); System.out.println(\u0026#34;状态二：\u0026#34;); user.show(); // 从备忘录中恢复到状态一 user.restoreMemento(caretaker.getMemento()); System.out.println(\u0026#34;回到状态一：\u0026#34;); user.show(); } } 优点缺点 # 优点：\n提供状态恢复机制：备忘录模式允许用户在状态无效或出错时，方便地回到某个特定的历史步骤，恢复之前的状态。 封装状态信息：备忘录对象对外部封装了原发器的状态，其他代码无法直接修改备忘录中的数据，从而保护了原发器的状态不被外界破坏。 支持多次撤销：通过使用列表、堆栈等集合来存储多个备忘录对象，可以实现多次的撤销操作，允许用户恢复到更早的状态。 缺点：\n资源消耗较大：如果原发器类的成员变量过多，每次保存状态都会占用大量的存储空间和系统资源，尤其是在需要频繁保存状态的情况下，资源消耗问题会更加突出。 适用环境：\n需要保存并恢复对象状态时：当需要保存对象的全部或部分状态以便日后恢复，或者实现撤销功能时，备忘录模式是一个合适的选择。 保护对象历史状态的封装性：当不希望对象的历史状态被外界对象破坏或暴露实现细节时，可以使用备忘录模式来保证对象状态的封装性和安全性。 备忘录模式和命令模式的组合使用 # 两者都提供了撤销或回到某个节点的功能，在命令模式执行撤回或重做的命令时，使用备忘录模式。\n备忘录模式和原型模式的组合使用 # 在原发器对象创建备忘录对象的时候，如果原发器对象中全部或者大部分的状态都需要保存，一个简洁的方式就是直接用原型模式克隆一个原发器对象。\n观察者模式 # 观察者模式的本质：触发联动。\n// 观察者接口：定义了观察者的接口，所有观察者都必须实现 response() 方法 public interface MyObserver { void response(); // 抽象响应方法 } // 具体观察者类：Dog 实现了 MyObserver 接口，定义了具体的响应行为 public class Dog implements MyObserver { @Override public void response() { System.out.println(\u0026#34;狗跟着叫！\u0026#34;); } } // 具体观察者类：Mouse 实现了 MyObserver 接口，定义了具体的响应行为 public class Mouse implements MyObserver { @Override public void response() { System.out.println(\u0026#34;老鼠吓得四处逃窜！\u0026#34;); } } public abstract class MySubject { // 用于存储观察者的列表，可以有多个观察者 protected ArrayList\u0026lt;MyObserver\u0026gt; observers = new ArrayList\u0026lt;\u0026gt;(); public void attach(MyObserver observer) { // 注册观察者方法 observers.add(observer); } public void detach(MyObserver observer) { // 注销观察者方法 observers.remove(observer); } // 抽象方法，具体的子类需要实现该方法来通知所有观察者 public abstract void cry(); } // 具体主体类：Cat 继承 MySubject，并实现 cry() 方法 public class Cat extends MySubject { @Override public void cry() { System.out.println(\u0026#34;猫叫了！\u0026#34;); // 通知所有注册的观察者，在父类中 for (MyObserver observer : observers) { // 在这里控制唤醒哪些观察者 observer.response(); } } } // 客户端代码：测试观察者模式 public class Client { public static void main(String[] args) { MySubject subject = new Cat(); // 创建多个观察者对象 MyObserver obs1 = new Mouse(); MyObserver obs3 = new Dog(); subject.attach(obs1); // 注册观察者到主体 subject.attach(obs3); // 触发主体行为（猫叫），并通知所有观察者 subject.cry(); } } 学习通例题： # // 回调函数接口 interface Runnable { void run(); } // 事件触发器类 class Trigger { // 事件名称与回调函数列表的映射 private Map\u0026lt;String, List\u0026lt;Runnable\u0026gt;\u0026gt; eventMap = new HashMap\u0026lt;\u0026gt;(); // 注册事件 public void on(String eventName, Runnable callback) { if (callback != null) { eventMap.computeIfAbsent(eventName, k -\u0026gt; new ArrayList\u0026lt;\u0026gt;()).add(callback); } } // 触发事件 public void raiseEvent(String eventName) { System.out.println(\u0026#34;Process \u0026#34; + eventName + \u0026#34; start\u0026#34;); List\u0026lt;Runnable\u0026gt; callbacks = eventMap.get(eventName); if (callbacks != null) { for (Runnable callback : callbacks) { callback.run(); // 执行回调 } } System.out.println(\u0026#34;Process \u0026#34; + eventName + \u0026#34; end\u0026#34;); } } // 示例回调函数 class Func01 implements Runnable { public void run() { System.out.println(\u0026#34;func01()\u0026#34;); } } class Func02 implements Runnable { public void run() { System.out.println(\u0026#34;func02()\u0026#34;); } } class Func03 implements Runnable { public void run() { System.out.println(\u0026#34;func03()\u0026#34;); } } // 测试代码 public class Main { public static void main(String[] args) { // 创建事件触发器 Trigger trigger = new Trigger(); // 注册事件 trigger.on(\u0026#34;event01\u0026#34;, new Func01()); trigger.on(\u0026#34;event01\u0026#34;, new Func02()); trigger.on(\u0026#34;event02\u0026#34;, new Func02()); trigger.on(\u0026#34;event03\u0026#34;, new Func03()); // 触发事件 trigger.raiseEvent(\u0026#34;event01\u0026#34;); trigger.raiseEvent(\u0026#34;event02\u0026#34;); trigger.raiseEvent(\u0026#34;event03\u0026#34;); trigger.raiseEvent(\u0026#34;event01\u0026#34;); // 再次触发 event01 trigger.raiseEvent(\u0026#34;event02\u0026#34;); // 再次触发 event02 } } 优点缺点： # 优点：\n解耦目标与观察者：目标对象只依赖于抽象的观察者接口，不需要知道具体的观察者类，降低了耦合度。 动态联动：通过动态注册和管理观察者，允许在运行时控制通知范围，实现灵活的联动效果。 支持广播通信：目标对象可向所有注册的观察者广播通知，适应一对多的通信需求，同时也可扩展限制广播的范围。 符合开闭原则：增加新的观察者无需修改现有代码，系统扩展性强。 缺点：\n性能问题：每次通知都会广播给所有观察者，可能导致性能浪费。应及时注销不需要的观察者。 避免死循环：若两个对象互为观察者和目标，可能产生相互通知的死循环，需要特别注意设计。 适用环境：\n对象间存在依赖关系：一个对象的改变需要通知其他对象，但不需知道具体有哪些对象会受到影响。 触发链场景：当需要创建链式触发机制时，使用观察者模式可以让一个对象的行为依次影响其他对象。 状态模式 # 状态模式的本质：根据状态来分离和选择行为。\n状态模式将一个对象的状态从该对象中分离出来，封装到专门的状态类中，使得对象状态可以灵活变化。\n关键是状态转移以及 state 中的 statecheck 函数\n// 抽象状态类：定义了用户行为的抽象接口 public abstract class AbstractState { protected ForumAccount acc; // 用户账户 protected int point; // 用户积分 protected String stateName; // 状态名称 // 状态检查方法，子类具体实现 public abstract void checkState(int score); // 文件下载行为，默认实现 public void downloadFile(int score) { System.out.println(acc.getName() + \u0026#34;下载文件，扣除\u0026#34; + score + \u0026#34;积分。\u0026#34;); this.point -= score; checkState(score); System.out.println(\u0026#34;剩余积分为：\u0026#34; + this.point + \u0026#34;，当前级别为：\u0026#34; + acc.getState().stateName); } ... } // 具体状态类：新手状态 public class PrimaryState extends AbstractState { public PrimaryState(AbstractState state) { this.acc = state.acc; this.point = state.getPoint(); this.stateName = \u0026#34;新手\u0026#34;; } public PrimaryState(ForumAccount acc) { this.point = 0; this.acc = acc; this.stateName = \u0026#34;新手\u0026#34;; } @Override public void downloadFile(int score) { System.out.println(\u0026#34;对不起，\u0026#34; + acc.getName() + \u0026#34;，您没有下载文件的权限！\u0026#34;); } @Override public void checkState(int score) { if (point \u0026gt;= 1000) { acc.setState(new HighState(this)); } else if (point \u0026gt;= 100) { acc.setState(new MiddleState(this)); } } } // 具体状态类：高手状态 public class MiddleState extends AbstractState { ... } // 具体状态类：专家状态 public class HighState extends AbstractState { ... } // 用户账户类：负责管理用户的状态 public class ForumAccount { private AbstractState state; private String name; public ForumAccount(String name) { // 改变状态 this.name = name; this.state = new PrimaryState(this); // ForumAccount 和 PrimaryState 相互关联 } public void setState(AbstractState state) { // 经典 set 与 get this.state = state; } public AbstractState getState() { return this.state; } public String getName() { return this.name; } public void downloadFile(int score) { state.downloadFile(score); } public void writeNote(int score) { state.writeNote(score); } public void replyNote(int score) { state.replyNote(score); } } // 客户端代码：用于测试状态模式的实现 public class Client { public static void main(String[] args) { ForumAccount account = new ForumAccount(\u0026#34;张三\u0026#34;); account.writeNote(20); account.downloadFile(20); account.replyNote(100); ... } } 实例2 # 画出状态转移图：\n实例代码（工程性质很强，不是传统模板）：\n// 抽象状态类：定义账户状态的抽象行为 abstract class AccountState { protected Account acc; // 关联的账户对象 public abstract void deposit(double amount); // 存款操作 public abstract void withdraw(double amount); // 取款操作 public abstract void computeInterest(); // 计算利息 // 最重要的：状态检查与转换 public abstract void stateCheck(); } // 正常状态：具体状态类 class NormalState extends AccountState { // 通过账户对象创建正常状态 public NormalState(Account acc) { this.acc = acc; } // 通过状态对象创建正常状态 public NormalState(AccountState state) { this.acc = state.acc; } // 存款操作并检查状态转换 public void deposit(double amount) { acc.setBalance(acc.getBalance() + amount); stateCheck(); } // 取款操作并检查状态转换 public void withdraw(double amount) { acc.setBalance(acc.getBalance() - amount); stateCheck(); } // 正常状态下无需支付利息 public void computeInterest() { System.out.println(\u0026#34;正常状态，无须支付利息！\u0026#34;); } // 状态转换逻辑 public void stateCheck() { if (acc.getBalance() \u0026gt; -2000 \u0026amp;\u0026amp; acc.getBalance() \u0026lt;= 0) { acc.setState(new OverdraftState(this)); } else if (acc.getBalance() == -2000) { acc.setState(new RestrictedState(this)); } else if (acc.getBalance() \u0026lt; -2000) { System.out.println(\u0026#34;操作受限！\u0026#34;); } } } // 透支状态：具体状态类 class OverdraftState extends AccountState { // 通过状态对象创建透支状态 public OverdraftState(AccountState state) { this.acc = state.acc; } // 存款操作并检查状态 public void deposit(double amount) { acc.setBalance(acc.getBalance() + amount); stateCheck(); } // 取款操作并检查状态 public void withdraw(double amount) { acc.setBalance(acc.getBalance() - amount); stateCheck(); } // 透支状态下计算利息 public void computeInterest() { System.out.println(\u0026#34;计算利息！\u0026#34;); } // 状态转换逻辑 public void stateCheck() { if (acc.getBalance() \u0026gt; 0) { acc.setState(new NormalState(this)); } else if (acc.getBalance() == -2000) { acc.setState(new RestrictedState(this)); } else if (acc.getBalance() \u0026lt; -2000) { System.out.println(\u0026#34;操作受限！\u0026#34;); } } } // 受限状态：具体状态类 class RestrictedState extends AccountState { // 通过状态对象创建受限状态 public RestrictedState(AccountState state) { this.acc = state.acc; } // 存款操作并检查状态 public void deposit(double amount) { acc.setBalance(acc.getBalance() + amount); stateCheck(); } // 受限状态下取款失败 public void withdraw(double amount) { System.out.println(\u0026#34;帐号受限，取款失败\u0026#34;); } // 受限状态下计算利息 public void computeInterest() { System.out.println(\u0026#34;计算利息！\u0026#34;); } // 状态转换逻辑 public void stateCheck() { if (acc.getBalance() \u0026gt; 0) { acc.setState(new NormalState(this)); } else if (acc.getBalance() \u0026gt; -2000) { acc.setState(new OverdraftState(this)); } } } // 账户类：负责管理账户的当前状态 class Account { private AccountState state; // 账户当前状态 private String owner; // 账户持有者 private double balance; // 账户余额 // 构造函数，初始化账户并设置初始状态为正常状态 public Account(String owner, double balance) { this.owner = owner; this.balance = balance; this.state = new NormalState(this); // 初始状态为正常状态 System.out.println(this.owner + \u0026#34;注册成功，初始余额为：\u0026#34; + this.balance); } // 存款操作，将操作委托给当前状态 public void deposit(double amount) { state.deposit(amount); System.out.println(\u0026#34;存款 \u0026#34; + amount + \u0026#34; 元，当前余额：\u0026#34; + this.balance); System.out.println(\u0026#34;当前账户状态：\u0026#34; + state.getClass().getSimpleName()); } // 取款操作，将操作委托给当前状态 public void withdraw(double amount) { state.withdraw(amount); System.out.println(\u0026#34;取款 \u0026#34; + amount + \u0026#34; 元，当前余额：\u0026#34; + this.balance); System.out.println(\u0026#34;当前账户状态：\u0026#34; + state.getClass().getSimpleName()); } // 计算利息，将操作委托给当前状态 public void computeInterest() { state.computeInterest(); } // 设置账户状态 public void setState(AccountState state) { this.state = state; } // 获取账户当前状态 public AccountState getState() { return this.state; } // 设置账户余额 public void setBalance(double balance) { this.balance = balance; } // 获取账户余额 public double getBalance() { return this.balance; } } // 客户端测试代码 class Client { public static void main(String args[]) { Account acc = new Account(\u0026#34;张三\u0026#34;, 0.0); // 创建账户并初始化 acc.deposit(1000); // 存款 1000 acc.withdraw(2000); // 取款 2000，进入透支状态 acc.deposit(3000); // 存款 3000，返回正常状态 acc.withdraw(4000); // 取款 4000，再次进入透支状态 acc.withdraw(1000); // 取款 1000，进入受限状态 acc.computeInterest(); // 计算利息 } } 优点缺点 # 优点\n简化逻辑控制 将状态处理封装到独立类中，分散复杂的控制逻辑，使得代码结构清晰，便于维护。 状态与行为分离 通过公共接口分离状态和行为，应用程序只需关注状态切换，而无需关心具体行为处理。 扩展性强 新增状态只需增加实现类，并在状态维护中加入转换逻辑，扩展方便。 显式状态转换 独立的状态对象使转换明确，保证状态一致性，避免内部状态不一致问题。 缺点\n类和对象增多 引入多个状态类，增加系统的复杂性和运行开销。 实现复杂 不当使用可能导致结构复杂，增加设计和维护难度。 对开闭原则支持有限 新增状态时需修改状态转换逻辑，影响开闭原则。 适用场景\n对象行为依赖其内部状态，且状态变化会引起行为变化。 代码中存在大量与状态相关的条件判断，影响代码的灵活性和可维护性。 模型扩展 # 共享状态：如果希望在系统中实现多个环境对象实例共享一个或多个状态对象，那么需要将这些状态对象定义为环境的静态成员对象。\n// 开关类：管理开关状态 class Switch { private State state; // 当前状态 private static State onState = new OnState(); // 打开状态， 静态 private static State offState = new OffState(); // 关闭状态， 静态 private String name; // 开关名称 // 构造函数，初始化为打开状态 public Switch(String name) { this.name = name; this.state = onState; // 默认状态为打开 } public void setState(State state) { this.state = state; } public void on() { // 开关打开操作 System.out.print(name); state.on(this); } public void off() { // 开关关闭操作 System.out.print(name); state.off(this); } // 根据类型获取状态 public static State getState(String type) { if (type.equalsIgnoreCase(\u0026#34;on\u0026#34;)) { return onState; } else { return offState; } } } // 抽象状态类：定义开关状态的行为接口 abstract class State { public abstract void on(Switch s); public abstract void off(Switch s); } class OnState extends State {// 打开状态类 public void on(Switch s) { System.out.println(\u0026#34;已经打开！\u0026#34;); } public void off(Switch s) { System.out.println(\u0026#34;关闭！\u0026#34;); s.setState(Switch.getState(\u0026#34;off\u0026#34;)); // 转换到关闭状态 } } class OffState extends State {// 关闭状态类 public void on(Switch s) { System.out.println(\u0026#34;打开！\u0026#34;); s.setState(Switch.getState(\u0026#34;on\u0026#34;)); // 转换到打开状态 } public void off(Switch s) { System.out.println(\u0026#34;已经关闭！\u0026#34;); } } // 客户端测试代码 class Client { public static void main(String[] args) { Switch s1 = new Switch(\u0026#34;开关1\u0026#34;); Switch s2 = new Switch(\u0026#34;开关2\u0026#34;); s1.on(); // 开关1 打开 s2.on(); // 开关2 打开 s1.off(); // 开关1 关闭 s2.off(); // 开关2 关闭 s2.on(); // 开关2 打开 s1.on(); // 开关1 已经打开 } } 简单状态模式：简单状态模式是指状态都相互独立，没有状态转化，遵循“开闭原则”。\n可切换状态的状态模式：也就是上面实例中的模式，在具体状态类内部需要调用环境类Context的setState()方法进行状态的转换操作，在具体状态类中可以调用到环境类的方法。\n状态模式和观察者模式的区别：这两个模式都是在状态发生改变的时候触发行为，只不过观察者模式的行为是固定的，那就是通知所有的观察者，而状态模式是根据状态来选择不同的处理，当状态发生改变的时候，动态改变行为。\n策略模式 # 策略模式的本质：分离算法，选择实现。\n结构上和简单状态模式非常相似，策略模式更强调策略的选择，而状态模式强调状态的多变。\n// 定义排序策略接口 public interface Sort { int[] sort(int[] arr); } // ArrayHandler 类：持有 Sort 策略对象 public class ArrayHandler { private Sort sortObj; // 设置具体的排序策略 public void setSortObj(Sort sortObj) { this.sortObj = sortObj; } // 调用策略进行排序 public int[] sort(int[] arr) { return sortObj.sort(arr); } } // 冒泡排序实现类 public class BubbleSort implements Sort { public int[] sort(int[] arr) { // 省略排序具体实现 return arr; } } // 插入排序实现类 public class InsertionSort implements Sort { public int[] sort(int[] arr) { // 省略排序具体实现 return arr; } } // Client 类：客户端代码 public class Client { public static void main(String[] args) { int[] arr = {1, 4, 6, 2, 5, 3, 7, 10, 9}; ArrayHandler arrayHandler = new ArrayHandler(); // 获取具体的排序策略对象 Sort sort = (Sort) XMLUtil.getBean(); arrayHandler.setSortObj(sort); // 设置策略 // 执行排序 int[] result = arrayHandler.sort(arr); // 输出排序结果 for (int i : result) { System.out.print(i + \u0026#34;, \u0026#34;); } } } 优点缺点 # 优点\n算法复用：将算法封装在策略类中，多个环境可复用，避免重复代码。 管理算法族：通过继承共享公共代码，简化算法管理。 减少条件语句：避免大量条件判断，将算法选择与实现分离。 替代继承：支持运行时动态切换算法，遵循单一职责原则。 符合开闭原则：便于在不修改现有代码的情况下扩展新算法。 缺点\n增加复杂度：客户端需了解所有策略并自行选择，增加系统复杂性。 类数量多：每个策略都需要独立类，类数量随策略增多而增加。 仅适用于平等算法：不适合嵌套或组合算法的复杂场景。 适用场景\n动态选择算法：系统需在多种算法间切换时。 避免复杂条件判断：通过策略模式简化多重选择语句。 隐藏算法细节：封装复杂算法，提升安全性和可维护性。 算法扩展 # 策略模式与状态模式的比较：\n模板方法模式 # 模板方法模式的本质：固定算法骨架。\n模板模式的结构非常简单，如下：\npublic abstract class BankTemplateMethod { public void takeNumber() { System.out.println(\u0026#34;取号排队。\u0026#34;); } public abstract void transact();\tpublic void evaluate() { System.out.println(\u0026#34;反馈评分。\u0026#34;); } // 模板模式的核心是改变一个过程中的一部分 public void process() { this.takeNumber(); this.transact(); this.evaluate(); } } 上面例子就是继承，下面可以看看钩子方法。让子类能够插入或跳过算法中的某些步骤。\n// 核心在下面的 isValid 中体现钩子方法，这样跳过了父类的 convertData() public abstract class HookDemo { public abstract void getData(); public void convertData() { System.out.println(\u0026#34;通用的数据转换操作。\u0026#34;); } public abstract void displayData(); public void process() { getData(); if (isValid()) { convertData(); } displayData(); } public boolean isValid() { return true; } } class SubHookDemo extends HookDemo { public void getData() { System.out.println(\u0026#34;从XML配置文件中获取数据。\u0026#34;); } public void displayData() { System.out.println(\u0026#34;以柱状图显示数据。\u0026#34;); } public boolean isValid() { return false; } } class Client { public static void main(String a[]) { HookDemo hd; hd = new SubHookDemo(); hd.process(); } } 作业多的一道题！ # import java.util.*; // 回调函数接口 interface Runnable { void run(); } // 事件触发器类 class Trigger { // 事件名称与回调函数列表的映射 private Map\u0026lt;String, List\u0026lt;Runnable\u0026gt;\u0026gt; eventMap = new HashMap\u0026lt;\u0026gt;(); // 注册事件 public void on(String eventName, Runnable callback) { if (callback != null) { eventMap.computeIfAbsent(eventName, k -\u0026gt; new ArrayList\u0026lt;\u0026gt;()).add(callback); } } // 触发事件 public void raiseEvent(String eventName) { System.out.println(\u0026#34;Process \u0026#34; + eventName + \u0026#34; start\u0026#34;); List\u0026lt;Runnable\u0026gt; callbacks = eventMap.get(eventName); if (callbacks != null) { for (Runnable callback : callbacks) { callback.run(); // 执行回调 } } System.out.println(\u0026#34;Process \u0026#34; + eventName + \u0026#34; end\u0026#34;); } } // 示例回调函数 class Func01 implements Runnable { public void run() { System.out.println(\u0026#34;func01()\u0026#34;); } } class Func02 implements Runnable { public void run() { System.out.println(\u0026#34;func02()\u0026#34;); } } class Func03 implements Runnable { public void run() { System.out.println(\u0026#34;func03()\u0026#34;); } } // 测试代码 public class Main { public static void main(String[] args) { // 创建事件触发器 Trigger trigger = new Trigger(); // 注册事件 trigger.on(\u0026#34;event01\u0026#34;, new Func01()); trigger.on(\u0026#34;event01\u0026#34;, new Func02()); trigger.on(\u0026#34;event02\u0026#34;, new Func02()); trigger.on(\u0026#34;event03\u0026#34;, new Func03()); // 触发事件 trigger.raiseEvent(\u0026#34;event01\u0026#34;); trigger.raiseEvent(\u0026#34;event02\u0026#34;); trigger.raiseEvent(\u0026#34;event03\u0026#34;); trigger.raiseEvent(\u0026#34;event01\u0026#34;); // 再次触发 event01 trigger.raiseEvent(\u0026#34;event02\u0026#34;); // 再次触发 event02 } } Java 语法： # 1. 深拷贝与浅拷贝 # 浅拷贝 # 浅拷贝是指创建一个新对象，但其中的字段（特别是引用类型的字段）仍然指向原始对象中相同的引用。\n特点\n基本类型的字段会被复制。 引用类型的字段不会被复制，只是复制引用，两个对象共享同一个引用类型的实例。 实现方式\n实现 Cloneable 接口并重写 clone() 方法。 使用 super.clone() 来进行浅拷贝。 class Person implements Cloneable { String name; int age; public Person(String name, int age) { this.name = name; this.age = age; } // 浅拷贝 @Override protected Object clone() throws CloneNotSupportedException { return super.clone(); // 这是浅拷贝 } } public class Main { public static void main(String[] args) throws CloneNotSupportedException { Person p1 = new Person(\u0026#34;Alice\u0026#34;, 25); Person p2 = (Person) p1.clone(); // 浅拷贝 System.out.println(p1.name == p2.name); // true，引用相同 } } 深拷贝 # 深拷贝是指创建一个新对象，并且递归地复制所有字段，包括引用类型字段所引用的对象，使得新对象与原对象完全独立。\n实现方式： 手动克隆每一个引用类型的字段。 使用序列化进行深拷贝（通过将对象序列化再反序列化来实现深拷贝）。 class Address { String city; public Address(String city) { this.city = city; } } class Person implements Cloneable { String name; int age; Address address; public Person(String name, int age, Address address) { this.name = name; this.age = age; this.address = address; } // 深拷贝 @Override protected Object clone() throws CloneNotSupportedException { Person cloned = (Person) super.clone(); cloned.address = new Address(this.address.city); // 深拷贝，创建新的Address return cloned; } } public class Main { public static void main(String[] args) throws CloneNotSupportedException { Address address = new Address(\u0026#34;New York\u0026#34;); Person p1 = new Person(\u0026#34;Alice\u0026#34;, 25, address); Person p2 = (Person) p1.clone(); // 深拷贝 System.out.println(p1.address.city == p2.address.city); // false，引用不同 } } 2. 列表（List） # 列表（List） 是 Java 中常用的数据结构之一，用于存储有序的元素集合。List 接口有多个实现类，如 ArrayList 和 LinkedList。\nArrayList # 基于动态数组实现，支持快速的随机访问。 插入和删除操作代价较高，尤其是在列表中间进行操作时，因为需要移动元素。 import java.util.ArrayList; import java.util.List; public class Main { public static void main(String[] args) { // 创建一个ArrayList List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); // 添加元素 list.add(\u0026#34;Alice\u0026#34;); list.add(\u0026#34;Bob\u0026#34;); list.add(\u0026#34;Charlie\u0026#34;); // 获取元素 System.out.println(list.get(1)); // 输出：Bob // 删除元素 list.remove(0); // 遍历列表 for (String name : list) { System.out.println(name); } } } 3. 哈希表（HashMap） # 哈希表（HashMap） 是 Java 中用于存储键值对的常用数据结构之一。它基于哈希函数实现，能够在常数时间内完成插入、删除和查找操作。\nHashMap 的常用操作 # import java.util.HashMap; import java.util.Map; public class Main { public static void main(String[] args) { // 创建一个HashMap Map\u0026lt;String, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); // 添加键值对 map.put(\u0026#34;Alice\u0026#34;, 25); map.put(\u0026#34;Bob\u0026#34;, 30); map.put(\u0026#34;Charlie\u0026#34;, 35); // 获取值 System.out.println(map.get(\u0026#34;Alice\u0026#34;)); // 输出：25 // 删除键值对 map.remove(\u0026#34;Bob\u0026#34;); // 遍历HashMap for (Map.Entry\u0026lt;String, Integer\u0026gt; entry : map.entrySet()) { System.out.println(entry.getKey() + \u0026#34;: \u0026#34; + entry.getValue()); } } } 4. 关键字： # abstract：用于声明抽象类或抽象方法，不能直接实例化。\nabstract class Animal { public abstract void sound(); } interface：用于声明接口，类通过 implements 实现接口中的方法。\ninterface Animal { void sound(); } extends：用于声明类的继承关系，子类继承父类的属性和方法。\nclass Dog extends Animal { void sound() { System.out.println(\u0026#34;Bark\u0026#34;); } } implements：用于声明类实现接口，一个类可以实现一个或多个接口。\nclass Dog implements Animal { public void sound() { System.out.println(\u0026#34;Bark\u0026#34;); } } public、protected、private：用于声明类、方法或变量的访问权限。\npublic class Animal { protected String name; private void sound() { } } static：用于声明类变量或类方法，不依赖对象实例访问。\npublic static int count = 0; // 静态变量 final：用于声明常量、不可继承的类、不可重写的方法。\npublic final class Constants { public static final double PI = 3.14; } super：用于引用父类的构造方法或方法。\nclass Dog extends Animal { Dog() { super.sound(); } } this：用于引用当前对象，通常用于区分类的成员变量与局部变量。\nclass Animal { private String name; Animal(String name) { this.name = name; } } Serializable：原型模式深拷贝，序列化基类。\npublic class Attachment implements Serializable Cloneable：原型模式浅拷贝，可以克隆基类。\npublic class Email implements Cloneable 5. 输入输出 # // 创建 Scanner 对象，用于从控制台读取输入 Scanner scanner = new Scanner(System.in); // 读取字符串 System.out.print(\u0026#34;Enter your name: \u0026#34;); String name = scanner.nextLine(); 简答题总结 # 2018 # 为什么优先使用对象组合而不是类继承 因为继承会使类之间高度耦合，组合确实比继承更加灵活，也更有助于代码维护。\n请举例说明你对创建型设计模式的理解 创建型模式分为5种：简单工厂模式、工厂模式、抽象工厂模式、原型模式、单例模式。它重点在于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。\n请举例说明哪些情况下可以使用组合模式 宏命令，MVC中的View图，文件夹的管理\n抽象工厂模式和原型模式有哪些相同和不同，可以联合使用吗？ 抽象工厂模式：通常由工厂方法模式来实现。但一个工厂中往往含有多个工厂方法生成一系列的产品。这个模式强调的是客户代码一次保证只使用一个系列的产品。当要切换为另一个系列的产品，换一个工厂类即可。 原型模式：工厂方法的最大缺点就是，对应一个继承体系的产品类，要有一个同样复杂的工厂类的继承体系。原型模式中的工厂方法为clone，它会返回一个拷贝（可以是浅拷贝，也可以是深拷贝，由设计者决定）。为了保证用户代码中到时可以通过指针调用clone来动态绑定地生成所需的具体的类。这些原型对象必须事先构造好。 原型模式相对工厂方法模式的另一个好处是，拷贝的效率一般对构造的效率要高。 二者可以联合成为原型工厂模式\n请给出一个适合使用策略模式的示例场景，并说明与不使用策略模式相比，使用策略模式有哪些优点 超市的各种折扣策略。 策略模式满足“开闭原则”，超市可以在不修改原有系统的基础上选择算法和行为，对现有优惠策略的变更非常方便。策略模式可以避免使用多重条件转移语句\n2017 # 请举例说明你对白箱复用和黑箱复用的理解 继承就是白箱复用，对于父类的封装性不好；组合时黑箱复用，调用者并不清楚依赖对象的实现细节。\nGOF设计模式有几种类型，分别包括那些模式 23种，分别是创建型模式（5种）、结构型模式（7种）、行为型模式（11种）\n请举例说明桥接模式如何将抽象部分与它的实现部分分离，使它们可以独立地变化 假如你有一个几何形状Shape类，从它能扩展出两个子类： 圆形Circle和 方形Square 。 你希望对这样的类层次结构进行扩展以使其包含颜色，所以你打算创建名为红色Red和蓝色Blue的形状子类。 如图所示的桥接模式uml图实现了在颜色和形状两个维度上的划分：\n简述组合模式和装饰模式的基本思路，并说明两者有何异同 组合模式是组合多个对象形成树形结构以表示’整体-部分’的关系层次，组合模式对单个对象和组合对象的使用具有一致性。 装饰模式则强调能给一个对象增加一些额外的职责和功能。 二者都属于结构型模式，意在将类或者对象结合在一起形成更大的结构。 组合模式相较于装饰模式，实现对象往往含有树形结构，并且引入了抽象容器构建类使得客户端能以一致的方式处理树形结构中的叶子节点和容器节点。\n2016 # 简述什么是硬编码，并说明硬编码有什么缺点？ 硬编码是将数据直接嵌入到程序或其他可执行对象的源代码中的软件开发实践。其特点有： ①硬编码数据通常只能通过编辑源代码和重新编译可执行文件来修改 ②硬编码的数据通常表示不变的信息，例如物理常量，版本号和静态文本元素。\n简述类适配器模式和对象适配器模式的基本思想，并说明两者有和异同 二者的基本思想都是：将一个类的接口变成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。 不同在于对象适配器——将Adapter类作修改，不是继承Adaptee类，而是持有Adaptee的实例，以解决兼容性的问题。对象适配器更符合“合成复用原则”（系统中尽量使用关联关系来替代继承关系）。\n简述工厂方法模式和抽象工厂模式的基本思想，并说明两者有何异同 工厂模式：定义一个用于创建对象的借口，让子类决定实例化哪一个类。 抽象工厂模式：为创建一组相关或相互依赖的对象提供一个接口，而且无需指定他们的具体类。 基本思想都是将对象的创建与使用分离。 区别在于：产品是否单一，如果产品单一，最合适用工厂模式，但是如果有多个业务品种、业务分类时，通过抽象工厂模式产生需要的对象是一种非常好的解决方式。再通俗深化理解下：工厂模式针对的是一个产品等级结构 ，抽象工厂模式针对的是面向多个产品等级结构的。\n简述状态模式和策略模式的基本思想，并说明两者有何异同？ 策略模式定义了算法族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。 状态模式允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。 状态模式策略模式很相似，都将类的\u0026quot;状态\u0026quot;封装了起来，在执行动作时进行自动的转换，从而实现，类在不同状态下的同一动作显示出不同结果。 但状态模式与策略模式的区别在于，这种转换是\u0026quot;自动\u0026quot;，\u0026ldquo;无意识\u0026quot;的。\n现在大多数软件都有撤销和重做的功能，请问这种功能一般是草用什么设计模式实现的，并举例说明是如何实现的。 主要使用的是命令模式 。\n2015 # 面向对象软件设计中，给一个类或对象增加行为（新功能）的方式有哪些？请举例说明 继承机制：使用继承机制是给现有类添加功能的一种有效途径，通过继承一个现有类可以使得子类在拥有自身方法的同时还拥有父类的方法，但是这种方法是静态的，用户不能控制增加行为的方式和时机。\n关联机制：将一个类的对象嵌入另一个对象中，由另一个对象来调用嵌入对象的行为同时扩展其行为，我们称另一个对象为装饰器。\n装饰模式：装饰者模式允许动态地为对象增加新的功能，而无需修改现有类的代码。这种模式通过将对象封装到另一个对象中来实现扩展。\n简述外观模式和中介者模式的基本思想，并说明两者有何异同？ 外观模式：为子系统的一组接口提供一个统一的入口。 中介者模式：用一个中介对象来封装一系列的对象交互，使原有个对象之间不需要显示地相互引用，从而使其耦合松散。 外观模式封装的是子系统外部和子系统内部模块间的交互；而中介者模式是提供多个平等的同事对象之间交互关系的封装，一般是用在内部实现上。也就是说外观模式是外部到系统内部的单向的交互，中介者模式是内部多个模块的多向的交互。\n请给出一个适合使用状态模式的示例场景，并说明与不适用状态模式相比，有哪些优点？ 在标准大气压条件下，水在温度低于0℃为固态，0~100℃为液态，大于100℃为气态。 用状态模式的优点： ①封装了状态的转换规则，可以对相应代码进行集中管理 ②将与状态相关的行为放在一个类，只需要注入不同状态即可让环境对象拥有不同的行为 ③状态模式避免了使用庞大的条件语句与转换代码\n你认为设计模式能否增强软件复用性？请列举两个模式并结合实例进行说明。 能。1. 工厂模式（Factory Pattern）\n工厂模式将对象的创建逻辑集中在工厂类中，客户端只需通过工厂获取对象，而无需直接实例化。这样，创建逻辑可以复用，且扩展时只需修改工厂类，不影响客户端代码。\n示例：\nclass ShapeFactory: def create_shape(self, shape_type): if shape_type == \u0026#34;circle\u0026#34;: return Circle() if shape_type == \u0026#34;rectangle\u0026#34;: return Rectangle() 通过工厂模式，不同的客户端都可以复用同一工厂创建对象，扩展时无需修改客户端代码。\n策略模式（Strategy Pattern）\n策略模式将算法封装在独立的类中，允许在运行时动态替换算法。不同的策略可被不同客户端复用，同时新策略添加时无需修改现有代码。\n示例：\nclass ShoppingCart: def __init__(self, strategy): self.strategy = strategy def checkout(self, amount): self.strategy.pay(amount) 策略模式使得不同的支付方式可灵活替换和复用，扩展性强。\n这两种模式均通过解耦和模块化设计提高了代码的维护性和复用性。\n2014.2 # 在面向对象设计时，采用水平关联（含依赖、组合、聚合、普通关联等）的方法或者继承都可以适应变化。请说明两种方式在适应变化上各自的优缺点。 组合关系—— 优点①不破环封装性，类之间松耦合，彼此相对独立 ②具有较好的可扩展性 ③在运行时，整体对象可以选择不同类型的局部对象 ④整体可以对局部进行包装，封装局部类的接口提供新的接口 缺点①整体类不能自动获得和局部类同样的接口 ②创建整体类的对象时需要创建所有局部类的对象\n继承关系—— 优点①子类能自动继承父类的接口 ②子类对象创建时，无需创建父类对象 缺点①破坏封装性，父类子类之间紧耦合，子类依赖父类实现，缺乏独立性 ②支持扩展，但往往以增加系统结构为代价 ③不支持动态继承，在运行时子类无法选择不同的父类 ④子类不能改变父类的接口\n变化整体上分为接口变化和实现变化。若这两类变化同时存在，通常应首先采用那种设计模式分离稳定与变化部分？举例说明如何设计。 工厂方法、桥接模式、策略模式都可以。 所谓的变化部分我们可以理解为接口或者类的扩展，而呈现给客户的只是一个统一的接口，用户不必关心内部如何实现，只要每次调用同一个方法，只传不同即可，而针对接口的变化，采用以上结合适配器模式即可转换关键代码部分。\n请举例说明什么是简单工厂方法？什么是单件（单例）模式？分别是如何实现的？ 简单工厂模式可以根据参数的不同返回不同类的实例。 单例模式是确保莫一个类只有一个实例，并且能自行实例化并向这个系统提供这个实例。\n线性聚集关系是一种现实中常见的逻辑关系，如一个A聚集多个B，一个B聚集多个C，…….。使用合成模式可以统一的接口访问各个部分。请给出本例应用合成模式的设计类图。子类聚集父类时该模式的特点之一，请再说出也具有该特点的其它几个模式的名称。 装饰模式、观察者模式\n为达到某些设计目的，设计时可以同时组合使用多个设计模式。请举出一个同时组合使用策略模式和对象适配器模式。要求给出例子的应用场景，设计方案。 应用场景：User中提供给用户的接口是一个普通的按钮，通过点击按钮实现排序算法，该排序算法可能在不同的时间发生改变（用户可以实现其他算法，按钮也可能变成倒计时等形式触发算法行为）。\n2014.3 # 软件公司要开发一个图形界面组件库，界面组件分为两大类，一类是单元控件（例如：按钮、文本框等），一类是容器控件，例如对话框、表单等，请问采用何种模式设计比较好？请画出UML设计类图 组合模式，\n化妆品公司的报表系统可将不同月份的销售数据以柱状图、曲线图和饼状图等多种形式展示出来。各个月份的销售数据可以从文本文件中获取，也可以从数据库中获取，还可以从Excel文件中获取，如果需要从Excel文件中获取数据，则需要调用与Excel相关的API，而这个API是现有系统所不具备的，该API由厂商提供。请问采用何种模式设计比较好？请画出UML设计类图。 桥接模式+适配器模式\n你认为面向对象方法中类设计的难点是什么，如何应对？ 难点：设计可复用的类要求必须找到相关的对象，以适当的粒度归类，在定义类的接口和继承层次，建立对象间的基本关系。你的设计应该对手头的问题有针对性，同时对将来的问题和需求也要有足够的通用性。你也希望避免重复设计或尽可能少做重复设计。 应对方法：学习设计模式，用更加简单方便的设计和体系结构。\n请阐述你对开闭原则的理解，以及如何设计能达到开闭原则的要求？ 理解：软件实体（模块、类、方法）应对扩展开放，对修改关闭，可以让软件系统复用，并易于维护。 设计方法： ①对软件系统中不变的部分加以抽象成不变的接口，以应对未来的扩展。 ②接口最小功能设计原则：原有的接口要么可以应对未来的扩展，不足的部分可以通过定义新的接口来实现。 ③模块之间的调用通过抽象接口进行，这样即使实现层发生变化，也无需修改调用方的代码。 综上，软件系统是否具有良好的接口（抽象）设计是判断软件系统是否满足开闭原则的一种重要的判断基准。\n请举例说明在应用标准外观模式时可能产生的问题，以及对应的解决方案。 存在的问题是：可能通过继承一个外观类在子系统中加入了新的行为。\n银行信用卡中心的电子账单系统包括了发送器、账单、广告信和发送队列等对象，其中广告信的业务逻辑是：先到数据库中把客户信息一个一个的取出，每个客户都生成一份个性化的邮件，然后交给发送机进行发送处理。请问使用哪种模式设计广告信较好？如何设计？ 每个客户都要发送一个个性化邮件，所以使用原型模式\n开发一个用于数值计算的大型程序库，他的功能是强大的，但需要使用者具备较高的数学专业知识。为方便菜鸟级用户的使用，需要提供一个简化版的，但同时又不希望影响专业人员的使用。使用那种设计模式较好？如何设计？ 外观模式\n在2D游戏的开发中，需要绘制地图，地图由大量的“一样的图块”拼接而成，而“图块”的种类有限，目前有草地、海洋、沙漠、山地等，未来肯定要增加种类，但不会太多太频繁。采用何种模式设计“图块”类比较好？如何设计？ 人物构成要素复杂，应该用建造者模式，地图块只有有限的几种，一整个地图上大面积重复，应该用享元\n其他 # 当一个系统要由多个产品系列中的一个来配置时，我们选择抽象工厂模式\n当创建复杂对象的算法应该独立于该对象的组成部分以及他们的装配方式时，我们选择建造者模式\n当一个类希望由它的子类来指定它所创建的对象的时候，我们选择工厂模式\n当一个系统应该独立于它的产品创建、构成和表示时，要使用抽象工厂模式\n当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时，要使用单例模式\n当你想使用一个已经存在的类，而他的接口不符合你的需求时，要使用适配器模式\n当你想表示对象的部分-整体层次结构，要使用组合模式\n当不能采用生成子类的方法进行扩充时，要使用装饰模式\n当你要为一个复杂子系统提供一个简单接口时，要使用外观模式\n一个应用程序使用了大量的对象，要使用享元模式\n在需要用比较通用和复杂的对象指针代替简单的指针的时候，使用代理模式\n你想在不明确指定接收者的情况下，向对各对象中的一个提交一个请求时，要使用职责链模式\n访问一个聚合对象的内容而无需暴露它的内部表示，要使用迭代器模式\n一组对象以定义良好但是复杂的方式进行通信，产生的相互依赖关系结构混乱且难以理解，要使用中介者模式\n当对一个对象的改变需要同时改变其他对象，而不知道具体有多少对象有待改变，要使用观察者模式\n一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变它的行为，要使用状态模式\n","date":"2025 年 2 月 14 日","externalUrl":null,"permalink":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%BA%94%E8%AF%95%E7%AC%94%E8%AE%B0/","section":"","summary":"","title":"设计模式 - 应试笔记","type":"posts"},{"content":"","date":"2025 年 2 月 14 日","externalUrl":null,"permalink":"/categories/%E5%BA%94%E8%AF%95%E7%AC%94%E8%AE%B0/","section":"","summary":"","title":"应试笔记","type":"categories"},{"content":"","date":"2025 年 2 月 14 日","externalUrl":null,"permalink":"/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/","section":"","summary":"","title":"机器学习","type":"tags"},{"content":" 本博客为吉林大学机器学习本科课程复习笔记。 课程内容主要来自于斯坦福 cs229。\n在应试之外，此博客对机器学习入门也能提供一定的参考。\n部分内容直接来自 PPT 讲义截图，可能对阅读产生不便，请谅解。\n本博客分为三部分，请自行在目录跳转。\n知识点内容总结 考试复习重点 考试数学推导重点（手写） 第01章-绪论 # 推理期-\u0026gt;知识期-\u0026gt;学习期\n符号主义学习:\n✓决策树：以信息论为基础，最小化信息熵\n✓基于逻辑的学习：用逻辑进行知识表示，通过修改扩充逻辑表达式对数据进行归纳\n连接主义学习:\n✓神经网络和深度学习\n统计学习:\n✓支持向量机及核方法\n✓2006年卡耐基梅隆大学成立第一个“机器学习系”系主任\u0026ndash;机器学习奠基人之一T. Mitchell教授\n新的方向：集成学习 强化学习 迁移学习 深度学习\n第02章-线性回归 # 假设函数 / 拟合函数： # 重点看其中的参数定义\n代价函数 # 绝对误差，平方和误差\n线性回归示例 # 注意上图最后一个公式挺重要的\n特征规范化 # （维度特征 - 均值）/ 标准差\nx1 = (x1 - mean(x1)) / std(x1)\n用来将尺度缩放到 -1 到 1 之间\n需要注意的是，特征缩放并不是一件很严格的事，他只是为了优化梯度下降效率的一个技巧，换句话说，没有明确的标准来规定每个向量的数据尺度应该是多少，从经验上来讲，[-1, 1]的尺度可以接受1/3到30左右的尺度偏差\n目标函数（最小二乘法） # 注意对比目标函数和代价函数，基本上目标函数就是多了个min\n一般而言，1/2应该为1/2m，使得函数值和数据量有关。\n这里的 2m 可以看做是方便后续计算而多写了一个 2 ，因为损失函数总会对某个变量求导，而恰好可以与平方项的求导结果抵消\n最小二乘法的正规方程 # 正规方程是直接用梯度和目标函数反推参数的方法，和梯度下降并列。直接计算出每个参数，精准且无需超参数但计算量大。\n梯度下降法 # 关键因子计算： # 即线性回归下的梯度下降可以简化公式\n即参数 θi 的梯度 = 误差值 * xi\nBGD vs SGD # 解决的是协调多样本梯度下降，其中 SGD 更常用\n学习率 # 正规方程 vs 梯度下降 # 局部加权线性回归 # 每项中添加 w 作为系数，一般用高斯核：\n欠拟合、过拟合、正则化 # 样本离群点：指显著偏离总体分布的异常数据点，可能影响统计分析结果。\n欠拟合（Underfitting）\n欠拟合发生在模型对训练数据的学习不足，无法很好地捕捉训练数据的规律，也无法在训练集和测试集上表现出良好的性能。 这通常是因为模型的复杂度太低，无法表示训练数据中的模式。 过拟合（Overfitting）\n过拟合发生在模型对训练数据学习得过多，甚至学习到了训练数据中的噪声和细节，从而失去了对新数据的泛化能力。 过拟合的模型在训练集上的表现非常好，但在测试集上的表现较差。 正则化（Regularization）\n定义\n正则化是一种用于防止过拟合的技术，通过在损失函数中加入额外的约束项（正则化项），限制模型的复杂度，从而提高模型的泛化能力。 原理\n在模型的损失函数中加入正则化项，通过对模型参数施加惩罚，限制参数的大小或稀疏性，使模型避免过度拟合训练数据。\nL1正则化（Lasso Regularization）\n在损失函数中加入参数的 L1 范数（即参数的绝对值之和）。\n优点：会使一些参数变为 0，从而实现特征选择，得到稀疏模型。\nL2正则化（Ridge Regularization）\n在损失函数中加入参数的 L2 范数（即参数的平方和）。\n优点：不会使参数变为 0，但能有效减小参数的值，防止过拟合。\n正则化项：（下图L1 L2 反了2）\nElastic Net 正则化\nL1 和 L2 正则化的结合，综合两者的优点。 第03章-逻辑回归 # 激活函数 # 单位阶跃函数\nsigmoid 逻辑回归的概率假设 # 对数几率变换 # Odds = 事件发生的概率 / 事件不发生的概率\nOdds = P(A) / [1 - P(A)]\n似然函数 # 注意 PPT 上的形式中 i 在右上角，并加括号。\n梯度法 最大似然函数 # 线性回归梯度法的关键因子为：\n形式上和逻辑回归的梯度上升维持相似：\n其假设函数对比如下：\n牛顿法 极大似然函数 # 牛顿法和梯度法对比 # 模型评估方法 # 训练集 (training): • 用于学习的数据集合 • 通常50 - 80 %的数据 验证集(validation):（平时很少使用到） • 用于设置和调整超参数的数据集合 • 通常10 - 20 %的数据 测试集(test): • 一组用于评估完整训练模型性能的数据 • 在评估测试集性能之后，不能进一步调优模型 • 通常10 - 30 %的数据 样本集的划分\n1. 留出法\n留出法是对数据集进行一次性划分，将数据分为训练集和测试集，用于评估模型性能。\n关键点：\n分层采样：在划分数据集时，按类别比例（或其他特征）进行分层采样，确保训练集和测试集的分布与原始数据一致。\n数据划分比例\n通常将数据的 2/3 到 4/5 用于训练，剩余部分用于测试（验证）。 测试集的样本数量建议大于 30，以保证评估结果的可靠性。\n优点\n简单直接，计算开销小。 缺点\n测试集划分的结果可能会受到数据分割方式的影响，存在一定随机性。 训练数据量较少时，模型可能无法充分学习。\n2. 交叉验证法\n交叉验证法是一种更稳定和常用的模型验证方法，通过多次划分和训练来全面评估模型性能。\n关键点：\nK 折交叉验证\n将数据集分为 K 个互斥的子集，每次将其中 1 个子集作为验证集，其余 K-1 个子集作为训练集。 这个过程重复 K 次，确保每个子集都被用作验证集一次。\n通常取 K=10（10 折交叉验证），以获得较好的性能评估。 分层采样\n和留出法类似，分层采样确保每个子集中的数据分布与原始数据一致。 K=样本数（留一法 Leave-One-Out）\n当 K 等于数据集样本数时，每次只用 1 个样本作为验证集，其余样本作为训练集，这种方法称为 留一法。 留一法适合小规模数据集，但计算开销较大。\n优点：\n各次评估结果的平均值可以更准确地反映模型性能。 更稳定，评估结果不依赖单次数据划分。 缺点：\n计算开销较大，尤其是数据集较大时。 第06章-支持向量机 # SVM 概念 # 三种分类：\n核函数、核技巧、核方法：\nSVM 如何克服过拟合 # 关于下面三种 SVM 部分，建议参考：看了这篇文章你还不懂SVM你就来打我 | TangShusen 线性可分 SVM — 硬间隔最大化 # 线性 SVM — 软间隔最大化 # 非线性SVM — 核技巧 # 回归问题 SVR # 在Support Vector Regression(SVR)中，同样也是计算间隔，不同的是使靠超平面最远的样本点之间的间隔最小。\n仅仅是约束有所不同\n第07章-聚类 # 聚类（Clustering）是最常见的无监督学习算法，它指的是按照某个特定标准（如距离）把一个数据集分割成不同的类或簇，使得同一个簇内的数据对象的相似性尽可能大，同时不在同一个簇中的数据对象的差异性也尽可能地大。\n主要类型 # ◼ 划分聚类（K-means、K-medoids等）\n◼ 层次聚类（凝聚法、分裂法）\n◼ 密度聚类（DBScan、基于密度峰值算法）\n◼ 网格法（STING、CLIQUE）\n◼ 模型法（概率模型：高斯混合模型Gaussian Mixture Models ；神经网络模型:SOM；吸引子传播算法： AP聚类）\n◼ 谱聚类\n划分聚类 # K-means：通过最小化簇内点到簇中心的平方误差，将数据划分为 k 个簇。 K-medoids：簇中心是数据点本身，通过最小化绝对距离实现聚类。 层次聚类 # 凝聚法：从每个点作为一个簇开始，逐步合并最相似的簇。 分裂法：从所有点作为一个簇开始，逐步将簇分裂成更小的簇。 密度聚类 # DBSCAN：通过核心点的密度连接形成簇，能够发现任意形状的簇。 基于密度峰值算法：通过识别局部密度的峰值作为簇中心实现聚类。 网格法 # STING：将数据划分为网格，并基于网格的统计信息进行聚类。 CLIQUE：结合网格划分和密度聚类，能够发现高维空间中的稀疏簇。 模型法 # 高斯混合模型（GMM）：假设数据由多个高斯分布组成，用概率计算点的簇隶属关系。 SOM：通过神经网络将高维数据映射到低维空间，同时保留数据的拓扑关系。 吸引子传播（AP聚类）：基于数据点间的相似性，通过消息传递选择簇中心。 基于网格的聚类 # 将数据空间划分成有限个单元的网格结构，所有的处理都是以单个的单元为对象 K-means算法 # K-means 算法的流程 # 随机选择 K 个簇中心点（可以选已有的数据作为中心点，也可直接选高维空间中的位置）\n样本被分配到离其最近的中心点\nK个簇中心点根据所在簇样本，以求平均值的方式重新计算\n开始迭代，重复第2步和第3步直到所有样本的分配不再改变\n损失函数 # K 的选择 # K-means算法 K 的选择(肘部法（elbow method）) • 目标：找到最合适的点——拐点 • 找到一个聚类数目，使得 K 高于该值之后的**损失（即上面的损失函数）**的变换会发生显著递减；也就是该点后的 loss 变换开始不明显。 • 这个 K 值，称为肘部点（elbow point），因为它看起来像一个人的肘部。\n优缺点 # 第08章-降维 # 维数灾难(Curse of Dimensionality)：通常是指在涉及到向量的计算的问题中，随着维数的增加，计算量呈指数倍增长的一种现象。\n在很多机器学习问题中，每条数据经常具有很高的特征维度。如果直接使用原始的数据，不仅会让训练非常缓慢，还会影响模型的泛化性能。\n降维(Dimensionality Reduction)是将训练数据中的样本(实例)从高维空间转换到低维空间。该过程与信息论中有损压缩概念相似，完全无损的降维是不存在。\n降维方法又分为线性降维和非线性降维，非线性降维又 分为基于核函数和基于流形等方法。\nPCA # 通过平移、旋转坐标轴完成对数据原始特征空间的重构\nPCA算法对于重构和降维的要求：\n重构的不同维度之间线性无关(正交、协方差为0)； 降维后所得维度的值尽可能分散(最大方差)； 考试复习重点 # PCA计算（必考） 条件：X矩阵 -\u0026gt; 减去 μ -\u0026gt; 其中可以是 m 或 m - 1 有 C = 1 / m * (X @ X.T)求协方差矩阵 协方差矩阵 -\u0026gt; 求特征值或特征向量（一般很难求，除非设计好数据） 特征向量转置则为 P，有P @ C @ P.T = λ 主对角线矩阵 降维 Y = Pi @ X ，贡献度为 λi 在 Σλ 的比值 SVM 给三个点求超平面 一定是三个点，因为三个点以上需要用SMO迭代 直接给对偶式子以及其st 带入即可求 a1 a2 a3 由 w = Σayx 得 w，带入任何一点即可求得 b 用正规方程求解线性回归 linalg.inv(X.T @ X) @ X.T @ Y 其中难点在求逆矩阵，增广矩阵法（会考吗？） 证明题： # 最小二乘法的关键因子推导（最简单）+ 带入梯度下降公式\n最小二乘法的正规方程推导\n线性回归最小二乘法的概率解释\n逻辑回归极大似然估计公式推导 -\u0026gt; 与线性回归的形式一致性\n线性可分 SVM\n从距离推导到目标 拉格朗日乘子法 求解 max (min L) SMO （非重点） 软间隔SVM 、非线性SVM 、SVR 推导可能性较小\nBP算法 （非重点）\n论述题： # 大概率一道回归、一道分类\n回归可能的点：\n房价预测实例 维度灾难时使用降维 最小二乘法为什么自然 非线性回归问题 -\u0026gt; 神经网络、SVR、线性回归核函数 分出训练集 测试集 验证集 正则化与过拟合 分类可能的点：\n区分有监督分类和无监督聚类\nSVM的使用方法、逻辑回归的使用方法（梯度与牛顿）\nSVM相比逻辑回归的好处\n神经网络的分类任务？\n二分类效果评估方法 F1 等\n简答题、选择题： # 监督学习 vs 无监督学习\n符号主义、连接主义、统计\n线性回归与逻辑回归中的 X 矩阵实际上是增广矩阵，用于适配 wx + b 中的 b\n损失函数 = 代价函数 ；加上 min，max 为目标函数\n特征规范化：x1=(x1-mean(x1))/std(x1)\n梯度下降与梯度上升（爬山）\n学习率的选择问题，过大会怎么样，过小会怎么样\nBGD vs SGD vs mini-batch\n全局极小值 vs 局部最小值\n线性回归 梯度下降 vs 正规方程\n过拟合与欠拟合 + 正则化\n什么是分类问题（硬分类与软分类），什么是回归问题\n单位阶跃函数 vs. Sigmoid function\nSigmoid 好在哪？，其参数怎么控制形状 Odds(几率、几率比)、似然函数\n牛顿法 vs 梯度法 牛顿法定义\n训练集 测试集 验证集\n交叉验证、K=10、留一法 自助法，可重复采样 准确率 精确率 召回率 F1score AUC\n核函数 核技巧 核方法\n结构风险最小化\nSVM 硬分类、软分类的 Margin 定义（松弛因子）\n非线性 SVM 的 𝐾(𝑥, 𝑦) = φ(𝑥) ⋅ φ(𝑦) 与 φ(x) : 𝑋 → 𝑅𝑚 (𝑚 ≫ 𝑛)\n高斯核参数以及惩罚参数对于分类情况的影响\nKKT 强对偶\nSVR 定义，目标函数\n聚类问题定义\n划分聚类：K-mean算法具体步骤与公式\n肘部法选择 K 优点缺点，对初值敏感 改进算法 层次聚类 密度聚类 网格法 模型法 谱聚类的定义\n什么是降维，什么是维度灾难，为什么降维\n完全无损的降维是不存在\nPCA的思想（计算考了，这里不考）\nPCA要求：正交（协方差为零）和最大方差\nPCA的优缺点\n神经网络 与 RBF神经网络\n感知器定义 感知器的表征能力\n多层前馈网络 正向传播 + 反向传播\n考试数学推导重点（手写） # ","date":"2025 年 2 月 14 日","externalUrl":null,"permalink":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%BA%94%E8%AF%95%E7%AC%94%E8%AE%B0/","section":"","summary":"","title":"机器学习 - 应试笔记","type":"posts"},{"content":"","date":"2025 年 2 月 14 日","externalUrl":null,"permalink":"/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","section":"","summary":"","title":"操作系统","type":"tags"},{"content":" 本博客为 吉林大学软件学院 操作系统课程 复习笔记。 本文内容基本只包括 简答题 的复习。\n名词解释题，网上已经有很多学长学姐的笔记，推荐 gonghr 学长。\n如果想 系统学习操作系统，本文也能起到一定的梳理作用。\n考试范围来自 2022级\n考试范围 # 第一章 绪论 # 操作系统（名词解释）：操作系统是位于硬件层(HAL)之上，所有其它软件层之下的一个系统软件，是管理系统中各种软硬件资源，方便用户使用计算机系统的程序集合。\n类别与发展（考过至少写出六种类别）\n第二章 进程管理 # 多道程序设计 # 吞吐量 = 作业道数 / 全部处理时间\n利用率 = CPU使用时间 / 运行总时间\nCPU利用率越高，说明系统效率越高对不对？\n不对，比如程序中出现死循环使得 CPU 利用率解决百分之百，无法处理其他请求，系统效率极低。\n单道程序设计资源利用率低\nMultiprogramming（多道程序设计）：多道程序设计是指在一台处理机上同时并发运行多个程序，即在一台处理机上有多个程序同时进入主存并发运行，宏观上并行，微观上串行交替运行。\n思考：内存中的程序数量是否越多越好\n道数过少，系统资源利用率低\n道数过多，系统开销(system overhead)增大，程序响应速度下降\n进程 # 1.重中之重\n4. 操作系统为什么提出“作业、进程、线程”的概念？\nPPT小结：\n作业与进程\n作业进入内存后变为进程\n一个作业通常与多个进程相对应\n进程与线程\n一个进程一般包含多个线程，至少包含一个线程\n不支持多线程的系统，可视为单线程进程\n**作业：**用户在一次解题或一个事物处理过程中要求计算机系统所做工作的集合。它包括用户程序、所需要的数据及控制指令等。作业是由一系列有序的步骤组成的。\n进程：\n进程是程序的一次执行\n进程是可以参与并发执行的程序\n进程是程序和数据一道通过处理器执行时所发生的活动\n进程是具有一定独立功能的程序关于一个数据集合的一次运行活动\n程序和进程\n程序静态，进程动态。这是进程和程序的本质差异\n程序可长期保存，进程有生存期\n一个程序可对应多个进程，一个进程只能执行一个程序\n并发：可与其它进程同时执行\n宏观同时，“交替执行”，不要求多个CPU\n**线程：**线程是进程中的一个实体，是被系统独立调度和执行的基本单位。\n作业是在早期的多道批处理系统中提出的，在现代操作系统中基本没有概念及应用。\n引入进程的目的是更好地使多道程序并发执行，提高资源利用率和系统吞吐量\n引入线程地目的使减小程序在并发执行时所付出地时空开销（上下文切换），提高操作系统地并发性能。\n进程状态转化\n进程创建时是什么状态\n就绪态\n当进程已分配到除处理器(CPU)以外的所有必要资源后，只要再获得处理器就可以执行的状态称为就绪状态。在一个系统里,可以有多个进程同时处于就绪状态，通常把这些就绪进程排成一个或多个队列，称为就绪队列。\n进程结束时是什么状态\n终止态\n当一个进程已经正常结束或异常结束，操作系统已将其从系统队列中移出，但是，尚未撤消，这时称为终止状态。\n下图为考试原题\n进程控制块PCB 标志进程存在的数据结构，其中保存系统管理进程所需的全部信息：pid、进程状态、现场信息、调度参数、所属用户(uid)……\n当调度某进程执行时，需要从该进程的PCB中查询其状态及优先级等参数\n当调度到某进程后，根据PCB中的现场信息恢复现场，并根据PCB中的程序和数据的内存地址找到程序和数据\n进程执行过程中，当需要与其它进程通信时，也要访问PCB\n当进程发生进程切换时，需要将现场信息从系统栈弹出，保存于PCB中\n系统建立进程时建立PCB，撤销进程时撤销PCB.\n进程上下文：PCB + 程序\n系统开销：运行操作系统程序完成系统管理工作所花费的时间和空间\nUNIX中分为 P区（proc）和U区（user）\nP区有Pid Uid 进程状态等 需要常驻内存\nU区是有进程被使用的时候才用的 不需要常驻\n进程切换时需要保存的现场信息\n16. 进程的现场信息包括什么，可能存放的位置\na 地址寄存器\n​\t保存当前CPU所访问的内存单元的地址\nb 通用寄存器\n​\t用于传送和暂存数据，也可参与算术逻辑运算，并保存运算结果\nc 浮点寄存器\n​\t用于存储浮点数字，它决定着计算机的计算精度。\nd. SP(系统栈指针)\ne. PSW(程序状态字)\nf. PC(指令计数器)\ng. 打开文件表\n存放位置：进程栈（不是系统栈）\n进程的特征\n§并发性 §动态性 §独立性 §交互性 §异步性 §结构性\n进程的创建与撤销\n进程创建 §向系统申请一个空闲PCB，并指定唯一的进程标识\n§为新进程分配资源\n§初始化新进程的PCB\n§加载程序\n§将PCB入就绪队列.\n考试原题！！考了两次\n引起进程创建的事件\n用户登录 作业调度 提供服务 应用请求\n进程撤销 exit()\n从系统PCB表中找到被撤销进程的PCB\n检查被撤销进程的状态是否为执行状态。若是，则立即停止该进程的执行\n设置重新调度标志，以便在该进程撤销后将处理器分配给其它进程\n检查被撤销进程是否有子孙进程，若有子孙进程还应撤销该进程的子孙进程\n回收该进程占有的全部资源并回收其PCB\n进程等待\n停止当前进程的执行，由于该进程正处于执行状态，故应停止该进程的执行\n保存该进程的现场信息。为了使进程以后能够重新调度运行，应将进程的现场信息送入其PCB中保存\n将进程状态改为等待.\n进程唤醒(事件发生)\n将被唤醒进程从相应的等待队列中移除\n将进程状态改为就绪，并将该进程插入就绪队列.\n思考：父进程创建子进程与主程序调用子程序区别?\n父进程创建子进程后，父进程与子进程可同时执行\n主程序调用子程序后，主程序暂停在调用点，子程序开始执行，直到子程序执行完毕返回，主程序才开始执行\n​\t思考\n​\t若系统中没有运行进程，是否一定没有就绪进程？\n​\ta：不一定比如死锁\n​\t若系统中即没有运行进程，也没有就绪进程，系统中是否就没有进程？\n​\ta：可能有等待状态的进程\n​\t在采用优先级进行调度时，运行进程是否一定是系统中优先级最高的进程？\n​\ta：就绪队列中的最高优先级进程\n​\t某进程被唤醒后立即投入运行，就说这个系统采用的是剥夺式调度方法？\n​\ta：不是，若当前CPU空闲，则非剥夺\n线程 # **线程是进程中一个相对独立的执行流。**一个进程可以包含多个线程，这些线程执行同一程序中的相同代码段或不同代码段，共享数据区和堆。一般认为，进程是资源的分配单位，线程是CPU的调度单位。\n多线程优点：\n§切换速度快（地址空间不变，避免了上下文切换（PCB+程序））\n§系统开销小\n§通讯容易（共享数据空间）\n线程控制块TCB(Thread control block)\n标志线程存在的数据结构，其中包含对线程管理需要的全部信息\n内容：线程标志 线程状态 调度参数 现场(通用寄存器,PC,SP) 链接指针\n存放位置：\n用户级线程：目态空间（用户空间）\n核心级线程：系统空间\n！考试原题：用户级线程与系统级的线程的区别（优缺点）\n用户级线程：\n§若同一进程中的多个线程至少有一个处于运行态，则该进程的状态为运行态\n§若同一进程中的多个线程均不处于运行态，但至少有一个线程处于就绪态，则该进程的状态为就绪态\n§若同一进程中的多个线程均处于等待态，则该进程的状态为等待态\n优点\n不依赖于操作系统，调度灵活\n同一进程中多线程切换速度快(不需进入操作系统)\n调度算法可以是进程专用的，不同的进程可以根据需要，对自己的线程选择不同的调度算法。\n用户级线程的实现于操作系统平台无关，对线程管理的代码是属于用户程序的一部分。\n缺点\n当线程执行一个系统调用时，不仅该线程被阻塞，而且进程内的所有线程都被阻塞。 不能发挥多处理机的优势，内核每次分配给进程仅有一个 CPU，因此进程中仅有一个线程能执行。 内核级线程\n优点 能充分发挥多处理机优势，内核能同时调度同一进程中多个线程并行执行。 如果进程中一个线程被阻塞，内核可以调度该进程中的其他线程占用处理机，也可以运行其他进程中的线程。 非新版本：内核支持线程具有很小的数据结构和堆栈，线程切换比较快、开销小。 非新版本：内核本身也可以采用多线程技术，可以提高系统的执行速度和效率。 缺点 同一进程中的线程切换，需要从用户态到核心态进行，系统开销大。 非新版本：线程的创建、撤销、调度在操作系统核心态，占用系统资源，增加系统开销。 具体区别\n核心级别线程操作系统可见；用户级别线程操作系统不可见\n用户级别线程的创建、撤销和调度不需要操作系统的支持，且是在（程序）语言这一级处理的。核心级别线程的创建、撤销和调度都需要操作系统内核的支持\n用户级别线程执行系统调用命令将导致其所属进程被中断，核心级别线程执行系统调用命令将导致线程被中断\n在仅有用户线程的系统内，CPU调度以进程为单位。在有核心级别线程的系统内，CPU调度以线程为单位\n用户级别线程的实体是运行在用户态下的程序，而核心级别线程的实体则是可以运行在任何状态下的程序\n第三章 中断和调度 # 中断 # 定义：处理器在运行过程中，出现了某一事件，必须中止正在运行的程序，转去处理这个事件，然后再返回原来运行的程序\n引入中断的目的\n实现并发活动\n实现实时处理\n故障自动处理\n中断类型： 自愿性主要的是系统调用、访管指令\n强迫性是硬件故障、程序性中断、外部中断、IO中断\n中断嵌套与中断屏蔽 计组学的\n中断屏蔽（关中断）-\u0026gt; 保护现场-\u0026gt;开中断（开放高优先级）-\u0026gt;中断处理-\u0026gt;关中断-\u0026gt;恢复现场（用PCB）-\u0026gt;开中断-\u0026gt;中断返回\n中断相当于一种特殊的子程序调用，发生时刻具有不确定性\n§思考1：中断现场保存在什么地方？进程现场保存在什么地方？\n中断现场主要保护PC PSW（中断向量），一般在系统栈中保存。\n进程以PCB进程控制块的形式保存在所有进程共享的内核空间中。\n§思考2：为什么说PCB保存的是核心级别现场？用户级别现场保存在什么地方？\nPCB保存在内核空间中，可以供操作系统内核以及其他进程访问。\n用户级现场保存在用户堆栈中，指的是线程级别的上下文信息，存储在目态空间。\n使用临界区的四个必要条件 ①空闲让进：临界区空闲时应该允许一个进程访问； ②忙则等待：临界区被访问时，其余想访问他的进程必须等待； ③有限等待：等待的进程在外等待的时间必须是有限的； ④让权等待：若等待进程一直等待，迟迟进不到临界区时，应该让出cpu，防止忙等待。 第五章 死锁 # 死锁：一组进程中的每一个进程，均无限期地等待此组进程中其它进程所占有的，因而永远无法得到的资源，这种现象称为进程死锁\n类型：竞争资源引起的死锁（可以竞争相同或不同的资源）、进程通讯引起的死锁、其他\n饥饿(starvation)\n当等待时间给进程推进和响应带来明显影响时,称发生了进程饥饿\n饥饿到一定程度的进程所赋予的使命即使完成也不再具有实际意义时称该进程被饿死\n§饥饿 vs 死锁\n§死锁进程处于等待状态，忙式等待的进程并非处于等待状态, 但却可能被饿死\n§死锁进程等待永远不会释放的资源, 饿死进程等待可能被释放,但却不会分给自己的资源,其等待时间没有上界\n§死锁一定发生了循环等待,饿死不然\n§死锁至少涉及两个进程, 饿死进程可能只有一个\n第六章 主存 # 动态异长分区的分配\n空闲区域表\n最先适应 (First Fit)\n​\t从低地址到高地址\n次适应法(Next Fit)\n​\t从低地址到高地址，从上次的地址开始继续找\n最佳适应 (Best Fit)\n​\t从小到大排序，会出碎片\n最坏适应 (Worst Fit)\n​\t从大到小排序，大进程无处可用\n碎片\n动态异常分区存储分配可能形成很小的空闲区域，称为碎片(fragment)\n如果碎片很多，将造成严重的存储资源浪费\n解决方法-紧凑(compaction)\n移动所有的占有区域，以使所有的空闲区域连成一片。缺点：开销大\n内存管理方式\n§界地址管理方式（一维地址）\n§页式管理方式（一维地址）\n§段式管理方式（二维地址）\n§段页式管理方式（二维地址）\n页式管理方式：具体和计组一样 多加了快表、页表\n页表对应 逻辑页号-\u0026gt;页框号 （存在多级页表）\n传统页表面向进程空间\n每个进程逻辑页面有一表项\n当进程空间很大时，页表很大\n反置页表面向内存空间\n对每个内存页框设置一个表项，表项的序号为物理页框号f，表项的内容为进程标识pid与逻辑页号p的有序对\n反置页表大小固定\n整个系统一个反置页表，为所有进程所共用\n快表相同，是更快的页表，但空间小\n段的共享（标记当前多少进程正在使用，归零后才能写入）\n段的保护-\u0026gt;\n对于保存共享代码的段，任何进程都不能修改它\n对于具有保密要求的段，某些进程不能读取它\n对于属于系统数据的段，某些进程不能修改等\n考试原题\n分段和分页的区别和优缺点\n页的大小是固定的，由操作系统决定，而段的大小不固定，取决于我们当前运行的程序。\n分页仅仅是为了满足操作系统内存管理的需求，而段是逻辑信息的单位，它含有一组其意义相对完整的信息，在程序中可以体现为代码段，数据段，是为了满足用户的需要。\n段一般比页大，因而段表比页表短，可以缩短查找时间，提高访问速度。\n分页对用户是透明的，分段对用户是可见的　第八章 文件 # 物理结构（顺序、链接、索引、倒排、散列）\n文件块：逻辑块号 + 块内地址（和页面一个道理）\nfcb：类似pcb 存储首地址，长度等信息\n顺序：整块的内存，用长度判越界\n链接：fcb存储块数，用指针形成链表\n索引：多加一个索引表，fcb存储索引表号和数量\n学习通简答题 # 作业、进程、线程（what，why） # 见上述表达\n忙式等待与排队等待 # 忙等待：当某进程正在使用临界区，其他试图进入临界区的进程都必须在进入区内连续空循环，会持续调用CPU查询临界区状态。\n排队等待：当某进程正在使用临界区，其他试图进入临界区的进程按顺序加入排队队列，当该临界区进入空闲时，给队首信号，让其进入临界区。在等待过程中不需要持续占用CPU。\n区分进程间的互斥与同步 # 两者都属于进程的竞态，其都有多个进程竞争使用不能被同时使用的只有，使得其一定要出现时间上的先后处理。\n互斥指的是当一个进程进入临界区时，其他程序一定要等待，当其退出临界区后，另一个进程才能访问该临界资源，其临界资源的使用是互斥的，在宏观上是串行的。\n同步指的是进程间具有前后执行顺序要求的，具有某种合作关系。\n面包店思路 # 说明一下面包店算法的思想? 如何实现的互斥与公平性问题?\n将每个线程想象成面包店的顾客，其想获得临界资源的操作为进入面包店，面包店每次只能进入一个人即临界资源只能同时被一个线程使用。想获取临界资源的线程获取一个号码，该号码逐次加一。但是当多个线程同时取号时，number修改前都进行了max，则他们会取到相同的number，但在执行时按照字典序进行。按照签到号码从小到大获取临界资源，完成后号码归零。\nA[i]=true; number[i]=max{number[0],…,number[n-1]}+1; A[i]=false; For (j=0; j\u0026lt; n; j++) { // 遍历 n 个进程 While (A[j]); // 当有线程 j 正在获取号码，阻塞 While ((number[j]!=0) \u0026amp;\u0026amp; (number[j],j)\u0026lt;(number[i],i)); // 如果找到线程 j 比 i 小，则等待 j 线程结束 } i 进入临界区…… // 清空 i 的号码 number[i] = 0; 其中 i 是某个当前有想要进入临界区的线程，j 是遍历全部线程找有没有比 i 号码靠前的线程。\n书中表达是 (a,b) \u0026lt; (c,d)\nA数组表示当前i是否正在取号，number数组表示取到的号码\n互斥性\n多个进程竞争进入临界区时, 抓到号且二元组(number[i],i)最小的进程获准进入临界区, 其它进程将在第一个while循环（ j正在抓号 ）或第二个while循环处（ 有比 i 更优先的 j）等待, 因而满足互斥性。\n公平性\n其本质上还是先进先出，一般情况下先申请的先获得号码，号码小的先执行。\n进展性\n只有一个线程申请进入临界区时，会直接执行。多个同时申请时，会有（number[i]，i）二元组最小的执行。\n优先等待性\n不会饿死\n活动进程 # 管程机制中的\u0026quot;活动进程“指的是什么进程?为什么在管程中只能有一个活动进程?\n活动进程：指的是处于就绪态或者是运行态的进程。 管程每次只允许一个进程进入，从而实现了进程的互斥，避免死锁\n","date":"2025 年 2 月 14 日","externalUrl":null,"permalink":"/posts/os-note/","section":"","summary":"","title":"操作系统 - 应试笔记","type":"posts"},{"content":" 本博客内容来源于我在某企业担任算法助教期间的教学材料，将课堂使用的 PPT 转换为 PDF 后整理而成。 博客前面内容为讲义内容大纲\n如果想仔细了解建议直接看最后的讲义原稿\n动态规划基础 # 动态规划（Dynamic Programming, DP）是一种优化决策过程的算法思想，常用于最优子结构和重叠子问题的场景。 主要包括： 状态定义 状态转移方程 初始状态 最终结果计算 经典 DP 问题分类 # 线性 DP # 最长递增子序列（LIS） 斐波那契数列 打家劫舍 最小花费爬楼梯 网格 DP # 最小路径和 不同路径 最大正方形 背包问题 # 0/1 背包 完全背包 多重背包 状态机 DP # 股票买卖问题 最长公共子序列（LCS） 划分 DP # 戳气球 石子合并 区间 DP # 回文子串 合并石子 数位 DP # 统计特定数字的个数 数位拆分问题 状态压缩 DP # 旅行商问题（TSP） 集合覆盖问题 斐波那契数列引入 # 斐波那契数列： $$ F(n) = F(n - 1) + F(n - 2) $$\n递归解法（时间复杂度 O(2^n)） 记忆化搜索（时间复杂度 O(n)） 动态规划（自底向上）（时间复杂度 O(n)） 矩阵快速幂（时间复杂度 O(log n)） 记忆化搜索 vs 动态规划 # 方法 适用情况 优点 缺点 记忆化搜索 递归问题 代码直观 可能栈溢出 动态规划 需要优化时间复杂度 避免重复计算 代码不一定直观 DP进阶 - 树上 DP # 换根 DP 树形背包 树的直径 课后练习题 # 最小花费爬楼梯（斐波那契进阶）\nLeetCode 746\n打家劫舍（经典 DP）\nLeetCode 198\n俄罗斯套娃信封问题（二维 LIS）\nLeetCode 354\n最长公共子序列（LCS）\nLeetCode 1143\n完整 PPT 预览 # 方式 1：腾讯文档在线预览 # 如果无法加载 PDF，请 点击这里打开腾讯文档。\n直接预览：\n方式 2：下载 PDF # 如果需要保存完整的 PDF 讲义，请点击下载： PDF 下载链接\n","date":"2025 年 2 月 13 日","externalUrl":null,"permalink":"/posts/%E4%BB%8E%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2%E5%88%B0%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","section":"","summary":"","title":"从记忆化搜索到动态规划","type":"posts"},{"content":" 本博客部分写自 2023 年，于 2025 年初重置。 由于本人经常忘记二分查找的要点，因此便对其进行了整理总结。\n部分参考了 yxc 和 0x3f 的教学内容。\n前言 # 二分查找在面试与竞赛中都十分常见。\n虽然算法难度不高。但不熟练的情况下会很容易出现边界错误而浪费时间。\n在复杂的综合题中，也可以会忘记使用二分查找，而导致超时。\n二分模板 # 二分最经典的情景，在单调数组中找目标值。\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e 原题链接：点击这里访问 # 第一个大于等于 target 的位置 # 等价于最常用的 lower_bound(a.begin(), a.end(), target) l = 0 r = n # 如果都小于 target，想返回 n 。就需要 r 初始化为 n，如果不想越界，就初始化为 n - 1。 while l \u0026lt; r : mid = l + r \u0026gt;\u0026gt; 1 if nums[mid] \u0026lt; target: l = mid + 1 else: r = mid return l # 第一个大于 target 的位置 # 等价于 upper_bound(a.begin(), a.end(), target) l = 0 r = n while l \u0026lt; r : mid = l + r \u0026gt;\u0026gt; 1 if nums[mid] \u0026lt;= target: l = mid + 1 else: r = mid return l # 最后一个小于等于 target 的位置 # 等价于的 lower_bound(a.begin(), a.end(), target, greater\u0026lt;int\u0026gt;()) l = 0 r = n while l \u0026lt; r : mid = l + r + 1 \u0026gt;\u0026gt; 1 if nums[mid] \u0026lt; target: l = mid else: r = mid - 1 return l # 最后一个小于 target 的位置 # 等价于最常用的 upper_bound(a.begin(), a.end(), target, greater\u0026lt;int\u0026gt;()) l = 0 r = n while l \u0026lt; r : mid = l + r + 1 \u0026gt;\u0026gt; 1 if nums[mid] \u0026lt;= target: l = mid else: r = mid - 1 return l 二分的库函数 # 对于 C++ 而言：\n#include\u0026lt;bits/stdc++.h\u0026gt; #include\u0026lt;algorithm\u0026gt; // 具体头文件 vector\u0026lt;int\u0026gt; a = {1, 2, 3, 4, 4, 5, 6}; int target = 4; // 对 vector 二分，库返回的是迭代器 auto it1 = lower_bound(a.begin(), a.end(), target); auto it2 = upper_bound(a.begin(), a.end(), target); // 其实 greater 就是把数组反过来查找 auto it3 = lower_bound(a.begin(), a.end(), target, greater\u0026lt;int\u0026gt;()); auto it4 = upper_bound(a.begin(), a.end(), target, greater\u0026lt;int\u0026gt;()); int pos = it1 - a.begin(); 对于 python 而言：\nimport bisect a = [1, 2, 3, 4, 4, 5, 6] target = 4 # 分别对应 lower_bound 和 upper_bound pos1 = bisect.bisect_left(a, target) pos2 = bisect.bisect_right(a, target) # Python 没有原生的降序 bisect，只能自己写下面两个 二分答案 # 根据经验，当题目中出现求最小、求最大、最大化最小、最小化最大时，很有可能要对答案进行二分查找。\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e 灵茶山艾府总结：点击这里访问 在二分答案时候，要时刻注意：\nr 的初始值是什么？即答案的上界。（如果在比赛中，上界开大一些更稳妥）\ncheck() 条件对应的边界是哪种？\n一般而言，check(int x) 按正常的 bool 逻辑写。 即 x 满足条件为 true，不满足为 false。 而在 while 查找中，用 !check()，代替第一种二分的 if 条件。 问题有没有单调性，能不能用二分？\n如果没有单调性，一般是 DP 或 搜索。 绝大部分二分答案的上界都在 int 范围外\n因此千万别忘了 mid 开 long long\n求最小 - 修车的最少时间： # \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e 原题链接：点击这里访问 给你一个整数数组 ranks ，表示一些机械工的 能力值 。ranksi 是第 i 位机械工的能力值。能力值为 r的机械工可以在 r * n2 分钟内修好 n 辆车。\n同时给你一个整数 cars ，表示总共需要修理的汽车数目。\n请你返回修理所有汽车 最少 需要多少时间。\n注意： 所有机械工可以同时修理汽车。\n示例 1：\n输入：ranks = [4,2,3,1], cars = 10 输出：16 解释： - 第一位机械工修 2 辆车，需要 4 * 2 * 2 = 16 分钟。 - 第二位机械工修 2 辆车，需要 2 * 2 * 2 = 8 分钟。 - 第三位机械工修 2 辆车，需要 3 * 2 * 2 = 12 分钟。 - 第四位机械工修 4 辆车，需要 1 * 4 * 4 = 16 分钟。 16 分钟是修理完所有车需要的最少时间。 示例 2：\n输入：ranks = [5,1,8], cars = 6 输出：16 解释： - 第一位机械工修 1 辆车，需要 5 * 1 * 1 = 5 分钟。 - 第二位机械工修 4 辆车，需要 1 * 4 * 4 = 16 分钟。 - 第三位机械工修 1 辆车，需要 8 * 1 * 1 = 8 分钟。 16 分钟时修理完所有车需要的最少时间。 提示：\n1 \u0026lt;= ranks.length \u0026lt;= 105 1 \u0026lt;= ranks[i] \u0026lt;= 100 1 \u0026lt;= cars \u0026lt;= 106 题解：\n# 经典二分答案 class Solution: def repairCars(self, ranks: List[int], cars: int) -\u0026gt; int: def check(x : int) -\u0026gt; bool: car_num = 0 for rank in ranks: car_num += int(sqrt(x / rank)) return car_num \u0026gt;= cars l, r = 0, int(1e15) while l \u0026lt; r: mid = l + r \u0026gt;\u0026gt; 1 if not check(mid): l = mid + 1 else: r = mid return l 最小化最大 - 袋子里最少数目的球： # \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e 原题链接：点击这里访问 给你一个整数数组 nums ，其中 nums[i] 表示第 i 个袋子里球的数目。同时给你一个整数maxOperations 。\n你可以进行如下操作至多 maxOperations 次：\n选择任意一个袋子，并将袋子里的球分到 2 个新的袋子中，每个袋子里都有正整数个球。 比方说，一个袋子里有 5 个球，你可以把它们分到两个新袋子里，分别有 1 个和 4 个球，或者分别有 2 个和 3 个球。 你的开销是单个袋子里球数目的 最大值 ，你想要 最小化 开销。\n请你返回进行上述操作后的最小开销。\n示例 1：\n输入：nums = [9], maxOperations = 2 输出：3 解释： - 将装有 9 个球的袋子分成装有 6 个和 3 个球的袋子。[9] -\u0026gt; [6,3] 。 - 将装有 6 个球的袋子分成装有 3 个和 3 个球的袋子。[6,3] -\u0026gt; [3,3,3] 。 装有最多球的袋子里装有 3 个球，所以开销为 3 并返回 3 。 示例 2：\n输入：nums = [2,4,8,2], maxOperations = 4 输出：2 解释： - 将装有 8 个球的袋子分成装有 4 个和 4 个球的袋子。[2,4,8,2] -\u0026gt; [2,4,4,4,2] 。 - 将装有 4 个球的袋子分成装有 2 个和 2 个球的袋子。[2,4,4,4,2] -\u0026gt; [2,2,2,4,4,2] 。 - 将装有 4 个球的袋子分成装有 2 个和 2 个球的袋子。[2,2,2,4,4,2] -\u0026gt; [2,2,2,2,2,4,2] 。 - 将装有 4 个球的袋子分成装有 2 个和 2 个球的袋子。[2,2,2,2,2,4,2] -\u0026gt; [2,2,2,2,2,2,2,2] 。 装有最多球的袋子里装有 2 个球，所以开销为 2 并返回 2 。 示例 3：\n输入：nums = [7,17], maxOperations = 2 输出：7 提示：\n1 \u0026lt;= nums.length \u0026lt;= 105 1 \u0026lt;= maxOperations, nums[i] \u0026lt;= 109 题解：\nclass Solution: def minimumSize(self, nums: List[int], maxOperations: int) -\u0026gt; int: def check(x : int) -\u0026gt; bool: if x == 0: return False operation = 0 for num in nums: if num \u0026gt; x: operation += (num + x - 1) // x - 1 # 向上取整后减一 return operation \u0026lt;= maxOperations l, r = 0, int(1e9) while l \u0026lt; r: mid = l + r \u0026gt;\u0026gt; 1 if not check(mid): l = mid + 1 else: r = mid return l 最大化最小 - 范围内整数的最大得分： # \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e 原题链接：点击这里访问 给你一个整数数组 start 和一个整数 d，代表 n 个区间 [start[i], start[i] + d]。\n你需要选择 n 个整数，其中第 i 个整数必须属于第 i 个区间。所选整数的 得分 定义为所选整数两两之间的最小 绝对差。\n返回所选整数的 最大可能得分 。\n示例 1：\n输入： start = [6,0,3], d = 2\n输出： 4\n解释：\n可以选择整数 8, 0 和 4 获得最大可能得分，得分为 min(|8 - 0|, |8 - 4|, |0 - 4|)，等于 4。\n示例 2：\n输入： start = [2,6,13,13], d = 5\n输出： 5\n解释：\n可以选择整数 2, 7, 13 和 18 获得最大可能得分，得分为 min(|2 - 7|, |2 - 13|, |2 - 18|, |7 - 13|, |7 - 18|, |13 - 18|)，等于 5。\n提示：\n2 \u0026lt;= start.length \u0026lt;= 105 0 \u0026lt;= start[i] \u0026lt;= 109 0 \u0026lt;= d \u0026lt;= 109 题解：\n// 24.9.8 注释： 对二分板子不熟悉 导致花了很长时间 class Solution { public: bool check(int mid, vector\u0026lt;int\u0026gt;\u0026amp; start, int d) { int n = start.size(); long long mn = start[0]; for (int i = 1; i \u0026lt; n; i++) { // 改了一个小时没改出来 max 这行 还得多学学 mn = max(1LL * start[i], mn + mid); if (mn \u0026lt;= start[i] + d) { continue; } return false; } return true; } int maxPossibleScore(vector\u0026lt;int\u0026gt;\u0026amp; start, int d) { int n = start.size(); sort(start.begin(), start.end()); // 上边界二分的写法不能忘啊 long long l = 0, r = long(2e9); while (l \u0026lt; r) { long long mid = l + r + 1 \u0026gt;\u0026gt; 1; if (!check(mid, start, d)) { r = mid - 1; } else { l = mid; } } return l; } }; 二分作为解题步骤之一 # 二分经常作为解题中的某一步，经常和其他算法结合考察。\n前缀和 - 青蛙过河 # 原题链接：点击这里访问 小青蛙住在一条河边，它想到河对岸的学校去学习。\n小青蛙打算经过河里的石头跳到对岸。\n河里的石头排成了一条直线，小青蛙每次跳跃必须落在一块石头或者岸上。\n不过，每块石头有一个高度，每次小青蛙从一块石头起跳，这块石头的高度就会下降 1，当石头的高度下降到 0 时小青蛙不能再跳到这块石头上（某次跳跃后使石头高度下降到 0 是允许的）。\n小青蛙一共需要去学校上 x 天课，所以它需要往返 2x 次。 当小青蛙具有一个跳跃能力 y 时，它能跳不超过 y 的距离。 请问小青蛙的跳跃能力至少是多少才能用这些石头上完 x 次课。\n输入格式\n输入的第一行包含两个整数 n, x，分别表示河的宽度和小青蛙需要去学校的天数。请注意 2x 才是实际过河的次数。\n第二行包含 n−1 个非负整数 H1, H2, ⋅⋅⋅, Hn−1，其中 Hi \u0026gt; 0 表示在河中与小青蛙的家相距 i 的地方有一块高度为 Hi 的石头，Hi = 0 表示这个位置没有石头。\n输出格式\n输出一行，包含一个整数，表示小青蛙需要的最低跳跃能力。\n数据范围\n对于所有评测用例，1 ≤ n ≤ 10⁵, 1 ≤ x ≤ 10⁹, 0 ≤ Hi ≤ 10⁴。\n输入样例\n5 1 1 0 1 0 输出样例\n4 样例解释\n由于只有两块高度为 1 的石头，所以往返只能各用一块。\n第 1 块石头和对岸的距离为 4，如果小青蛙的跳跃能力为 3 则无法满足要求。\n所以小青蛙最少需要 4 的跳跃能力。\n题解\n// 找规律 + 前缀和 + 二分查找 // 核心是先找到为了让青蛙能踩到对应的石头，满足 i 块到 i + step 块石头的和大于 2 * x 即可 // 多次求区间之和自然想到前缀和 // 多次求位置的 step 并且符合二段性 自然考虑二分查找 // 此题要实现的细节挺多的 要注意 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n, x; vector\u0026lt;int\u0026gt;stone; vector\u0026lt;long long\u0026gt;prefix; bool check(int step) { // 注意上界为 n - step for (int i = 0; i \u0026lt; n - step + 1; i++) { if (prefix[i + step] - prefix[i] \u0026lt; 2 * x) { return false; } } return true; } int main () { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; x; n--; stone.resize(n); for (int i = 0; i \u0026lt; n ;i++) { cin \u0026gt;\u0026gt; stone[i]; } prefix.resize(n + 1); prefix[0] = 0; for (int i = 1; i \u0026lt;= n; i++) { prefix[i] = prefix[i - 1] + stone[i - 1]; //\tcout \u0026lt;\u0026lt; prefix[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } int l = 0, r = n + 100; while(l \u0026lt; r) { int mid = l + r \u0026gt;\u0026gt; 1; //\tcout \u0026lt;\u0026lt; mid \u0026lt;\u0026lt; \u0026#34; \u0026#34;; if (!check(mid)) l = mid + 1; else r = mid; } cout \u0026lt;\u0026lt; l; return 0; } ","date":"2025 年 2 月 12 日","externalUrl":null,"permalink":"/posts/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%80%BB%E7%BB%93%E4%B8%8E%E4%BE%8B%E9%A2%98/","section":"","summary":"","title":"“二分查找” 总结与例题","type":"posts"},{"content":"","date":"2025 年 2 月 12 日","externalUrl":null,"permalink":"/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/","section":"","summary":"","title":"二分查找","type":"tags"},{"content":" \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e 原题链接：点击这里访问 猫和老鼠 题干 # 两位玩家分别扮演猫和老鼠，在一张无向图上进行游戏，两人轮流行动。\n图的形式是：graph[a] 是一个列表，由满足 ab 是图中的一条边的所有节点 b 组成。\n老鼠从节点 1 开始，第一个出发；猫从节点 2 开始，第二个出发。在节点 0 处有一个洞。\n在每个玩家的行动中，他们必须沿着图中与所在当前位置连通的一条边移动。例如，如果老鼠在节点 1 ，那么它必须移动到 graph[1] 中的任一节点。\n此外，猫无法移动到洞中（节点 0）。\n然后，游戏在出现以下三种情形之一时结束：\n如果猫和老鼠出现在同一个节点，猫获胜。 如果老鼠到达洞中，老鼠获胜。 = 如果某一位置重复出现（即，玩家的位置和移动顺序都与上一次行动相同），游戏平局。 给你一张图 graph ，并假设两位玩家都都以最佳状态参与游戏：\n如果老鼠获胜，则返回 1； 如果猫获胜，则返回 2； 如果平局，则返回 0 。 示例 1：\n输入：graph = [[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]] 输出：0 示例 2：\n输入：graph = [[1,3],[0],[3],[0,2]] 输出：1\n提示：\n3 \u0026lt;= graph.length \u0026lt;= 50 1 \u0026lt;= graph[i].length \u0026lt; graph.length 0 \u0026lt;= graph[i][j] \u0026lt; graph.length graph[i][j] != i graph[i] 互不相同 猫和老鼠在游戏中总是可以移动 博弈 前置知识 # 显然此题和博弈有关。先回忆最简单的博弈：NIM 游戏。\n给定 N 堆石子，第 i 堆有 ai 个石子。\n两名玩家轮流行动，每次在一堆石子中取若干个，不能不取，最后不能取的人输。\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e 原题链接：点击这里访问 简单来说，在公平博弈中，己方的最优策略是通过将对方引入其必败状态来确保胜利。\n核心思想是，在假设双方都采用最优策略的情况下：\n如果从某个状态可以到达至少一个对方必败状态，那么该状态对于己方就是必胜的。\n反之，如果无法到达任何对方必败状态，则该状态对己方就是必败的。\n如果游戏存在平局，则无法在确认必胜或必负的情况就是平局。\n对于该前置内容，我在24年初写过一道蓝桥杯的题，连接贴在下面可以参考：\n原题链接：点击这里访问 灭鼠先锋是一个老少咸宜的棋盘小游戏，由两人参与，轮流操作。\n灭鼠先锋的棋盘有各种规格，本题中游戏在两行四列的棋盘上进行。游戏的规则为：两人轮流操作，每次可选择在棋盘的一个空位上放置一个棋子，或在同一行的连续两个空位上各放置一个棋子，放下棋子后使棋盘放满的一方输掉游戏。\n小蓝和小乔一起玩游戏，小蓝先手，小乔后手。小蓝可以放置棋子的方法很多，通过旋转和翻转可以对应如下四种情况：\nXOOO XXOO OXOO OXXO OOOO OOOO OOOO OOOO 其中 O 表示棋盘上的一个方格为空，X 表示该方格已经放置了棋子。\n请问，对于以上四种情况，如果小蓝和小乔都是按照对自己最优的策略来玩游戏，小蓝是否能获胜。如果获胜，请用 V 表示，否则用 L 表示。请将四种情况的胜负结果按顺序连接在一起提交。\n24年题解如下\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; bool check(string s){//判断是否只有一个O int cnt = 0; for(auto i : s){ cnt += i==\u0026#39;O\u0026#39;; } return cnt == 1; } unordered_map\u0026lt;string, bool\u0026gt;mp; bool dfs(string s){ if(mp.count(s))return mp[s]; if(check(s)){//当当前状态只有一个O时标记为必败态 mp[s] = false; return false; } // 核心思路是只有遍历能到达一个必败态，此态就是必胜的（两人都是最优策略） // 如果一个必败态都无法到达，此态就是必败的 // 进行记忆化搜素 // 放置一个 for(int i = 0; i \u0026lt; s.size(); i ++){ if(s[i] == \u0026#39;O\u0026#39;){ string tmp = s; tmp[i] = \u0026#39;X\u0026#39;; if(dfs(tmp) == false){ mp[s] = true; return true; } } } // 放置两个 for(int i = 0; i \u0026lt; s.size(); i ++){ if(s[i] == \u0026#39;O\u0026#39; \u0026amp;\u0026amp; s[i+1] == \u0026#39;O\u0026#39; \u0026amp;\u0026amp; i != 3){ string tmp = s; tmp[i] = \u0026#39;X\u0026#39;; tmp[i+1] = \u0026#39;X\u0026#39;; if(dfs(tmp) == false){ mp[s] = true; return true; } } } mp[s] = false; return false; } int main() { dfs(\u0026#34;OOOOOOOO\u0026#34;); dfs(\u0026#34;XOOOOOOO\u0026#34;); dfs(\u0026#34;OXOOOOOO\u0026#34;); dfs(\u0026#34;XXOOOOOO\u0026#34;); dfs(\u0026#34;OXXOOOOO\u0026#34;); cout \u0026lt;\u0026lt; mp[\u0026#34;OXXOOOOO\u0026#34;] \u0026lt;\u0026lt; endl; return 0; } 记忆化搜索 # 一般而言，博弈问题可以转化为搜索问题。显然在博弈过程中会有大量重复子问题，因此往往会引入记忆化搜索。\n对于该题，很容易思考到搜索的前两个参数：猫位置与鼠位置。而第三个参数则有两种可能的写法，即 bool 类型表示现在是哪方的回合，以及 int 类型表示当前第几回合。\n而初始状态为：\n老鼠成功进洞，即 dp[0][j][1] = 1 （贪心可知，老鼠赢的下一回合一定是猫的回合） 猫捉到老鼠，即 dp[i][i][1] = 2 dp[i][i][0] = 2 如果想用 bool 类型表示回合，就又引出了新的问题。在无法确定回合数的情况下，如果不加上其他限制，对于平局会进入无限循环的搜索。\n但是对于 int 类型表示回合数，在此题的时间复杂度是不够的：\n在本题中，猫和鼠的数据范围都是 n 。如果第三个参数为上述的 int 行，其上界为： \\( 2 \\times n^2 \\) 则搜索状态为 \\( O(n^4) \\)，而此题的初始状态数上述提到过了是 n ，因此总复杂度为： \\( O(n^5) \\) 不能满足时间要求。\n根据上面的分析，此题的问题变为：在使用 bool 表示当前是谁的回合时，如何避免出现无限循环的搜索并尽可能剪枝。\n对于回合数作为第三个参数时的官方题解如下：\nclass Solution { public: const int MOUSE_TURN = 0, CAT_TURN = 1; const int DRAW = 0, MOUSE_WIN = 1, CAT_WIN = 2; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; graph; vector\u0026lt;vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026gt; degrees; vector\u0026lt;vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026gt; results; int catMouseGame(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; graph) { int n = graph.size(); this-\u0026gt;graph = graph; this-\u0026gt;degrees = vector\u0026lt;vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026gt;(n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;(n, vector\u0026lt;int\u0026gt;(2))); this-\u0026gt;results = vector\u0026lt;vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026gt;(n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;(n, vector\u0026lt;int\u0026gt;(2))); queue\u0026lt;tuple\u0026lt;int, int, int\u0026gt;\u0026gt; qu; for (int i = 0; i \u0026lt; n; i++) { for (int j = 1; j \u0026lt; n; j++) { degrees[i][j][MOUSE_TURN] = graph[i].size(); degrees[i][j][CAT_TURN] = graph[j].size(); } } for (int node : graph[0]) { for (int i = 0; i \u0026lt; n; i++) { degrees[i][node][CAT_TURN]--; } } for (int j = 1; j \u0026lt; n; j++) { results[0][j][MOUSE_TURN] = MOUSE_WIN; results[0][j][CAT_TURN] = MOUSE_WIN; qu.emplace(0, j, MOUSE_TURN); qu.emplace(0, j, CAT_TURN); } for (int i = 1; i \u0026lt; n; i++) { results[i][i][MOUSE_TURN] = CAT_WIN; results[i][i][CAT_TURN] = CAT_WIN; qu.emplace(i, i, MOUSE_TURN); qu.emplace(i, i, CAT_TURN); } while (!qu.empty()) { auto [mouse, cat, turn] = qu.front(); qu.pop(); int result = results[mouse][cat][turn]; vector\u0026lt;tuple\u0026lt;int, int, int\u0026gt;\u0026gt; prevStates = GetPrevStates(mouse, cat, turn); for (auto \u0026amp; [prevMouse, prevCat, prevTurn] : prevStates) { if (results[prevMouse][prevCat][prevTurn] == DRAW) { bool canWin = (result == MOUSE_WIN \u0026amp;\u0026amp; prevTurn == MOUSE_TURN) || (result == CAT_WIN \u0026amp;\u0026amp; prevTurn == CAT_TURN); if (canWin) { results[prevMouse][prevCat][prevTurn] = result; qu.emplace(prevMouse, prevCat, prevTurn); } else if (--degrees[prevMouse][prevCat][prevTurn] == 0) { int loseResult = prevTurn == MOUSE_TURN ? CAT_WIN : MOUSE_WIN; results[prevMouse][prevCat][prevTurn] = loseResult; qu.emplace(prevMouse, prevCat, prevTurn); } } } } return results[1][2][MOUSE_TURN]; } vector\u0026lt;tuple\u0026lt;int, int, int\u0026gt;\u0026gt; GetPrevStates(int mouse, int cat, int turn) { vector\u0026lt;tuple\u0026lt;int, int, int\u0026gt;\u0026gt; prevStates; int prevTurn = turn == MOUSE_TURN ? CAT_TURN : MOUSE_TURN; if (prevTurn == MOUSE_TURN) { for (int \u0026amp; prev : graph[mouse]) { prevStates.emplace_back(prev, cat, prevTurn); } } else { for (int \u0026amp; prev : graph[cat]) { if (prev != 0) { prevStates.emplace_back(mouse, prev, prevTurn); } } } return prevStates; } }; 拓扑排序 前置知识 # 此题说是用到拓扑排序并不准确，更应该说是用到拓扑排序的“ 入度表 ”的思想。\n入度表 记录 每个节点被指向的次数。\n使用 队列 处理 入度为 0 的节点。\n不断删除已处理的节点，更新 入度表。\n若无法遍历所有节点，则存在环。\n时间复杂度 O(n + m)，适用于 有向无环图（DAG）。\n对于该拓扑排序前置知识，可以参考下面：\n任务拓扑排序 # 一个工程被分解成n个子任务，编号为0至n-1。要完成整个工程需要完成所有的子任务。其中一些子任务必须先于另外一些子任务被完成。给定各子任务之间的先后关系，请编写程序给出一个合理的任务完成顺序，若工程不可行，程序亦能识别。\n输入第一行为两个整数n和e，均不超过100。n表示子任务数。接下来e行，表示已知的两个子任务间的先后关系，每行为两个整数a和b，表示任务a必须先于任务b完成。\n若工程不可行（一些子任务以自己为先决条件），输出“unworkable project”；若工程可行，输出为1行整数，每个整数后一个空格，为n个子任务的编号，表示子任务的完成顺序，如果有多种可能的顺序，则输出字典序最小者。\n注：字典序，即对象在字典中的顺序。对于两个数字序列，从第一个数字开始比较，当某一个位置的数字不同时，该位置数字较小的序列，字典序较小，例如1 2 3 9比1 2 4 5小，1 2 8 9比1 2 10 3小。\n样例1：\n3 2 0 1 1 2 0 1 2 样例2：\n3 3 0 1 1 2 2 0 unworkable project ANSWER # #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; graph(n); vector\u0026lt;int\u0026gt; inDegree(n, 0); // 记录每个节点的入度 // 读取边信息 for (int i = 0; i \u0026lt; m; i++) { int from, to; cin \u0026gt;\u0026gt; from \u0026gt;\u0026gt; to; graph[from].push_back(to); inDegree[to]++; // 目标节点的入度增加 } // 小顶堆（优先队列）保证字典序最小 priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; q; // 将所有入度为 0 的节点入队 for (int i = 0; i \u0026lt; n; i++) { if (inDegree[i] == 0) { q.push(i); } } vector\u0026lt;int\u0026gt; topoOrder; // 记录拓扑排序结果 while (!q.empty()) { int node = q.top(); q.pop(); topoOrder.push_back(node); for (int neighbor : graph[node]) { inDegree[neighbor]--; // 删除当前节点的出边 if (inDegree[neighbor] == 0) { // 若入度变为 0，则加入队列 q.push(neighbor); } } } // 如果排序结果中的节点数小于总节点数，说明有环 if (topoOrder.size() \u0026lt; n) { cout \u0026lt;\u0026lt; \u0026#34;unworkable project\u0026#34; \u0026lt;\u0026lt; endl; } else { for (int node : topoOrder) { cout \u0026lt;\u0026lt; node \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } } return 0; } 动态规划 # 那么在这道题中，如果为所有状态添加一个入度表，就可以做到上述的剪枝。\n同样的，我们选择自顶向下，初始状态为：\n老鼠成功进洞，即 result[0][j][1] = 1 （贪心可知，老鼠赢的下一回合一定是猫的回合） 猫捉到老鼠，即 result[i][i][1] = 2 result[i][i][0] = 2 其他状态设置为 0，即平局。 而对于入度的初始化为：\ndegree[i][j][0] = len(graph[i])\ndegree[i][j][1] = len(graph[j])\ndegree[i][j][1] -= 1 if j in graph[0] （猫不能在洞里）\n那么状态转移可以理解为：\n从最终状态遍历每一个前置状态： 若遍历到该前置状态的必胜态，则使其入度为零。 如没遍历到必胜态，则每次遍历使得其入度减一，知道其度为零，则设置其为必败态。 将已经确定必败或必胜的状态加入 queue 中， BFS 遍历其前置状态。 该转移没有遍历到的状态即平局状态。 当然此题还有些细节需要注意，可以看题解中的注释:\nclass Solution: def catMouseGame(self, graph: List[List[int]]) -\u0026gt; int: n = len(graph) queue = deque() # 状态为 degree[i][j][k] 表示: # 老鼠在 i , 猫在 j, 谁先手为 k (0 表示老鼠回合，1 表示猫回合) degree = [[[0, 0] for _ in range(n)] for _ in range(n)] result = [[[0, 0] for _ in range(n)] for _ in range(n)] def init(): for i in range(n): for j in range(1, n): degree[i][j][0] = len(graph[i]) degree[i][j][1] = len(graph[j]) # 猫不能在洞里，所以要减去这种特殊情况 for i in range(n): for j in graph[0]: degree[i][j][1] -= 1 for i in range(n): for j in range(1, n): if i == 0: result[i][j][1] = 1 # result[i][j][0] = 1 queue.append([i, j, 1]) # queue.append([i, j, 0]) elif i == j: result[i][j][1] =2 result[i][j][0] =2 queue.append([i, j, 1]) queue.append([i, j, 0]) init() # 检查前一个状态是否已经能被确定 def preCheck(preMouse, preCat, preTurn, result_state): if result[preMouse][preCat][preTurn] != 0: return # 如果下一个状态能赢，则直接确定为赢 win = True if result_state == 1 + preTurn else False if win: # 如果能赢，则入度直接归零 result[preMouse][preCat][preTurn] = result_state queue.append((preMouse, preCat, preTurn)) degree[preMouse][preCat][preTurn] = 0 # 避免重复处理 else: degree[preMouse][preCat][preTurn] -= 1 if degree[preMouse][preCat][preTurn] == 0: result[preMouse][preCat][preTurn] = 2 - preTurn queue.append((preMouse, preCat, preTurn)) # queue 中都是已经确定结果的状态 while queue: mouse, cat, turn = queue.popleft() result_state = result[mouse][cat][turn] preTurn = 1 - turn # 换手 if preTurn == 0: # 前一个回合是老鼠 for preMouse in graph[mouse]: preCheck(preMouse, cat, preTurn, result_state) else: # 前一个回合是猫 for preCat in graph[cat]: if preCat == 0: continue preCheck(mouse, preCat, preTurn, result_state) return result[1][2][0] 总结 # 此题综合了博弈论、搜索剪枝、动态规划、拓扑排序。有一定的难度，可以时常复习。\n","date":"2025 年 2 月 10 日","externalUrl":null,"permalink":"/posts/%E7%8C%AB%E5%92%8C%E8%80%81%E9%BC%A0-lc/","section":"","summary":"","title":"从“猫和老鼠”题解看博弈题型","type":"posts"},{"content":"","date":"2025 年 2 月 10 日","externalUrl":null,"permalink":"/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/","section":"","summary":"","title":"拓扑排序","type":"tags"},{"content":"","date":"2025 年 2 月 10 日","externalUrl":null,"permalink":"/tags/%E5%9B%BE%E8%AE%BA/","section":"","summary":"","title":"图论","type":"tags"},{"content":" Kaggle 分类任务，使用 MLP、RF、SVM。 实验报告格式根据 智能算法综合实践 课程要求。\n比赛界面：电话顾客流失\n我的开源 jupyter notebook ：\n随机森林 ，逻辑回归，SVM\n一、前言 # 我想将 jupyter notebook 的输出汇总到本报告之中，但转化无法避免的导致排版略显杂乱，请理解。\n本实验报告很大一部分是由 jupyter notebook 转化 md 而得到的：\njupyter nbconvert name.ipynb --to markdown 而 word 版本使用了：\npandoc name.md -o output.docx 比赛界面：Telco-Customer-Churn\n二、实验目的 # 在 Kaggle 电话客户流失竞赛中构建模型并优化性能。\n掌握数据预处理、特征工程及分类任务建模方法。\n熟悉 PyTorch 的基本操作，包括数据处理、模型训练与评估。\n其中关于 PyTorch 操作，借由本次实验我进行了一定程度的总结，见我的博客：pytorch 总结\n三、实验原理与实验步骤 # 逻辑回归与数据处理 # 本实验使用的是 Telco 客户流失预测数据集，目标是预测客户是否会流失（分类任务）。\n初步处理过程如下：\n数据加载与探索：读取训练集和测试集，并查看数据维度、字段信息，识别出类别与数值型特征。 缺失值处理与特征编码： 类别特征使用 OneHotEncoder 进行独热编码； 数值特征使用 StandardScaler 进行标准化； 标签 Churn 转换为二值标签（Yes → 1，No → 0）。 主成分分析（PCA）： 对预处理后的特征进行 PCA 降维，保留 95% 信息； 并可视化前两个主成分，观察数据分布。 使用 MLP 多层感知机模型 # 构建了一个包含两层隐藏层的 MLP 模型，结构为：\n输入层 → Linear(64) → ReLU → Dropout(0.5) 隐藏层 → Linear(64) → ReLU → Dropout(0.5) 输出层 → Sigmoid 使用 BCELoss() 作为损失函数，采用 Adam 优化器进行训练。\n最终训练准确率约为 0.8575，测试准确率为 0.8119。由于模型较大，出现了一定程度的过拟合。\n随机森林模型 # 使用 RandomForestClassifier 进行建模：\n设置参数如 n_estimators=150, max_depth=30。 并使用 GridSearchCV 进行参数网格搜索，提升模型性能。 最终测试集准确率约为 0.7999。\nSVM 支持向量机模型 # 采用 SVM 进行建模：\n使用 PCA 降维后的数据。 使用 SVC(kernel='linear', C=0.5)，并通过 GridSearchCV 搜索最优参数。 最终测试集准确率约为 0.8204，表现稳定。\n模型融合（Ensemble） # 为了进一步提升准确率，使用了融合模型：\n加载 MLP、RandomForest 和 SVM 三个模型； 构建一个 WeightedEnsemble 融合层，使用 softmax 归一化可学习权重； 使用 BCELoss 和 Adam 优化器训练融合模型； 结果可视化显示融合层输出分布良好。 最终融合模型在测试集上取得 0.8421 的预测准确率 ，排名 25 / 300 。\n融合模型的训练和可视化展示了三种模型在预测上的互补性。\n四、具体实验 # 导入并处理数据集 # import torch device = torch.device(\u0026#34;cuda\u0026#34; if torch.cuda.is_available() else \u0026#34;cpu\u0026#34;) print(device) path = \u0026#34;\u0026#34; E:\\Softwares\\anaconda\\envs\\RL\\lib\\site-packages\\tqdm\\auto.py:21: TqdmWarning: IProgress not found. Please update jupyter and ipywidgets. See https://ipywidgets.readthedocs.io/en/stable/user_install.html from .autonotebook import tqdm as notebook_tqdm cuda import numpy as np import pandas as pd import os train_file = os.path.join(path, \u0026#34;dataset/WA_Fn-UseC_-Telco-Customer-Churn.csv\u0026#34;) test_file = os.path.join(path, \u0026#34;dataset/u-churn-test.csv\u0026#34;) train_df = pd.read_csv(train_file) test_df = pd.read_csv(test_file) print(train_df.shape) print(test_df.shape) print(\u0026#34;Train Data Columns:\u0026#34;) print(train_df.columns.tolist()) (7043, 21) (1409, 20) Train Data Columns: ['customerID', 'gender', 'SeniorCitizen', 'Partner', 'Dependents', 'tenure', 'PhoneService', 'MultipleLines', 'InternetService', 'OnlineSecurity', 'OnlineBackup', 'DeviceProtection', 'TechSupport', 'StreamingTV', 'StreamingMovies', 'Contract', 'PaperlessBilling', 'PaymentMethod', 'MonthlyCharges', 'TotalCharges', 'Churn'] print(\u0026#34;\\nTrain Data Description:\u0026#34;) print(train_df.describe()) Train Data Description: SeniorCitizen tenure MonthlyCharges count 7043.000000 7043.000000 7043.000000 mean 0.162147 32.371149 64.761692 std 0.368612 24.559481 30.090047 min 0.000000 0.000000 18.250000 25% 0.000000 9.000000 35.500000 50% 0.000000 29.000000 70.350000 75% 0.000000 55.000000 89.850000 max 1.000000 72.000000 118.750000 可以看到，数据集的范围不大。在这种情况下特征工程的意义并不大。\nfrom sklearn.preprocessing import OneHotEncoder, StandardScaler # 拆分训练特征和标签 X_train = train_df.drop(columns=[\u0026#39;customerID\u0026#39;, \u0026#39;Churn\u0026#39;]) y_train = train_df[\u0026#39;Churn\u0026#39;].map({\u0026#39;Yes\u0026#39;: 1, \u0026#39;No\u0026#39;: 0}) # 将 Churn 转换为 0/1 # 从训练集中排除测试集中的 customerID（防止数据泄漏） mask = ~train_df[\u0026#39;customerID\u0026#39;].isin(test_df[\u0026#39;customerID\u0026#39;]) X_train = X_train[mask] y_train = y_train[mask] df_with_target = X_train.copy() df_with_target[\u0026#39;target\u0026#39;] = y_train corr_matrix = df_with_target.corr() target_corr = corr_matrix[\u0026#39;target\u0026#39;].drop(\u0026#39;target\u0026#39;) top_10_corr = target_corr.abs().sort_values(ascending=False).head(10) import seaborn as sns import matplotlib.pyplot as plt top_features = top_10_corr.index plt.figure(figsize=(8, 6)) sns.heatmap(df_with_target[top_features].corr(), annot=True, cmap=\u0026#39;YlGnBu\u0026#39;, fmt=\u0026#34;.2f\u0026#34;) plt.title(\u0026#34;Top 3 Features Most Correlated with Target\u0026#34;) plt.tight_layout() plt.show() # 识别类别特征和数值特征 categorical_features = X_train.select_dtypes(include=[\u0026#39;object\u0026#39;]).columns numerical_features = X_train.select_dtypes(exclude=[\u0026#39;object\u0026#39;]).columns # 独热编码器 encoder = OneHotEncoder(handle_unknown=\u0026#39;ignore\u0026#39;, sparse=False) X_train_cat_encoded = encoder.fit_transform(X_train[categorical_features]) X_train_cat_df = pd.DataFrame(X_train_cat_encoded, columns=encoder.get_feature_names_out(categorical_features)) # 合并数值特征与编码后的类别特征 X_train_final = pd.concat([X_train_cat_df, X_train[numerical_features].reset_index(drop=True)], axis=1) # 标准化数值特征 scaler = StandardScaler() X_train_final[numerical_features] = scaler.fit_transform(X_train_final[numerical_features]) # 处理测试集（与训练集相同方式） X_test = test_df.drop(columns=[\u0026#39;customerID\u0026#39;]) X_test_cat_encoded = encoder.transform(X_test[categorical_features]) X_test_cat_df = pd.DataFrame(X_test_cat_encoded, columns=encoder.get_feature_names_out(categorical_features)) X_test_final = pd.concat([X_test_cat_df, X_test[numerical_features].reset_index(drop=True)], axis=1) X_test_final[numerical_features] = scaler.transform(X_test_final[numerical_features]) 对热独立编码后的特征进行 pca\nfrom sklearn.decomposition import PCA # 将独热编码后的DataFrame转换为numpy数组 X_train_np = X_train_final.values pca = PCA(n_components=0.95) X_pca = pca.fit_transform(X_train_np) # 转换为PyTorch张量 X_tensor = torch.tensor(X_pca, dtype=torch.float32) y_tensor = torch.tensor(y_train.values.reshape(-1, 1), dtype=torch.float32) X_test_pca = pca.transform(X_test_final.values) X_test_tensor = torch.tensor(X_test_pca, dtype=torch.float32) import matplotlib.pyplot as plt # 提取前两个主成分 X_pca_2d = X_pca[:, :20] # 创建散点图 plt.figure(figsize=(8, 6)) scatter = plt.scatter(X_pca_2d[:, 0], X_pca_2d[:, 1], c=y_train, cmap=\u0026#39;viridis\u0026#39;, alpha=0.7) plt.xlabel(\u0026#39;Principal Component 1\u0026#39;) plt.ylabel(\u0026#39;Principal Component 2\u0026#39;) plt.title(\u0026#39;PCA 2D Visualization (95% Variance)\u0026#39;) plt.colorbar(scatter, label=\u0026#39;Target\u0026#39;) plt.grid(True) plt.tight_layout() plt.show() 使用简单逻辑回归模型 # import torch.nn as nn import torch.optim as optim # 逻辑回归模型 class ExpandedMLPModel(nn.Module): def __init__(self, input_dim): super(ExpandedMLPModel, self).__init__() self.hidden1 = nn.Linear(input_dim, 64) self.hidden2 = nn.Linear(64, 64) self.output = nn.Linear(64, 1) self.relu = nn.ReLU() self.sigmoid = nn.Sigmoid() self.dropout = nn.Dropout(0.5) def forward(self, x): x = self.relu(self.hidden1(x)) x = self.dropout(x) x = self.relu(self.hidden2(x)) x = self.dropout(x) x = self.sigmoid(self.output(x)) return x 使用 BCELoss() 交叉熵作为损失函数。\nimport torch import torch.nn as nn import torch.optim as optim from tqdm import tqdm import pandas as pd num_epochs = 140 learning_rate = 0.0005 # 初始化模型 input_dim = X_pca.shape[1] final_model = ExpandedMLPModel(input_dim) criterion = nn.BCELoss() optimizer = optim.Adam(final_model.parameters(), lr=learning_rate) print(\u0026#34;Training...\u0026#34;) train_losses = [] for epoch in tqdm(range(num_epochs), desc=\u0026#34;Training\u0026#34;): final_model.train() optimizer.zero_grad() outputs = final_model(X_tensor) loss = criterion(outputs, y_tensor) loss.backward() optimizer.step() train_losses.append(loss.item()) final_model.eval() with torch.no_grad(): test_outputs = final_model(X_test_tensor) test_predictions = (test_outputs.numpy() \u0026gt; 0.43).astype(int) # 自定义阈值为 0.43 # 生成提交结果 result_df = pd.DataFrame({ \u0026#39;customerID\u0026#39;: test_df[\u0026#39;customerID\u0026#39;], \u0026#39;Churn\u0026#39;: test_predictions.flatten() }) result_df[\u0026#39;Churn\u0026#39;] = result_df[\u0026#39;Churn\u0026#39;].map({1: \u0026#39;Yes\u0026#39;, 0: \u0026#39;No\u0026#39;}) result_df.to_csv(\u0026#39;output.csv\u0026#39;, index=False) print(\u0026#34;预测结果已保存到 output.csv\u0026#34;) Training... Training: 100%|██████████| 140/140 [00:07\u0026lt;00:00, 17.62it/s] 预测结果已保存到 output.csv 由于此数据集特征比较简单，因此出现了比较严重的过拟合。 一定的调参后好了一些。\n# 保存模型参数 torch.save(final_model.state_dict(), \u0026#39;logistic_regression_model.pth\u0026#39;) import matplotlib.pyplot as plt from sklearn.metrics import accuracy_score from sklearn.preprocessing import LabelEncoder final_model.eval() with torch.no_grad(): train_outputs = final_model(X_tensor) train_predictions = (train_outputs.numpy() \u0026gt; 0.43).astype(int) train_accuracy = accuracy_score(y_tensor.numpy(), train_predictions) merged_df = train_df[[\u0026#39;customerID\u0026#39;, \u0026#39;Churn\u0026#39;]].merge(result_df, on=\u0026#39;customerID\u0026#39;, suffixes=(\u0026#39;_true\u0026#39;, \u0026#39;_pred\u0026#39;)) y_true = merged_df[\u0026#39;Churn_true\u0026#39;] y_pred = merged_df[\u0026#39;Churn_pred\u0026#39;] # 使用 LabelEncoder 转换 \u0026#39;Yes\u0026#39;/\u0026#39;No\u0026#39; 为 0/1 le = LabelEncoder() y_true = le.fit_transform(y_true) y_pred = le.transform(y_pred) # 计算原始测试集准确率 original_test_accuracy = accuracy_score(y_true, y_pred) plt.figure(figsize=(12, 5)) # 训练损失曲线 plt.subplot(1, 2, 1) plt.plot(range(1, num_epochs + 1), train_losses, label=\u0026#34;Train Loss\u0026#34;, color=\u0026#34;blue\u0026#34;) plt.xlabel(\u0026#34;Epochs\u0026#34;) plt.ylabel(\u0026#34;Loss\u0026#34;) plt.title(\u0026#34;Training Loss Curve\u0026#34;) plt.legend() # 训练集 \u0026amp; 测试集准确率 plt.subplot(1, 2, 2) plt.bar([\u0026#34;Train Accuracy\u0026#34;, \u0026#34;Test Accuracy\u0026#34;], [train_accuracy, original_test_accuracy], color=[\u0026#34;blue\u0026#34;, \u0026#34;orange\u0026#34;]) plt.ylim(0, 1) plt.ylabel(\u0026#34;Accuracy\u0026#34;) plt.title(\u0026#34;Train vs. Test Accuracy\u0026#34;) # 显示图像 plt.tight_layout() plt.show() # 打印准确率 print(f\u0026#34;最终训练集准确率: {train_accuracy:.4f}\u0026#34;) print(f\u0026#34;测试集准确率: {original_test_accuracy:.4f}\u0026#34;) ​\n最终训练集准确率: 0.8575 测试集准确率: 0.8119 随机森林算法 # from sklearn.ensemble import RandomForestClassifier rf_model = RandomForestClassifier( n_estimators=150, max_depth=30, min_samples_split=10, min_samples_leaf=1, max_features=\u0026#39;sqrt\u0026#39;, random_state=42 ) rf_model.fit(X_train_final, y_train) test_predictions = rf_model.predict(X_test_final) result_df = pd.DataFrame({ \u0026#39;customerID\u0026#39;: test_df[\u0026#39;customerID\u0026#39;], \u0026#39;Churn\u0026#39;: test_predictions.flatten() }) import joblib joblib.dump(rf_model, \u0026#39;random_forest_model.pkl\u0026#39;) print(result_df.head()) customerID Churn 0 1024-GUALD 1 1 0484-JPBRU 0 2 3620-EHIMZ 0 3 6910-HADCM 1 4 8587-XYZSF 0 GridSearchCV 搜索较优参数。\nfrom sklearn.model_selection import GridSearchCV param_grid = { \u0026#39;n_estimators\u0026#39;: [100, 200, 300], \u0026#39;max_depth\u0026#39;: [10, 20, 30], \u0026#39;min_samples_split\u0026#39;: [2, 5, 10], \u0026#39;min_samples_leaf\u0026#39;: [1, 3, 5], \u0026#39;max_features\u0026#39;: [\u0026#39;sqrt\u0026#39;, \u0026#39;log2\u0026#39;], \u0026#39;class_weight\u0026#39;: [\u0026#39;balanced\u0026#39;, None] } grid_search = GridSearchCV( estimator=RandomForestClassifier(random_state=42), param_grid=param_grid, cv=2, scoring=\u0026#39;accuracy\u0026#39;, n_jobs=-1, verbose=1 ) grid_search.fit(X_train_final, y_train) best_model = grid_search.best_estimator_ print(\u0026#34;最佳参数：\u0026#34;, grid_search.best_params_) Fitting 2 folds for each of 324 candidates, totalling 648 fits from sklearn.preprocessing import LabelEncoder from sklearn.metrics import accuracy_score merged_df = train_df[[\u0026#39;customerID\u0026#39;, \u0026#39;Churn\u0026#39;]].merge(result_df, on=\u0026#39;customerID\u0026#39;, suffixes=(\u0026#39;_true\u0026#39;, \u0026#39;_pred\u0026#39;)) y_true = merged_df[\u0026#39;Churn_true\u0026#39;] y_pred = merged_df[\u0026#39;Churn_pred\u0026#39;] # 使用 LabelEncoder 转换 \u0026#39;Yes\u0026#39;/\u0026#39;No\u0026#39; 为 0/1 le = LabelEncoder() y_true = le.fit_transform(y_true) # 计算准确率 original_test_accuracy = accuracy_score(y_true, y_pred) print(f\u0026#34;测试集准确率: {original_test_accuracy:.4f}\u0026#34;) 测试集准确率: 0.7999 SVM 算法 # from sklearn.svm import SVC from sklearn.metrics import accuracy_score, classification_report svm_clf = SVC(kernel=\u0026#39;linear\u0026#39;, C=0.5, gamma=\u0026#39;scale\u0026#39;) svm_clf.fit(X_pca, y_train.values.ravel()) y_pred = svm_clf.predict(X_test_pca) result_df = pd.DataFrame({ \u0026#39;customerID\u0026#39;: test_df[\u0026#39;customerID\u0026#39;], \u0026#39;Churn\u0026#39;: y_pred.flatten() }) GridSearchCV 暴力参数\nfrom sklearn.model_selection import GridSearchCV from sklearn.svm import SVC param_grid = { \u0026#39;C\u0026#39;: [0.1, 1, 10, 100], \u0026#39;gamma\u0026#39;: [\u0026#39;scale\u0026#39;, \u0026#39;auto\u0026#39;, 0.01, 0.001], \u0026#39;kernel\u0026#39;: [\u0026#39;rbf\u0026#39;, \u0026#39;linear\u0026#39;] } svc = SVC() grid_search = GridSearchCV(estimator=svc, param_grid=param_grid, cv=2, scoring=\u0026#39;accuracy\u0026#39;, verbose=2, n_jobs=-1) grid_search.fit(X_pca, y_train.values.ravel()) print(\u0026#34;最佳参数组合:\u0026#34;, grid_search.best_params_) Fitting 2 folds for each of 32 candidates, totalling 64 fits 最佳参数组合: {'C': 0.1, 'gamma': 'scale', 'kernel': 'linear'} from sklearn.preprocessing import LabelEncoder from sklearn.metrics import accuracy_score import joblib model_path = \u0026#39;model/svm_model.pkl\u0026#39; joblib.dump(svm_clf, model_path) print(f\u0026#34;模型已保存到 {model_path}\u0026#34;) merged_df = train_df[[\u0026#39;customerID\u0026#39;, \u0026#39;Churn\u0026#39;]].merge(result_df, on=\u0026#39;customerID\u0026#39;, suffixes=(\u0026#39;_true\u0026#39;, \u0026#39;_pred\u0026#39;)) y_true = merged_df[\u0026#39;Churn_true\u0026#39;] y_pred = merged_df[\u0026#39;Churn_pred\u0026#39;] # 使用 LabelEncoder 转换 \u0026#39;Yes\u0026#39;/\u0026#39;No\u0026#39; 为 0/1 le = LabelEncoder() y_true = le.fit_transform(y_true) original_test_accuracy = accuracy_score(y_true, y_pred) print(f\u0026#34;测试集准确率: {original_test_accuracy:.4f}\u0026#34;) 模型已保存到 model/svm_model.pkl 测试集准确率: 0.8204 混合模型 # 读取 MLP、随机森林、SVM 三种模型。\ninput_dim = X_pca.shape[1] model = ExpandedMLPModel(input_dim=input_dim) model.load_state_dict(torch.load(\u0026#39;model/logistic_regression_model.pth\u0026#39;)) \u0026lt;All keys matched successfully\u0026gt; import joblib rf_model = joblib.load(\u0026#34;model/random_forest_model.pkl\u0026#34;) svm_clf = joblib.load(\u0026#34;model/svm_model.pkl\u0026#34;) 为三个模型的输出添加一个融合层。\nimport torch.nn as nn class WeightedEnsemble(nn.Module): def __init__(self): super(WeightedEnsemble, self).__init__() # 可学习的权重参数（初始化为相等） self.weights = nn.Parameter(torch.ones(3)) self.sigmoid = nn.Sigmoid() def forward(self, mlp_out, svm_out, rf_out): # 拼接为一个 tensor: [N, 3] all_outputs = torch.cat([mlp_out, svm_out, rf_out], dim=1) # softmax 归一化权重 normalized_weights = torch.softmax(self.weights, dim=0) weighted_sum = torch.matmul(all_outputs, normalized_weights.view(-1, 1)) return self.sigmoid(weighted_sum) # MLP 模型输出 mlp_output = model(X_tensor).detach() # shape: [N, 1] # SVM 输出 svm_output = torch.tensor(svm_clf.decision_function(X_pca).reshape(-1, 1), dtype=torch.float32) # RF 输出 rf_output = torch.tensor(rf_model.predict_proba(X_train_final)[:, 1].reshape(-1, 1), dtype=torch.float32) 训练融合模型\nfrom torch.utils.data import TensorDataset, DataLoader ensemble_inputs = TensorDataset(mlp_output, svm_output, rf_output, y_tensor) ensemble_loader = DataLoader(ensemble_inputs, batch_size=32, shuffle=True) # 初始化融合模型 ensemble_model = WeightedEnsemble() criterion = nn.BCELoss() optimizer = torch.optim.Adam(ensemble_model.parameters(), lr=0.01) for epoch in range(20): total_loss = 0 for mlp_out, svm_out, rf_out, labels in ensemble_loader: optimizer.zero_grad() outputs = ensemble_model(mlp_out, svm_out, rf_out) loss = criterion(outputs, labels) loss.backward() optimizer.step() total_loss += loss.item() # 获取测试集的三个模型输出 mlp_test_out = model(X_test_tensor).detach() svm_test_out = torch.tensor(svm_clf.decision_function(X_test_pca).reshape(-1, 1), dtype=torch.float32) rf_test_out = torch.tensor(rf_model.predict_proba(X_test_final)[:, 1].reshape(-1, 1), dtype=torch.float32) # 使用融合模型预测 ensemble_model.eval() with torch.no_grad(): final_output = ensemble_model(mlp_test_out, svm_test_out, rf_test_out) 输出可视化，分别为三种模型的输出分布于散点图。\nimport matplotlib.pyplot as plt import seaborn as sns import torch mlp_out = mlp_test_out.numpy().flatten() svm_out = svm_test_out.numpy().flatten() rf_out = rf_test_out.numpy().flatten() ens_out = final_output.numpy().flatten() # 可视化每个模型输出的分布 plt.figure(figsize=(10, 6)) sns.kdeplot(mlp_out, label=\u0026#39;MLP Output\u0026#39;, fill=True) sns.kdeplot(svm_out, label=\u0026#39;SVM Output\u0026#39;, fill=True) sns.kdeplot(rf_out, label=\u0026#39;Random Forest Output\u0026#39;, fill=True) sns.kdeplot(ens_out, label=\u0026#39;Ensemble Output\u0026#39;, fill=True, linestyle=\u0026#39;--\u0026#39;) plt.title(\u0026#39;Model Output Distribution on Test Set\u0026#39;) plt.xlabel(\u0026#39;Model Output\u0026#39;) plt.ylabel(\u0026#39;Density\u0026#39;) plt.legend() plt.grid(True) plt.tight_layout() plt.show() from mpl_toolkits.mplot3d import Axes3D import matplotlib.pyplot as plt fig = plt.figure(figsize=(10, 8)) ax = fig.add_subplot(111, projection=\u0026#39;3d\u0026#39;) # 绘制 3D 散点图 sc = ax.scatter( mlp_out, svm_out, rf_out, c=ens_out, cmap=\u0026#39;coolwarm\u0026#39;, alpha=0.8, edgecolors=\u0026#39;k\u0026#39;, s=40 ) ax.set_xlabel(\u0026#39;MLP Output\u0026#39;) ax.set_ylabel(\u0026#39;SVM Output\u0026#39;) ax.set_zlabel(\u0026#39;RF Output\u0026#39;) ax.set_title(\u0026#39;3D Scatter of Base Model Outputs\\n(Colored by Ensemble Output)\u0026#39;) cbar = fig.colorbar(sc, ax=ax, pad=0.1) cbar.set_label(\u0026#39;Ensemble Output\u0026#39;) plt.tight_layout() plt.show() C:\\Users\\walter\\AppData\\Local\\Temp\\ipykernel_29780\\831797772.py:27: MatplotlibDeprecationWarning: Auto-removal of grids by pcolor() and pcolormesh() is deprecated since 3.5 and will be removed two minor releases later; please call grid(False) first. cbar = fig.colorbar(sc, ax=ax, pad=0.1) import pandas as pd y_pred = final_output.numpy() y_pred_class = (y_pred \u0026gt; 0.5).astype(int) result_df = pd.DataFrame({ \u0026#39;customerID\u0026#39;: test_df[\u0026#39;customerID\u0026#39;].values, \u0026#39;Churn\u0026#39;: y_pred_class.flatten() }) result_df.to_csv(\u0026#34;final_predictions.csv\u0026#34;, index=False) print(\u0026#34;预测结果已保存为 final_predictions.csv\u0026#34;) 预测结果已保存为 final_predictions.csv from sklearn.preprocessing import LabelEncoder from sklearn.metrics import accuracy_score merged_df = train_df[[\u0026#39;customerID\u0026#39;, \u0026#39;Churn\u0026#39;]].merge(result_df, on=\u0026#39;customerID\u0026#39;, suffixes=(\u0026#39;_true\u0026#39;, \u0026#39;_pred\u0026#39;)) y_true = merged_df[\u0026#39;Churn_true\u0026#39;] y_pred = merged_df[\u0026#39;Churn_pred\u0026#39;] le = LabelEncoder() y_true = le.fit_transform(y_true) original_test_accuracy = accuracy_score(y_true, y_pred) print(f\u0026#34;测试集准确率: {original_test_accuracy:.4f}\u0026#34;) 测试集准确率: 0.8421 五、总结 # 本实验展示了从数据预处理、特征工程、模型设计与训练到融合策略的完整流程。\n在实际项目中，融合模型不仅可以提高准确率，也提高了模型鲁棒性。\n未来可以进一步尝试如 XGBoost、LightGBM、Stacking 等策略进一步提升模型表现。\n","date":"2025 年 1 月 11 日","externalUrl":null,"permalink":"/posts/customer_churn/","section":"","summary":"","title":"kaggle 顾客流失：课程报告","type":"posts"},{"content":"","date":"2025 年 1 月 11 日","externalUrl":null,"permalink":"/tags/%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/","section":"","summary":"","title":"分类任务","type":"tags"},{"content":"","date":"2025 年 1 月 11 日","externalUrl":null,"permalink":"/tags/%E8%AF%BE%E7%A8%8B%E6%8A%A5%E5%91%8A/","section":"","summary":"","title":"课程报告","type":"tags"},{"content":" 本博客为 kaggle 房价预测 的代码和实验报告，并融合自己的心得。\n本实验在 23 年做过一次。25年 必修课程要求 写报告而有了些新的感悟。\n实验报告格式根据 智能算法综合实践 课程要求。\n比赛界面：房价预测\n我的开源 jupyter notebook ：线性回归 ，MLP 和多种优化\n一、前言 # 我想将 jupyter notebook 的输出汇总到本报告之中，但转化无法避免的导致排版略显杂乱，请理解。\n本实验报告很大一部分是由 jupyter notebook 转化 md 而得到的：\njupyter nbconvert name.ipynb --to markdown 而 word 版本使用了：\npandoc name.md -o output.docx 网络搭建部分参考了李沐老师的波士顿房价预测实例。\n二、实验目的 # 在 Kaggle 房价预测竞赛中构建模型并优化性能。\n掌握数据预处理、特征工程及回归任务建模方法。\n熟悉 PyTorch 的基本操作，包括数据处理、模型训练与评估。\n其中关于 PyTorch 操作，借由本次实验我进行了一定程度的总结，见我的博客：pytorch 总结\n三、实验原理与实验步骤 # 线性回归 # 显然该问题是一个回归问题，先试一下最简单的线性回归。\n线性回归在现在的 pytorch 中框架非常简单，几乎一个 nn.linear() 就能解决。\n对数据进行一定的操作：\n对 features 进行归一化，这几乎在任何线性回归任务中都是必须的。\n该题最终检测的是 RMSE，但经过我的测试，loss 用 nn.MSELoss() 仍是最佳的。\n因此为了使检测数据更加直观，要手写一个 RMSE 用于检测输出。\nRMSE 是 MSE 开方后的值，它的最优点与 MSE 一致，只是数值上有非线性变化（平方根）。\n该题的输入样式很多，包括 bool，int，float 等，要将其统一到 tensor 中。\n将 bool 值进行热编码。\n为了检验拟合情况，使用了 K 折交叉检验（这为我判断是否过拟合起到了很大的帮助）\n此外，为了直观观察 loss 下降，我也做了适配 RMSE 的绘图。\n此方案提交后的结果为 ：0.149，排名大致为 2000 / 3700\nMLP 与优化 # 在线性回归之后，很正常的思路是将模型扩大，即使用 MLP 进行学习。\n当然，使用 MLP 就代表要使用 cuda 加速，需要修改 to(device) 。\n但在仅修改 MLP 后，最后效果却反而不如线性回归，原因有以下几点：\n出现了严重的过拟合，MLP 神经元较多导致学习了很多不相干特征的。 实际损失函数 MSE 在不同房价基础上的表现有所差异。 对于第二点，我尝试过用 RMSE 做损失函数，但效果并不好。\n为了修改 MSE 的表现需要将 label 进行归一化，并在实际预测时进行反归一化。\n对于第一点，修改分成的两部分：\n适当缩小 MLP 的神经元数量、dropout 设置为 0.5、加入 L2 正则化。 对输入进行主成分分析（具体可视化在 MLP 一节的特征工程小节），选取了前 100 个主成分（累计贡献 98%）。 当然，修改过后还有一定的过拟合现象，但并不严重。\n此方案提交后的结果为 ：0.122，排名大致为 250 / 3700\n如果进行仔细的调参，还有一定的提升空间。\n特征工程 # 在参考排行榜头部 notebook 后，我发现此题最重要的部分是特征工程。\n即使上一部分中，我使用了主成分分析，但仍远远不如直接从特征出发。\n参考大量他人文档，引用了高分公开测试集，经过一定的参数调整后，得到结果如下。\n但我个人认为，这种针对数据集的调整的泛用性不一定强。因此在大部分实际工作中，并不具有普遍性。\n四、具体实验 # 简单线性回归 # 首先检查 input # 特别是训练集和测试集的 shape\n# This Python 3 environment comes with many helpful analytics libraries installed # It is defined by the kaggle/python Docker image: https://github.com/kaggle/docker-python # For example, here\u0026#39;s several helpful packages to load import numpy as np # linear algebra import pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv) # Input data files are available in the read-only \u0026#34;../input/\u0026#34; directory # For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory import os for dirname, _, filenames in os.walk(\u0026#39;/kaggle/input\u0026#39;): for filename in filenames: print(os.path.join(dirname, filename)) # You can write up to 20GB to the current directory (/kaggle/working/) that gets preserved as output when you create a version using \u0026#34;Save \u0026amp; Run All\u0026#34; # You can also write temporary files to /kaggle/temp/, but they won\u0026#39;t be saved outside of the current session /kaggle/input/house-prices-advanced-regression-techniques/sample_submission.csv /kaggle/input/house-prices-advanced-regression-techniques/data_description.txt /kaggle/input/house-prices-advanced-regression-techniques/train.csv /kaggle/input/house-prices-advanced-regression-techniques/test.csv train_data = pd.read_csv(\u0026#34;/kaggle/input/house-prices-advanced-regression-techniques/train.csv\u0026#34;) test_data = pd.read_csv(\u0026#34;/kaggle/input/house-prices-advanced-regression-techniques/test.csv\u0026#34;) print(\u0026#34;Train Data Shape:\u0026#34;, train_data.shape) print(\u0026#34;Test Data Shape:\u0026#34;, test_data.shape) Train Data Shape: (1460, 81) Test Data Shape: (1459, 80) 进行特征工程 # 将 input 进行 transform\n# 检查列名 print(train_data.iloc[0, :]) print(\u0026#34;-------------\u0026#34;) print(test_data.iloc[0, :]) # 其中 test_data 没有最后的 SalePrice Id 1 MSSubClass 60 MSZoning RL LotFrontage 65.0 LotArea 8450 ... MoSold 2 YrSold 2008 SaleType WD SaleCondition Normal SalePrice 208500 Name: 0, Length: 81, dtype: object ------------- Id 1461 MSSubClass 20 MSZoning RH LotFrontage 80.0 LotArea 11622 ... MiscVal 0 MoSold 6 YrSold 2010 SaleType WD SaleCondition Normal Name: 0, Length: 80, dtype: object 显然 id 这一列对数据预测没有实际意义\n对特征进行整合，并准备进行特征工程\nfeatures = pd.concat((train_data.iloc[:, 1:-1], test_data.iloc[:, 1:])) print(features.shape) print(\u0026#34;--------\u0026#34;) print(features.iloc[0, :]) (2919, 79) -------- MSSubClass 60 MSZoning RL LotFrontage 65.0 LotArea 8450 Street Pave ... MiscVal 0 MoSold 2 YrSold 2008 SaleType WD SaleCondition Normal Name: 0, Length: 79, dtype: object 将数组进行归一化，如公式所示 $$ (x - \\mu) / \\sigma$$\n# numeric_features 是特征中非对象类型（即整数与浮点数）的 index numeric_features = features.dtypes[features.dtypes != \u0026#39;object\u0026#39;].index features[numeric_features] = features[numeric_features].apply( lambda x: (x - x.mean()) / (x.std())) # 在标准化数据之后，所有均值消失。因此我们可以将缺失值设置为 0 features[numeric_features] = features[numeric_features].fillna(0) # 接下来处理布尔值。dummy_na 表示是否单独提出 nan 在新版本下，get_dummies 会转化为 uint8\n但 uint8 不能转化为 numpy，因此要使用 dtype=int\nfeatures = pd.get_dummies(features, dummy_na=True, dtype=int) features.shape (2919, 330) from torch import nn import torch n_train = train_data.shape[0] # 强制将 object 转为 float64 # features = features.astype(str) # 先将所有列转换为字符串 # features = features.apply(pd.to_numeric, errors=\u0026#39;coerce\u0026#39;) print(features[:].to_numpy().dtype) train_features = torch.tensor(features[:n_train].values, dtype=torch.float32) test_features = torch.tensor(features[n_train:].values, dtype=torch.float32) train_labels = torch.tensor( train_data.SalePrice.values.reshape(-1, 1), dtype=torch.float32) float64 下面开始进行线性回归训练，选择 MSE 做 loss。\n为了方便对比其他模型，线性回归是一个好的 baseline。\nloss = nn.MSELoss() input_features = features.shape[1] # 其中 shape[1] 是列数，也就是特征数 def get_net(): net = nn.Sequential(nn.Linear(input_features,1)) return net 然而，房价的差异在自身房价不同的情况下，不能直接用 abs(target - predict) 直接代表误差\n此题官方使用的是 $$ \\sqrt {\\frac {1}{n} \\sum _ {i=1}^ {n} (\\log y_ {i}-\\log _ {y}i)^ {2} }$$ .\n即 均方根对数误差（RMSLE）\n而其配合 MSE 就是 均方根对数误差（MSLE）\n此外，为保证均方根的合理性，要将 tensor 切割在 (1, inf) 之间\nnumpy 的 clip() 和 tensor 的 clamp() 作用相同\ndef log_rmse(net, features, labels): # 为了在取对数时进一步稳定该值，将小于1的值设置为1 clipped_preds = torch.clamp(net(features), 1, float(\u0026#39;inf\u0026#39;)) rmse = torch.sqrt(loss(torch.log(clipped_preds), torch.log(labels))) return rmse.item() # 将 tensor 标量化 下面开始训练代码\nfrom torch.utils.data import TensorDataset, DataLoader def train(net, train_features, train_labels, test_features, test_labels, num_epochs, learning_rate, weight_decay, batch_size): train_ls, test_ls = [], [] # 用 Dataset 和 DataLoader 进行打包 dataset = TensorDataset(train_features, train_labels) train_iter = DataLoader(dataset, batch_size=batch_size, shuffle=True) optimizer = torch.optim.Adam(net.parameters(), lr = learning_rate, weight_decay = weight_decay) # 传入 weight_decay 从而方便进行 L2 正则化 for epoch in range(num_epochs): for X, y in train_iter: optimizer.zero_grad() l = loss(net(X), y) l.backward() optimizer.step() train_ls.append(log_rmse(net, train_features, train_labels)) # 记录训练 loss if test_labels is not None: test_ls.append(log_rmse(net, test_features, test_labels)) # 记录测试 loss return train_ls, test_ls K 折交叉检验 # 由于数据量较小，可以使用 K 折检验，使得模型更稳定\nimport matplotlib.pyplot as plt # 划分 K 折交叉验证数据集 def get_k_fold_data(k, fold_idx, X, y): assert k \u0026gt; 1 fold_size = X.shape[0] // k # 每折数据大小 X_valid = X[fold_idx * fold_size: (fold_idx + 1) * fold_size, :] y_valid = y[fold_idx * fold_size: (fold_idx + 1) * fold_size] # 训练集由剩余 k-1 份数据组成 （即 留一法） X_train_parts = [] y_train_parts = [] for i in range(k): if i == fold_idx: continue X_part = X[i * fold_size: (i + 1) * fold_size, :] y_part = y[i * fold_size: (i + 1) * fold_size] X_train_parts.append(X_part) y_train_parts.append(y_part) # 拼接所有训练集部分 X_train = torch.cat(X_train_parts, dim=0) # dim = 0 表示按照行合并 y_train = torch.cat(y_train_parts, dim=0) return X_train, y_train, X_valid, y_valid # 执行 k 折检验 def k_fold(k, X_train, y_train, num_epochs, lr, weight_decay, batch_size): train_loss_sum, valid_loss_sum = 0, 0 for fold in range(k): # 进行 K 次留一法 X_tr, y_tr, X_val, y_val = get_k_fold_data(k, fold, X_train, y_train) net = get_net() train_ls, valid_ls = train(net, X_tr, y_tr, X_val, y_val, num_epochs, lr, weight_decay, batch_size) # 记录 loss_sum （只记录训练每折训练结束的 loss） train_loss_sum += train_ls[-1] valid_loss_sum += valid_ls[-1] # 仅在第一折时绘制损失曲线 if fold == 0: # 画图 plt.plot(range(1, num_epochs + 1), train_ls, label=\u0026#39;train\u0026#39;) # 训练损失 plt.plot(range(1, num_epochs + 1), valid_ls, label=\u0026#39;valid\u0026#39;) # 验证损失 plt.xlabel(\u0026#39;epoch\u0026#39;) plt.ylabel(\u0026#39;rmse\u0026#39;) plt.xlim([1, num_epochs]) plt.yscale(\u0026#39;log\u0026#39;, base=2) # y 轴使用对数尺度 plt.legend() plt.show() print(f\u0026#39;折 {fold + 1}，训练 log rmse: {float(train_ls[-1]):.6f}, \u0026#39; f\u0026#39;验证 log rmse: {float(valid_ls[-1]):.6f}\u0026#39;) return train_loss_sum / k, valid_loss_sum / k 调配参数 # num_epochs = 500 k = 3 lr = 2 weight_decay = 1e-3 batch_size = 128 train_l, valid_l = k_fold(k, train_features, train_labels, num_epochs, lr, weight_decay, batch_size) print(f\u0026#39;{k}-折验证: 平均训练log rmse: {float(train_l):f}, \u0026#39; f\u0026#39;平均验证log rmse: {float(valid_l):f}\u0026#39;) ​\n折 1，训练 log rmse: 0.169430, 验证 log rmse: 0.160753 折 2，训练 log rmse: 0.159886, 验证 log rmse: 0.173186 折 3，训练 log rmse: 0.160932, 验证 log rmse: 0.172761 3-折验证: 平均训练log rmse: 0.163416, 平均验证log rmse: 0.168900 保存为 CSV # 不同于上面的 K 折检验, 在实际提交 kaggle 时，要将所有的训练集传入训练\ndef train_and_pred(train_features, test_features, train_labels, test_data, num_epochs, lr, weight_decay, batch_size): net = get_net() train_ls, _ = train(net, train_features, train_labels, None, None, num_epochs, lr, weight_decay, batch_size) plt.plot(range(1, num_epochs + 1), train_ls, label=\u0026#39;train\u0026#39;) # 训练损失 plt.xlabel(\u0026#39;epoch\u0026#39;) plt.ylabel(\u0026#39;rmse\u0026#39;) plt.xlim([1, num_epochs]) plt.yscale(\u0026#39;log\u0026#39;, base=2) # y 轴使用对数尺度 plt.legend() plt.show() print(f\u0026#39;训练log rmse：{float(train_ls[-1]):f}\u0026#39;) # 将网络应用于测试集。 preds = net(test_features).detach().numpy() # 将 tensor 不在跟踪梯度，并转为标量 # 将其重新格式化以导出到 CSV 格式 test_data[\u0026#39;SalePrice\u0026#39;] = pd.Series(preds.reshape(1, -1)[0]) submission = pd.concat([test_data[\u0026#39;Id\u0026#39;], test_data[\u0026#39;SalePrice\u0026#39;]], axis=1) # 只保留 id 和预测价格 submission.to_csv(\u0026#39;submission.csv\u0026#39;, index=False) num_epochs = 1500 lr = 2 weight_decay = 1e-3 batch_size = 128 train_and_pred(train_features, test_features, train_labels, test_data, num_epochs, lr, weight_decay, batch_size) ​\n训练log rmse：0.124836 MLP 和多种优化 # 单独一个线性层的成绩并不好\n将单独的线性层换成多重感知机\n# 测试 cuda import torch device = torch.device(\u0026#34;cuda\u0026#34; if torch.cuda.is_available() else \u0026#34;cpu\u0026#34;) print(device) cuda 进行特征工程 # 将 input 进行 transform\n# 检查列名 print(train_data.iloc[0, :]) print(\u0026#34;-------------\u0026#34;) print(test_data.iloc[0, :]) # 其中 test_data 没有最后的 SalePrice Id 1 MSSubClass 60 MSZoning RL LotFrontage 65.0 LotArea 8450 ... MoSold 2 YrSold 2008 SaleType WD SaleCondition Normal SalePrice 208500 Name: 0, Length: 81, dtype: object ------------- Id 1461 MSSubClass 20 MSZoning RH LotFrontage 80.0 LotArea 11622 ... MiscVal 0 MoSold 6 YrSold 2010 SaleType WD SaleCondition Normal Name: 0, Length: 80, dtype: object 显然 id 这一列对数据预测没有实际意义\n对特征进行整合，并准备进行特征工程\nfeatures = pd.concat((train_data.iloc[:, 1:-1], test_data.iloc[:, 1:])) print(features.shape) print(\u0026#34;--------\u0026#34;) print(features.iloc[0, :]) (2919, 79) -------- MSSubClass 60 MSZoning RL LotFrontage 65.0 LotArea 8450 Street Pave ... MiscVal 0 MoSold 2 YrSold 2008 SaleType WD SaleCondition Normal Name: 0, Length: 79, dtype: object 将数组进行归一化，如公式所示 $$ (x - \\mu) / \\sigma$$\n# numeric_features 是特征中非对象类型（即整数与浮点数）的 index numeric_features = features.dtypes[features.dtypes != \u0026#39;object\u0026#39;].index features[numeric_features] = features[numeric_features].apply( lambda x: (x - x.mean()) / (x.std())) # 在标准化数据之后，所有均值消失。因此我们可以将缺失值设置为 0 features[numeric_features] = features[numeric_features].fillna(0) 在新版本下，get_dummies 会转化为 uint8\n但 uint8 不能转化为 numpy，因此要使用 dtype=int\n# 接下来处理布尔值。dummy_na 表示是否单独提出 nan features = pd.get_dummies(features, dummy_na=True, dtype=int) features.shape (2919, 330) 进行主成分分析，并划分训练集、测试集\nfrom torch import nn from sklearn.decomposition import PCA import torch n_train = train_data.shape[0] # 强制将 object 转为 float64 # features = features.astype(str) # 先将所有列转换为字符串 # features = features.apply(pd.to_numeric, errors=\u0026#39;coerce\u0026#39;) pca = PCA(n_components=100) features_pca = pca.fit_transform(features) print(features_pca.shape) train_features = torch.tensor(features[:n_train].values, dtype=torch.float32) test_features = torch.tensor(features[n_train:].values, dtype=torch.float32) (2919, 100) 对主成分分析进行可视化，看一下累计贡献图\nimport seaborn as sns import matplotlib.pyplot as plt explained_variance_ratio = np.cumsum(pca.explained_variance_ratio_) # 图一 累计主成分贡献图 plt.figure(figsize=(10, 6)) plt.plot(range(1, 101), explained_variance_ratio, marker=\u0026#39;o\u0026#39;, linestyle=\u0026#39;--\u0026#39;, color=\u0026#39;b\u0026#39;) plt.xlabel(\u0026#34;Number of Principal Components\u0026#34;) plt.ylabel(\u0026#34;Cumulative Explained Variance Ratio\u0026#34;) plt.title(\u0026#34;PCA Cumulative Explained Variance\u0026#34;) plt.grid() plt.axhline(y=0.80, color=\u0026#39;r\u0026#39;, linestyle=\u0026#39;--\u0026#39;, label=\u0026#34;80% Explained Variance\u0026#34;) plt.axhline(y=0.90, color=\u0026#39;g\u0026#39;, linestyle=\u0026#39;--\u0026#39;, label=\u0026#34;90% Explained Variance\u0026#34;) plt.legend() plt.show() # 图二 具体成果贡献图 explained_variance = pca.explained_variance_ratio_ top_10_components = np.argsort(explained_variance)[-20:][::-1] loadings = pd.DataFrame(pca.components_, columns=features.columns, index=[f\u0026#34;PC{i+1}\u0026#34; for i in range(100)]) top_10_loadings = loadings.iloc[top_10_components] top_20_features = top_10_loadings.abs().sum().nlargest(40).index top_10_loadings = top_10_loadings[top_20_features] plt.figure(figsize=(14, 8)) sns.heatmap(top_10_loadings, cmap=\u0026#34;coolwarm\u0026#34;, annot=False, linewidths=0.5) plt.xlabel(\u0026#34;Top 40 Most Important Features\u0026#34;) plt.ylabel(\u0026#34;Top 20 Principal Components\u0026#34;) plt.title(\u0026#34;Feature Contributions to Top 10 Principal Components\u0026#34;) plt.show() ​ ​\n# 计算均值和标准差 sale_price = np.array(train_data.SalePrice.values, dtype=np.float32).reshape(-1, 1) mean = sale_price.mean() std = sale_price.std() normalized = (sale_price - mean) / std # 转换为 PyTorch Tensor train_labels = torch.from_numpy(normalized) print(train_labels) tensor([[ 0.3473], [ 0.0073], [ 0.5362], ..., [ 1.0776], [-0.4885], [-0.4208]]) 模型搭建 # 下面开始进行线性回归训练，选择 MSE 做 loss。\n为了方便对比其他模型，线性回归是一个好的 baseline。\nloss = nn.MSELoss() input_features = features.shape[1] # 其中 shape[1] 是列数，也就是特征数 def get_net(): net = nn.Sequential( nn.Linear(input_features, 256), nn.ReLU(), nn.Dropout(0.5), nn.Linear(256, 64), nn.ReLU(), nn.Dropout(0.5), nn.Linear(64, 1) ) return net 然而，房价的差异在自身房价不同的情况下，不能直接用 abs(target - predict) 直接代表误差\n此题官方使用的是 $$ \\sqrt {\\frac {1}{n} \\sum _ {i=1}^ {n} (\\log y_ {i}-\\log _ {y}i)^ {2} }$$ .\n即 均方根对数误差（RMSLE）\n而其配合 MSE 就是 均方根对数误差（MSLE）\n此外，为保证均方根的合理性，要将 tensor 切割在 (1, inf) 之间\nnumpy 的 clip() 和 tensor 的 clamp() 作用相同\ndef log_rmse(net, features, labels, device): # 为了在取对数时进一步稳定该值，将小于 1 的值设置为 1 features, labels = features.to(device), labels.to(device) # 只添加这一行 test_labels = (labels.clone() * std) + mean clipped_preds = torch.clamp(net(features).clone() * std + mean, 1, float(\u0026#39;inf\u0026#39;)) rmse = torch.sqrt(loss(torch.log(clipped_preds), torch.log(test_labels))) return rmse.item() 下面开始训练代码\nfrom torch.utils.data import TensorDataset, DataLoader from tqdm import tqdm def train(net, train_features, train_labels, test_features, test_labels, num_epochs, learning_rate, weight_decay, batch_size, device): net.to(device) train_features, train_labels = train_features.to(device), train_labels.to(device) if test_features is not None and test_labels is not None: test_features, test_labels = test_features.to(device), test_labels.to(device) train_ls, test_ls = [], [] # 用 Dataset 和 DataLoader 进行打包 dataset = TensorDataset(train_features, train_labels) train_iter = DataLoader(dataset, batch_size=batch_size, shuffle=True) optimizer = torch.optim.Adam(net.parameters(), lr=learning_rate, weight_decay=weight_decay) for epoch in tqdm(range(num_epochs), desc=\u0026#34;Training\u0026#34;): net.train() # 进入训练模式 for X, y in train_iter: X, y = X.to(device), y.to(device) # 确保数据在 GPU 上 optimizer.zero_grad() l = loss(net(X), y) # 计算损失 l.backward() optimizer.step() # 记录训练损失 net.eval() train_ls.append(log_rmse(net, train_features, train_labels, device)) # 确保 loss 计算时数据在 GPU 上 if test_labels is not None: test_ls.append(log_rmse(net, test_features, test_labels, device)) return train_ls, test_ls K 折交叉检验 # import matplotlib.pyplot as plt # 划分 K 折交叉验证数据集 def get_k_fold_data(k, fold_idx, X, y): assert k \u0026gt; 1 fold_size = X.shape[0] // k # 每折数据大小 X_valid = X[fold_idx * fold_size: (fold_idx + 1) * fold_size, :] y_valid = y[fold_idx * fold_size: (fold_idx + 1) * fold_size] # 训练集由剩余 k-1 份数据组成 （即 留一法） X_train_parts = [] y_train_parts = [] for i in range(k): if i == fold_idx: continue X_part = X[i * fold_size: (i + 1) * fold_size, :] y_part = y[i * fold_size: (i + 1) * fold_size] X_train_parts.append(X_part) y_train_parts.append(y_part) # 拼接所有训练集部分 X_train = torch.cat(X_train_parts, dim=0) # dim = 0 表示按照行合并 y_train = torch.cat(y_train_parts, dim=0) return X_train, y_train, X_valid, y_valid # 执行 k 折检验 def k_fold(k, X_train, y_train, num_epochs, lr, weight_decay, batch_size, device): train_loss_sum, valid_loss_sum = 0, 0 for fold in range(k): # 进行 K 次留一法 X_tr, y_tr, X_val, y_val = get_k_fold_data(k, fold, X_train, y_train) net = get_net() train_ls, valid_ls = train(net, X_tr, y_tr, X_val, y_val, num_epochs, lr, weight_decay, batch_size, device) # 记录 loss_sum （只记录训练每折训练结束的 loss） train_loss_sum += train_ls[-1] valid_loss_sum += valid_ls[-1] # 仅在第一折时绘制损失曲线 if fold == 0: # 画图 plt.plot(range(1, num_epochs + 1), train_ls, label=\u0026#39;train\u0026#39;) # 训练损失 plt.plot(range(1, num_epochs + 1), valid_ls, label=\u0026#39;valid\u0026#39;) # 验证损失 plt.xlabel(\u0026#39;epoch\u0026#39;) plt.ylabel(\u0026#39;rmse\u0026#39;) plt.xlim([1, num_epochs]) plt.yscale(\u0026#39;log\u0026#39;, base=2) # y 轴使用对数尺度 plt.legend() plt.show() print(f\u0026#39;折 {fold + 1}，训练 log rmse: {float(train_ls[-1]):.6f}, \u0026#39; f\u0026#39;验证 log rmse: {float(valid_ls[-1]):.6f}\u0026#39;) return train_loss_sum / k, valid_loss_sum / k num_epochs = 1000 lr = 0.0001 k = 3 weight_decay = 1e-3 batch_size = 512 train_l, valid_l = k_fold(k, train_features, train_labels, num_epochs, lr, weight_decay, batch_size, device) print(f\u0026#39;{k}-折验证: 平均训练log rmse: {float(train_l):f}, \u0026#39; f\u0026#39;平均验证log rmse: {float(valid_l):f}\u0026#39;) Training: 100%|██████████| 1000/1000 [00:11\u0026lt;00:00, 83.82it/s] 折 1，训练 log rmse: 0.060021, 验证 log rmse: 0.121284 Training: 100%|██████████| 1000/1000 [00:12\u0026lt;00:00, 81.13it/s] 折 2，训练 log rmse: 0.059339, 验证 log rmse: 0.133545 Training: 100%|██████████| 1000/1000 [00:12\u0026lt;00:00, 82.40it/s] 折 3，训练 log rmse: 0.060882, 验证 log rmse: 0.133310 3-折验证: 平均训练log rmse: 0.060081, 平均验证log rmse: 0.129380 ​ ​\n保存为 CSV # 不同于上面的 K 折检验, 在实际提交 kaggle 时，要将所有的训练集传入训练\nimport matplotlib.pyplot as plt def train_and_pred(train_features, test_features, train_labels, test_data, num_epochs, lr, weight_decay, batch_size): net = get_net().to(device) train_ls, _ = train(net, train_features, train_labels, None, None, num_epochs, lr, weight_decay, batch_size, device) plt.plot(range(1, num_epochs + 1), train_ls, label=\u0026#39;train\u0026#39;) # 训练损失 plt.xlabel(\u0026#39;epoch\u0026#39;) plt.ylabel(\u0026#39;rmse\u0026#39;) plt.xlim([1, num_epochs]) plt.yscale(\u0026#39;log\u0026#39;, base=2) # y 轴使用对数尺度 plt.legend() plt.show() print(f\u0026#39;训练log rmse：{float(train_ls[-1]):f}\u0026#39;) # 将网络应用于测试集。 preds = net(test_features.to(device)).detach().cpu().numpy() # 将 tensor 不再跟踪梯度，并转为标量 preds = preds * std + mean # 将其重新格式化以导出到 CSV 格式 test_data[\u0026#39;SalePrice\u0026#39;] = pd.Series(preds.reshape(1, -1)[0]) submission = pd.concat([test_data[\u0026#39;Id\u0026#39;], test_data[\u0026#39;SalePrice\u0026#39;]], axis=1) # 只保留 id 和预测价格 submission.to_csv(\u0026#39;submission.csv\u0026#39;, index=False) num_epochs = 2000 lr = 0.0001 k = 3 weight_decay = 1e-3 batch_size = 512 train_and_pred(train_features, test_features, train_labels, test_data, num_epochs, lr, weight_decay, batch_size) Training: 100%|██████████| 2000/2000 [00:34\u0026lt;00:00, 58.16it/s] 训练log rmse：0.083971 五、结论与讨论 # 1. 线性回归：简单但有效 # 最开始，我选择了最基础的线性回归模型，实际上 PyTorch 里 nn.Linear() 就能轻松实现。虽然简单，但只要数据预处理得当，比如归一化、数据类型转换、独热编码等，线性回归的效果其实也不错。\n在这个过程中，我发现 K 折交叉验证 是个非常重要的工具，它让我能更客观地评估模型的泛化能力，避免单次训练结果的偶然性。此外，损失函数的选择 也很关键，这里 MSELoss()（均方误差）效果最好，而 RMSE（均方根误差）更适合作为最终评估指标。\n小结：线性回归虽然简单，但如果数据处理得当，表现并不差，甚至可以作为一个可靠的基线模型。\n2. MLP：神经网络并不总是更好 # 接下来，我尝试把线性模型升级成 MLP（多层感知机），希望它能学到更复杂的特征。然而，模型刚训练出来就发现了一个大问题：严重的过拟合。\n为什么会这样？主要有两个原因：\nMLP 结构过于复杂，参数太多，导致模型学到了很多无关的噪声数据。 损失函数 MSE 在不同房价区间的影响不同，高价房的误差会被放大。 为了解决这些问题，我做了几项调整：\n加入 Dropout（0.5）和 L2 正则化，减少过拟合 对标签归一化，让 MSE 在不同房价区间的影响更均衡 使用 PCA（主成分分析）降维，减少无关特征 结果确实有提升，但神经网络并不是万能的，如果数据特征没选好，模型再复杂也没用。\n小结：神经网络并不总是比线性回归好，尤其是数据量不大时，复杂模型反而容易过拟合。\n3. 特征工程才是关键 # 在调整 MLP 的过程中，我逐渐意识到：模型的选择往往没那么重要，真正决定表现的其实是数据本身。\n后来，我参考了一些别人的思路，尝试从特征工程入手，比如：\n针对房价预测的特性，设计更合适的特征 结合已有的高分测试集，调整特征组合方式 调整之后，模型的表现确实更好了，但这个过程让我有些思考： 这些优化是否真的有普遍适用性？如果换个数据集，效果还会这么好吗？\n小结：模型的复杂度并不是提升效果的关键，如何处理数据、如何提取有用特征，才是真正决定模型表现的核心。\n4. 我的感悟 # 简单模型+好数据 \u0026gt; 复杂模型+普通数据，线性回归如果数据处理得当，效果不会比 MLP 差太多。\n","date":"2025 年 1 月 10 日","externalUrl":null,"permalink":"/posts/house_price/","section":"","summary":"","title":"kaggle 房价预测：课程报告","type":"posts"},{"content":"","date":"2025 年 1 月 10 日","externalUrl":null,"permalink":"/tags/%E5%9B%9E%E5%BD%92%E4%BB%BB%E5%8A%A1/","section":"","summary":"","title":"回归任务","type":"tags"},{"content":" 由于我使用的 oj 平台比较杂，很多时候找不到自己做过的题。\n特此将有价值的题目分类索引。\n本分类从 2025.01 开始。\n记忆化搜索 # leetcode 63.不同路径 - 经典走迷宫记忆化搜索\nleetcode 132. 分割回文串 Ⅱ - 分割字符串，返回计数。此题做法先记忆化搜索来预处理子串，之后用简单的 选或不选 DP 进行分割。\n蓝桥 火车运输 - 完全背包的扩展，但用记忆化更简单点。核心剪枝的是当找到一个最优状态直接终止程序，基本上算是个猜结论题。\nleetcode 3509. 最大化交错和为 K 的子序列乘积 - 完全背包的扩展。但需要对后缀零进行分类讨论，并在搜索前剪枝。\nleetcode 416. 分割等和子集 - 记忆化搜索 + 剪枝。选或不选使得两个子集相等，有较多的剪枝技巧。\n蓝桥 划分 - 和 LC416 非常相似，当两个子集相等时取答案。注意要直接当已经相等时直接剪枝，进而才能在合理时间内结束。\nleetcode 474. 一和零 - 两个维度的 01 背包\nleetcode 3693. 爬楼梯 II - 和爬楼梯差不多的记忆化搜索\n搜索 # leetcode 90 - 类似选或不选的简单搜索\nleetcode 680 - 经典题验证回文串\nleetcode 131 - 经典回溯法，分割字符串\nleetcode 1863. 找出所有子集的异或总和再求和 选或不选的搜索，注意”异或操作“并不能直接累计\nHOT100 22. 括号生成 - 虽然在回溯的提单，但其实只需要可以在搜索过程中剪枝即可\n蓝桥 不同的总分值 - 最简答的选或不选搜索\n蓝桥 买瓜 - DFS搜索的经典题，用后缀重量剪枝\n回溯 # HOT100 46. 全排列 - 经典搜索回溯问题\nHOT100 78. 子集 - 经典搜索回溯问题\nHOT100 17. 电话号码的字母组合 - 哈希表 + 基础回溯\nHOT100 39. 组合总和 - 对结果查重的回溯问题，需要注意分割数组\nHOT100 79. 单词搜索 - 走格子回溯路径，注意剪枝。优化：词频判断提前返回\nHOT100 131. 分割回文串 - j 从 i 起枚举子串终点，判断是否回文，若是则加入路径并递归，完成后回溯。\nHOT100 51. N 皇后 - 经典题 N 皇后，回溯列剪枝，对角线检测，构造棋盘输出结果。\n动态规划 # 资源分配 DP # leetcode 2209 用地毯覆盖后的最少白色砖块 - 资源分配问题，dp[i][j]表示：前 i 个地砖用 j 个地毯后的最小白砖数量。其中 i 为进度轴、j 为资源轴。\nleetcode 1278. 分割回文串 III - 是前面两个记忆化搜索的分割字符串的延续。思路还是资源分配 DP，前 i 给字符分割成 j 给字符串的最小修改次数。\nleecode 1745. 分割回文串 IV - 和上面的 Ⅲ 几乎完全一致，不过是把维护修改数量改成维护 bool 值。\n区间 DP # 奶牛体检 - 区间DP + 前缀和，比较规矩的模板\nleetcode 1690. 石子游戏 VII - 区间DP + 前缀和，需要将博弈转化到递归，进而想到重复子问题。\nluogu P1005 - 区间DP (记忆化版)，此题要处理大数输出。\n打家劫舍型 DP # 蓝桥 松散子序列 - 打家劫舍板子，一种做法 dp[i][1] 表示 i 选了的最大值 dp[i][0] 表示 i 没选的最大值，空间优化做法为 dp[i] 就表示当前最大值\n蓝桥 对局匹配 - 将数值分成 k 组，其中 i+k，i+2*k……为一组，可以保证组之间互不干扰。而在组中，就是打家劫舍问题。\nleetcode 2597. 美丽子集的数目 - 和上面的对局匹配几乎完全一致，不过要多想一下为什么 k 组之间相互独立\nleetcode 2140. 解决智力问题 - 打家劫舍变形，从左往右刷表法。每次维护的是 x + dx 下标的值、\nleetcode 3557. 不相交子字符串的最大数量 - 本质上还是选或不选问题，不过需要用 O1 维护该数的前一个相同数的位置，并保证 i - j \u0026gt;= 3。当然也可能直接双指针贪心，最小的分割情况就是最好的。\n状态机 DP # leetcode 2272. 最大波动的子字符串 - 此题转化成 状态机DP 的难度不低，小写字母双层外部遍历，内部遍历中维护两个状态。\nleetcode 2712. 使所有字符相等的最小成本 - 状态机 DP 板子，也可以用贪心做（但有点难想到）。\n蓝桥 蜗牛 - 二维状态 DP，几乎是板子了\n蓝桥 翻转 - 看懂题就是很简单的状态机\n蓝桥 贸易航线 - 线性 DP 部分非常简单，几乎就是最基础的维护前缀最大 DP。但数据预处理比较麻烦，即将题目的数据转化为 DP 直接能用的（价值、所需持续时间）二元组，题解中也有更优雅的不需要预处理的办法，此外也需要贪心发现 k 不影响买卖。\n经典线性 DP # leetcode 72. 编辑距离 - 最长公共子序列板子。\nleetcode 368. 最大整除子集 - 思路与最长上升子序列完全一致，需要维护具体的序列内容（而非标准的长度）\nleetcode 300. 最长递增子序列 - 经典题：最长上升子序列。nlogn 是二分查找的做法\n状压 DP # 蓝桥 羊圈 - 状态压缩 DP 的板子。其中 i 表示遍历到第几头羊，j 用状态压缩的二进制表示用了哪些羊圈，此题用了记忆化。\n博弈 DP # leetcode 913. 猫和老鼠 - 比较复杂的博弈，写了博客文章。\n蓝桥 砍柴 - 基本是最简单的博弈，记忆化和递推都好写。加一个线性筛判断质数，但这题卡常极其恶心。\n蓝桥 魔法迅游 - 比较复杂的状态机 DP，也包含了前缀优化 DP 的思路。状态转移很复杂，模拟量较大。\n数位 DP # leetcode 1012. 至少有 1 位重复的数字 - 先导零 + 掩码\nleetcode 2719. 统计整数数目 - 数位 DP 板子，无先导零\nleetcode 233. 数字 1 的个数 - 最基础的数位 DP，无先导零\nleetcode 600. 不含连续1的非负整数 - 简单数位 DP，无先导零，用一个 pre 存储上一个位置的数字。且此题是二进制串。\nleetcode 2376. 统计特殊整数 - 需要考虑掩码和先导零\n蓝桥 奇怪的数 - 数位 DP 过 60%，后 40% 卡内存。正解是将 pos 转为奇或偶两种状态的五维 DP。\nleetcode 2999. 统计强大整数的数目 上下界数位 DP，不用考虑先导零。判断后缀在状态转移方程中，如果 pos 到达后缀的位置，则只能在范围内选择后缀的数字。\n其他 DP # 蓝桥 选数异或 转化任务为 O1 查找区间内是否存在 x。但区间长度最多支持 On，因此将问题在此转化为：以 r 为基准维护最短失败区间长度。而这步需要 ：维护 r 前最近的 x 位置（哈希表），如果 x 位置在区间外，则延续当前最短失败区间（状态转移方程）。想到这步之后就是基本的线性 DP 了。\n前缀和 \u0026amp; 差分数组 # leetcode 3070. 元素和小于等于 k 的子矩阵的数目 - 二维前缀和板子。\nccfcsp 坐标变换（其二） - 前缀和 + 模拟，注意下三角函数库函数输入为弧度制。并需要控制输出精度。\nleetcode 3355. 零数组变换 I - 差分数组板子，最后有一个小贪心。\n蓝桥 等差数列 - 给一个少了 n 个元素的数列，给出完全包含其全部元素的等差数列。说是差分数组，实际只是排序后记录临近差值，然后求全部 gcd。\nHOT100 560. 和为 K 的子数组 - 前缀和 + 两数之和，也可以滑动窗口。用哈希表记录每一个前缀和，如果能和当前的前置和组成\nHOT100 53. 最大子数组和 - 当前最大的前缀和减去最小的前缀和就是答案。（也可以更优雅的分治法）\nHOT100 238. 除自身以外数组的乘积 - 前缀后缀积，如果想控制 O1 空间复杂度，可以只维护 suf 数组和一个 “当前 pre”。\n堆 \u0026amp; 栈 \u0026amp; 队列 \u0026amp; 桶 # 栈 # leetcode 3561. 移除相邻字符 栈的应用，这题其实和括号匹配一个意思\n单调栈 # leetcode 3542. 将所有元素变为 0 的最少操作次数 - 贪心加单调栈，要从概念出发慢慢推出单调栈，思维难度不低。\n洛谷 单调栈 - 单调栈板子，栈内单调递减，若 arr[i + 1] \u0026lt;= arr[i] 则弹出 i + 1，单调栈内部存的是下标。\n堆 # 3092. 最高频率的 ID - 懒删除堆，实际上是哈希表加堆。\n洛谷 合并果子 - 贪心 + 堆，用小根堆，每次拿出最小的两个合并即可\ntop K # leetcode 215. 数组中的第K个最大元素 topK 板子。我经常错写为把 k 弹出再压入，实际上是当 pq 的长度大于 k 时应该直接弹出旧的并压入新的。\n蓝桥 选段排序 贪心 + topK：贪心可知，最优排序区间中至少有一段点是 p 或 q（这个贪心并不好想），因此问题转化为 p-\u0026gt;n 和 q-\u0026gt;0 的 topk 问题。\n单调队列 # HOT100 239. 滑动窗口最大值 - 滑动窗口维护单调递减队列板子题，用于 On 时间内查找窗口最值\n桶 # 蓝桥 限流器 - 经典桶（哈希）应用，对区间整除后加入桶中\n滑动窗口 # HOT100 3. 无重复字符的最长子串 - 板子中的板子，尽量背诵\nHOT100 438. 找到字符串中所有字母异位词 - 定长滑动窗口，比普通的简单些。\nHOT100 76. 最小覆盖子串 - 滑动窗口板子，多写一个哈希判断字串是否在窗口中即可。\nleetcode 3306. 元音辅音字符串计数 II - 至少型 滑动窗口，题目要求恰好 k，但滑动窗口只能解决至少 k 和 至少 k + 1，则需要将其相减。此外可以参考下其求至少的思路，即 ans += l ，其中 l 左侧每个都可以成为一个满足条件的子数组。\n蓝桥 特殊的数组 - 逆向滑动窗口，维护的是窗口外的 cnt，用一个 num 记录当前还有几个数不符合要求，从而避免反复查询 cnt\n字符串 # leetcode 541 - 字符串反转、练习下切片\n蓝桥 吊坠 - 字符串破坏成链DP + 克鲁斯卡尔 能过 80%，优化常数能过 90%。想过 100% 需要后缀自动机\nleetcode 2109. 向字符串添加空格 - 字符串切片\n数论 # 快速幂 # leetcode 1922. 统计好数字的数目 - 快速幂板子\n质数筛 # 洛谷 线性筛 - 线性筛板子\nleetcode 2614. 对角线上的质数 - 线性筛预处理\nleetcode 3556. 最大质数子字符串之和 - 直接判断质数，当查询量小时，直接判断比筛更快\n组合数学 # 蓝桥 2023 - 组合数学 + 容斥定理。comb 部分用逆元法，容斥定理部分为二项式反演。\n蓝桥 困局 - 思维量较高才能发现组合数公式，此外还需与对每种 k 进行枚举其加权。\nleetcode 3558. 给边赋权值的方案数 I - 两个步骤：1. 遍历树的最深深度 2. 求该深度个数中（每个数都是1或2），一共有多少种总长度奇数的路径，因此可以用组合数学求和。其中求和 1 个奇数、3个奇数 …… 的组合数，根据二项式定理，就是 2 ^ (i - 1) 种。\n质因数 # 洛谷 分解质因数 - 质因数分解板子，注意特判 n 为质数的情况\n蓝桥 儿童数 - 利用唯一分解定理（每个正整数可以唯一表示为若干个质数的幂的乘积）将 1~2024 所有整数质因数分解，统计所有质因数总次数，若某质因数次数 ≥61，则按次数 //61 +1 参与组合乘积。\n图论 # 搜索 # leetcode 547. 省份数量 - 最基础的图论 DFS。\nleetcode 1311. 获取你好友已观看的视频 - 最基础的图论 BFS，加一个 map 转化 vector 用 lambda 排序。\nleetcode 1129. 颜色交替的最短路径 - 必须交替走两种颜色的路径，由于路径长度都为一，因此还是 BFS。不过要维护两种颜色的 visited 和 两种颜色分别作为第一步的 ans。\n蓝桥 走方格 比较板子的走迷宫 BFS，但题目描述和样例都很烂，没有大样例的 debug 需要花一段时间。\nHOT100 200. 岛屿数量 - 最基础的 BFS\nHOT100 994. 腐烂的橘子 - 同样基础的 BFS\n蓝桥 马与象 - 双向 BFS，从马和象分别进行 BFS ，得到其和每个点的 DIS。找所有点中两者的最小距离。\n拓扑排序 # HOT100 207. 课程表 - 判断是否有环，可以拓扑排序或 DFS\nleetcode 1462. 课程表 IV - 拓扑排序。维护一个 dp 数组，拓扑排序时，已确认 node 是 next 的先导。则状态转移方程：dp[i][next] = dp[i][next] || dp[i][node]。其中dp[i][j] 表示 i 是 j 的先导。\nleetcode 685. 冗余连接 II - 基环树 + 分类讨论。需要的算法是判断入度和判断环，都是基于拓扑排序。\nleetcode 2360. 图中的最长环 - 由于每个节点最多一个出边。因此不存在嵌套的环，每个节点至多在一个环中。拓扑排序：找到在环中的节点 + DFS：遍历每个环。\nleetcode 3543. K 条边路径的最大边权和 - 先拓扑排序判断有向图顺序，在根据排序进行 DP。状态 dp[i][j] 表示 终点在 i 点、经过 j 条路径的全部可能的总长度大小。通过拓扑排序可以保证只需要遍历一轮 n。或者使用记忆化搜索更加简单。\nleetcode 1857. 有向图中最大颜色值 - 拓扑排序 + 图上 DP，拓扑排序判断环，并顺便完成 DP 状态的更新。dp[v][c] 表示以 v 为终点，颜色 c 的最大数量 ，当然也可以 DFS 记忆化搜索。\n洛谷 拓扑排序 - 拓扑排序板子\n洛谷 最大食物链 - 拓扑排序经典题，要找从起始到终止的食物链数量。拓扑排序只会遍历一次 x -\u0026gt; y 的关系，因此只需要按顺序记录每个节点的路径，然后累加即可（此处思路很类似 DP）。\n最短路 # leetocde 743. 网络延迟时间 - spfa 和 dijk 都写了。\nleetcode 1514. 概率最大的路径 - dijk 做法。\nleetcode 2642. 设计可以求最短路径的图类 - spfa 做法。\nleetcode 3341. 到达最后一个房间的最少时间 I - 经典网格图 dijk\nleetcode 3342. 到达最后一个房间的最少时间 II - 网格图最短路，由于需要判断当前 dis 和 dis_num 因此不太适合 BFS。此题我用了 SPFA，会卡常数。网格图这种稠密图更适合 Dijk。\nleetcode 1334. 阈值距离内邻居最少的城市 Floyd 多源最短路。\nleetcode 3552. 网格传送门旅游 - 01BFS，实际上是将 queue 换成双端队列，不消耗步数就插入队列顶部，也可以视作只有01距离的 dijk\n最小生成树 # 蓝桥 吊坠 - 字符串破坏成链DP + 克鲁斯卡尔 能过 80%，优化常数能过 90%。想过 100% 需要后缀自动机。此题用图论的并查集克鲁斯卡尔。\nleetcode 1584. 连接所有点的最小费用 克鲁斯卡尔板子。\n并查集 # leetcode 3551. 数位和排序需要的最小交换次数 - 排序最小交换次数问题，实际上就是寻找数组中的连通块数量（将下标视作链表），找连通块可以用 BFS DFS 并查集等等。\nLCA # 蓝桥 彩色二叉树 - 完全二叉树的两点 LCA，倍增法的缩减版。用树上两点距离 x y，存储所有标记操作。遍历标记操作，找 x y 距离小于 y 并最晚标记的颜色。 理论复杂度较高，但实际能过全部数据。\nleetcode 1123. 最深叶节点的最近公共祖先 - 也可以不用 LCA 做，但可以练一下\nleetcode 3559. 给边赋权值的方案数 II - 用倍增法 LCA 求两节点距离，后续的组合数学部分见 3558 题。\n前缀树 Trie # HOT100 208. 实现 Trie (前缀树) - Trie 树板子，构造题\n链表 # 比赛很少考，面试经常考\nCSP 十滴水 - 递归加双向链表模拟即可。实际上 map 的底层是红黑树，能够实现 log 级别模拟双向链表 ，因此可以直接用 map 逃课。\nHOT100 142. 环形链表 II - 快慢指针找入环的第一个节点，技巧题。当快慢指针第一次相遇时候，将快指针重新回到头节点，快慢同步走，再次相遇就是环入口。\nHOT100 206. 反转链表 经典反转链表，可以迭代或者递归。\nHOT100 25. K 个一组翻转链表 经典中的经典，反转链表 + 前后指针。\n区间数据结构 # 线段树 # leetcode 2080 - 统计区间内数字频数，将静态线段树板子的 max 改成统计词频的哈希表即可。（此题二分 + 前缀和更优）\nleetcode 307 - 经典的区间和检索，静态线段树板子\nleetcode 1438. 绝对差不超过限制的最长连续子数组 - 区间线段树 + 滑动窗口，CPP 能过，python 卡常。更好的解法是单调队列\n树状数组 # 洛谷 树状数组1 - 树状数组板子\n洛谷 树状数组2 - 树状数组 + 差分数组\n模拟 # 蓝桥 连连看 - 需要先简单转化一下，得到模拟所有主副对角线，之后哈希统计。转化稍微需要一点思维。\nleetcode 2711. 对角线上不同值的数量差 - 简单二维模拟，用个 set 就秒了\nccfcsp 矩阵计算 - 模拟矩阵的点乘和积乘，此题正常算的复杂度很勉强。矩阵计算需要把点乘放到最后，因此用乘法交换律从右向左算。\n蓝桥 交易账本 - 中高强度的模拟，幸好样例给的不错\nleetcode 838. 推多米诺 - 小模拟多米诺骨牌，用 BFS 能减少分类讨论\nleetcode 1007. 行相等的最少多米诺旋转 - 小模拟找最小\nleetcode 2131. 连接两字母单词得到的最长回文串 - 分类讨论，分别模拟自身是回文串的数量、能分别组成回文串的左右字串、最中间可以放一个回文串。\nHOT100 73. 矩阵置零 - 模拟，要找节约内存的最优解。用第一行和第一列的来记录本行或列是否要归零。用 bool 记录第一行或列自己是否要归零\nHOT100 54. 螺旋矩阵 - 纯模拟，右下左上的顺序\nHOT100 48. 旋转图像 - 纯模拟 先换主对角线 再换左右 就是向右选择 90°\n蓝桥 记事本 - 经典模拟 vim，易错切片的区间边界问题。值得注意的是，切片的时候 ans[:max(index - n, 0):] 经常容易忘掉下边界最小为零。\n洛谷 文字处理软件 - STL string 板子\n洛谷 统计单词数 - 通过在匹配串加 “ ” 使其适配 string::find，比较聪明的写法\n洛谷 学籍管理 - STL map 板子\n日期模拟 # 蓝桥 神奇闹钟 - 日期时间模拟，考库函数。日期做差。\n蓝桥 跑步 - 日期时间模拟，注意 weekday() 下标从 0 开始。\n蓝桥 跑步计划 - 日期时间模拟，和上一道题十分相似\n思维题 # leetcode 1287. 有序数组中出现次数超过25%的元素 - 有序数组中找 1/4 以上的连续数。其logn 复杂度下，思想角度类似鸽巢原理，或者从字符串角度看有一点像 kmp。\n蓝桥 召唤数学精灵 - 杯特有的找规律，不得不品尝。前面位置的题不会了就缩小数据范围找规律试试。\n蓝桥 数字诗意 - 还是那个找规律，答案是所有的 2 ** n ，用 n \u0026amp; (n - 1) == 0 判断\n蓝桥 村的真相 - 稍微难一点的找规律，和考公题一样。\n蓝桥 子树的大小 - 思维 + 完全 N 叉树概念了解即可。之后通过遍历最左和最右节点来进行求和。\n蓝桥 阶乘的和 - 将阶乘和数组，模拟从最小因子开始合并，若可整除则升级，贪心推进求出最终最大因子值 （需要一点点 gcd 的知识）\nleetcode 781. 森林中的兔子 - 思维题：如果同种兔子数量不大于他所说的个数，则有 i+1 种兔子，如果大于，则进行分组即可。\nleetcode 2145. 统计隐藏数组数目 - 找最小最大，中间相隔的就是能放下的距离\nleetcode 790. 多米诺和托米诺平铺 - 排方块找规律，规律有难度。标注的考思维量的题。\nHOT100 169. 多数元素 - 找数组中数量大于 n // 2 的数。法1：当作 LC1287 的弱化版，排序后下表 n // 2 就是答案。法2：时间On，空间O1 摩尔投票法，不太好理解，尤其证明 candidate 需要仔细看。\nHOT100 31. 下一个排列 - 经典下一个排序算法，需要两次从后向前遍历找两个下标，交换后反转降序数组。\nHOT100 56. 合并区间 - 区间排序后，重叠则合并，不重叠则加入结果。\nHOT100 189. 轮转数组 - 最优解法是：reverse(0, n - 1) ; reverse(0, k - 1); reverse(k, n - 1)\nHOT100 41. 缺失的第一个正数 - 利用交换将正数放入对应下标，最终首个不匹配位置即为缺失的最小正整数。\nHOT100 240. 搜索二维矩阵 II - 最优解法是将其视作一根以右上角为顶点的二分查找树，时间复杂度是 O(m + n)\n洛谷 蚂蚁 - 脑筋急转弯。两蚂蚁相撞后分别向反方向走，实际上和他们直接路过没有区别。\n哈希 # HOT100 1. 两数之和 - 哈希表的 find 或者默认值设置两种语法\nHOT100 49. 字母异位词分组 - 注意下简洁写法的哈希语法\nHOT100 128. 最长连续序列 - 用集合判断连续序列起点，元素最多遍历两次。\n洛谷 A-B数对 - 两数之和，洛谷版本\n洛谷 木材仓库 - set 的二分库函数和迭代器使用，注意 set 的迭代器不能直接减，要用 prev，加要用 next\n双指针 # leetcode 680 - 经典题验证回文串\nHOT100 287. 寻找重复数 - 将数组下标的映射视作链表，之后就与快慢指针找环入口一致\nHOT100 75. 颜色分类 - 荷兰国旗，双指针。从前向后的指针好理解，但从后向前的指针需要 while，进而在数组原地交换。\nHOT100 283. 移动零 - left 表示非零的已经好的位置，right 遇到非零就和 left 交换\nHOT100 11. 盛最多水的容器 - 因为面积由 min(height[l], height[r]) 决定，因此先挪更短指针一定是最优解\nHOT100 15. 三数之和 - 思路先排序，遍历 i 作为基准，之后 l r 双指针。如果 l 和 r 的 sum 大于目标，则减小 r，反之增加 l。但此题要求不能重复，因此要去掉重复的 i ，和重复的 j，导致边界条件非常麻烦。\nHOT100 42. 接雨水 - 典中典 1. 前缀后缀法：通法，思维量较小。统计每个数的最大前后缀；2. 双指针实际上就说前缀后缀的优化版，核心就是哪侧前或后缀更小，就缩那测 ；3.单调递减栈，找上一个更大的，然后填坑。双指针是最优解，前缀后缀和单调栈更常用\n异或和 # HOT100 136. 只出现一次的数字 - 最基础的异或和，原理 ： a ^ a = 0 ; a ^ b ^ a = b\nleetcode 2588. 统计美丽子数组数目 - 巧妙的异或和例子\n蓝桥 异或和之和 - 异或和 加 贡献法\n贡献法 # 农夫约翰的奶酪块 - 贡献法，三维映射到二维\n哞叫时间 - 比较麻烦的模拟，基本方法是：先尝试该某点，获取哈希表计数，撤回对该点的修改\n哞叫时间Ⅱ - 在遍历过程中维护三个数组，“遍历右，维护左”\n鸽巢原理 # 蓝桥 取模 - 乍一看是中国剩余定理。但实际上是 “反证 + 鸽巢原理”，若模值两两不同，则必为 n % m == m - 1（因为小于 m - 1 的已经被占了），遍历验证是否存在不满足的情况。\n二分查找 # leetcode 1552 - 最大化最小\nleetcode 1760 - 最小化最大\nleetcode 2594 - 最小化最大，本质上是最小化\nleetcode 1283. 使结果不超过阈值的最小除数 - 基础的最小化最大\nleetcode 81. 搜索选择排序数组Ⅱ - 经典旋转数组二分，要考虑比较多的边界\nleetcode 33. 搜索选择排序数组 - 上一道题的简化版\nluogu P1068 - 模拟排序 记得看下字符串输入输出\n蓝桥 卡片 - 找规律 + 二分答案。规律和二分都非常好想。\n蓝桥 切木棍 - 经典最大化最小，注意切的时候是 (i - 1) / num 即可\n贪心 # leetcode 624 - 经典的遍历右，维护左。\n蛋糕游戏 - 博弈中的贪心，要使用到前缀和\nleetcode 1328. 破坏回文串 - 有一些贪心做法，不过暴力也能过。\nleetcode 2070. 每一个查询的最大美丽值 - 经典遍历右，维护左\nleetcode 1963. 使字符串平衡的最小交换次数 - 可以交换的括号匹配，当遇到无法匹配的右括号时，贪心从后向前的左括号交换。\n蓝桥 回文数组 - 贪心，前后做差。可以看作差分数组的简化版本。\nleetcode 2680. 最大或值 - 贪心，将 k 都给一个元素是最好的。为了 On 实现，需要维护前后缀和。要注意此题并非维护区间和，区间和需要线段树。\nleetcode 2116. 判断一个括号字符串是否有效 - 指定可变括号位置的括号匹配。分别将可变的括号视作 “(“ 和 “)”，如果两次匹配都能成功，说明可变的位置是灵活的，说明能成功匹配。\nleetcode2874. 有序三元组中的最大值 II - 贪心使得 nums[i] 和 nums[k] 最大，因此只用维护最大前缀后缀即可\n蓝桥 最长回文前后缀 - 双指针回文贪心，如果严格复杂度需要马拉车算法，实际上用双指针处理前后缀即可。\n蓝桥 三国游戏 - 贪心 + 排序。同一选择只会有一种赢。\n蓝桥 球衣号码 - 简单推理可得，编码的最大值只和最小和最大的号有关\nleetcode 2311. 小于等于 K 的最长二进制子序列 - 从后往前找尽量多的 1 ，多余的 0 直接补上即可\nleetcode 1262. 可被三整除的最大和 - 经典凑 mod3 的贪心，思路挺有意思的。可以找最小的 x1 % 3 == 1 和 x2 % 3 == 2，为这个 x1 x2 也可以是其他数凑的。状态转移比如当 x2 % 3 == 2 时： x1 = min(x1, x2 + nums[i]), x2 = min(x2, nums[i])，从而包装 x1 和 x2 没有依赖关系。最后 用 s - x1 或 s - x2 做答案。\n面试智力题 # 鸡蛋坠楼 # leetcode 1884. 鸡蛋掉落-两枚鸡蛋 - 找到所有 n * (1 + n) / 2 即全部累计的数\nleetcode 887. 鸡蛋掉落 ：\n从 n 直接得到次数比较难，类似上一题（k == 2）的特例\n可以枚举 i 找其能找的最大楼层，降低难度\n考虑子问题，关键两个因素是“剩余的尝试次数 i 和剩余的鸡蛋数量 j“\n此外其时间复杂度 n * k 为 1e6，更能考虑其 i 与 j 为关键状态\n在某楼层扔鸡蛋，会产生两种状态\n鸡蛋碎了 -\u0026gt; 产生 dfs(i - 1, j - 1) 的子问题 -\u0026gt; 其本身也测出来该楼层正误 -\u0026gt; 获得 dfs(i - 1, j - 1) + 1 的楼层\n鸡蛋没碎 -\u0026gt; 产生 dfs(i - 1, j) 的子问题 -\u0026gt; 即该楼层以上能测出多少楼层\n该楼层以下 + 该楼层以上 -\u0026gt; dfs(i - 1, j - 1) + 1 + dfs(i - 1, j)\n当 i == 0 或 j == 0 时测不出来楼层 返回 0\n概率论 # leetcode 1227. 飞机座位分配概率 - 除第一人外，每人坐对概率对称，最终乘客有一半概率坐上自己的座位。\n五道股票题 # leetcode 121. 买卖股票的最佳时机 - 前缀最小值模拟即可\nleetcode 122. 买卖股票的最佳时机 II - 按题干模拟即可，或者理解为 相邻元素正的差值之和\nleetcode 123. 买卖股票的最佳时机 III - 前缀后缀法，或 买卖股票 4 的 dp 法。 前缀后缀都视作 买卖股票1 ，分别记录其前后缀的最大利润，就能找到两次买卖的最大利润。\nleetcode 188. 买卖股票的最佳时机 IV - 资源分配型记忆化搜索，从最后状态往前推，状态转移稍微有些复杂。\ni 是数组下标即当前最后统计的元素，记忆化搜索从后向前容易\nj 是当前剩余的买卖次数\nhold 标记当前是否存有股票\n如果转成 DP 需要三维\nleetcode 3573. 买卖股票的最佳时机 V - 在 买卖股票4 的基础上多一个状态转移，还没来得及做\n","date":"2025 年 1 月 2 日","externalUrl":null,"permalink":"/posts/%E7%AE%97%E6%B3%95%E9%A2%98-%E7%B4%A2%E5%BC%95/","section":"","summary":"","title":"算法题 - 分类索引","type":"posts"},{"content":" 友链页，目前比较草率，有兴趣的时候可以装修下。 谢谢各位朋友们 ！\n石上三年(赵梓霖)\n刘孟玄\n古恩豪\n易永康\n溴化锂\n","date":"2025 年 1 月 1 日","externalUrl":null,"permalink":"/posts/%E5%8F%8B%E9%93%BE/","section":"","summary":"","title":"友链","type":"posts"},{"content":" 首先，非常感谢您打开我的个人博客 🤗🤗🤗 我是谁？ # 👋 你好，我是 陈驰水\n🎓 吉林大学软件工程 大四在读，推免至 复旦大学电子信息（计算机技术）。\n📅 我出生于 2004 年，目前在 长春 / 北京 。\n🎯 目前正寻求 科研合作 与 企业实习 的机会。\n💡 当前正深入学习 Embodied AI \u0026amp; LLM\n🔗 如果您希望进一步了解我，欢迎点击本文上方头像下方的各平台链接。\n🧐 如果和您在线下见面，希望您能认出我：\n我的 GitHub 头像，就是我的证件照。\n👉跳转我的 GitHub\n关于此博客 # 本博客所使用的技术栈：\n此博客使用 github page + hugo 进行搭建。 对 blowfish theme 进行了个性化修改。 目前正使用 firebase 作为数据库。 目前解析到的域名是 blog.chencs.online ，并已经通过 icp备案 和 公安备案。 并使用 CDN 加速，以方便国内访问。 此博客页面设计：\n本人对界面设计感比较看重，因此在博客的风格上也进行了一定的努力。 修改导航栏为灵动岛风格。 大部分字体与样式都经过我的微调。 文章全部进行分类和标记。 大部分 Markdown排版 和 latex公式 使用得当。 本博客内容：\n算法与数据结构的整理和总结。 本科课程的应试笔记。 论文的学习笔记。 我的杂谈和优秀文章的转载。 ","date":"2025 年 1 月 1 日","externalUrl":null,"permalink":"/posts/%E5%85%B3%E4%BA%8E%E6%88%91/","section":"","summary":"","title":"关于我","type":"posts"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]