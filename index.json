
[{"content":" 文章分类 # ","date":"2025 年 3 月 11 日","externalUrl":null,"permalink":"/categories/","section":"","summary":"","title":"","type":"categories"},{"content":" 最近文章 # ","date":"2025 年 3 月 11 日","externalUrl":null,"permalink":"/posts/","section":"","summary":"","title":"","type":"posts"},{"content":" 文章标签 # ","date":"2025 年 3 月 11 日","externalUrl":null,"permalink":"/tags/","section":"","summary":"","title":"","type":"tags"},{"content":" 本博客为 kaggle 房价预测 的代码和实验报告，并融合自己的心得。 实验报告格式根据 智能算法综合实践 课程要求。\n比赛界面：房价预测\n我的开源 jupyter notebook ：线性回归 ，MLP 和多种优化\n一、前言 # 我想将 jupyter notebook 的输出汇总到本报告之中，但转化无法避免的导致排版略显杂乱，请理解。\n本实验报告很大一部分是由 jupyter notebook 转化 md 而得到的：\njupyter nbconvert name.ipynb --to markdown 而 word 版本使用了：\npandoc name.md -o output.docx 网络搭建部分参考了李沐老师的波士顿房价预测实例。\n二、实验目的 # 在 Kaggle 房价预测竞赛中构建模型并优化性能。\n掌握数据预处理、特征工程及回归任务建模方法。\n熟悉 PyTorch 的基本操作，包括数据处理、模型训练与评估。\n其中关于 PyTorch 操作，借由本次实验我进行了一定程度的总结，见我的博客：pytorch 总结\n三、实验原理与实验步骤 # 线性回归 # 显然该问题是一个回归问题，先试一下最简单的线性回归。\n线性回归在现在的 pytorch 中框架非常简单，几乎一个 nn.linear() 就能解决。\n对数据进行一定的操作：\n对 features 进行归一化，这几乎在任何线性回归任务中都是必须的。\n该题最终检测的是 RMSE，但经过我的测试，loss 用 nn.MSELoss() 仍是最佳的。\n因此为了使检测数据更加直观，要手写一个 RMSE 用于检测输出。\nRMSE 是 MSE 开方后的值，它的最优点与 MSE 一致，只是数值上有非线性变化（平方根）。\n该题的输入样式很多，包括 bool，int，float 等，要将其统一到 tensor 中。\n将 bool 值进行热编码。\n为了检验拟合情况，使用了 K 折交叉检验（这为我判断是否过拟合起到了很大的帮助）\n此外，为了直观观察 loss 下降，我也做了适配 RMSE 的绘图。\n此方案提交后的结果为 ：0.149，排名大致为 2000 / 3700\nMLP 与优化 # 在线性回归之后，很正常的思路是将模型扩大，即使用 MLP 进行学习。\n当然，使用 MLP 就代表要使用 cuda 加速，需要修改 to(device) 。\n但在仅修改 MLP 后，最后效果却反而不如线性回归，原因有以下几点：\n出现了严重的过拟合，MLP 神经元较多导致学习了很多不相干特征的。 实际损失函数 MSE 在不同房价基础上的表现有所差异。 对于第二点，我尝试过用 RMSE 做损失函数，但效果并不好。\n为了修改 MSE 的表现需要将 label 进行归一化，并在实际预测时进行反归一化。\n对于第一点，修改分成的两部分：\n适当缩小 MLP 的神经元数量、dropout 设置为 0.5、加入 L2 正则化。 对输入进行主成分分析（具体可视化在 MLP 一节的特征工程小节），选取了前 100 个主成分（累计贡献 98%）。 当然，修改过后还有一定的过拟合现象，但并不严重。\n此方案提交后的结果为 ：0.122，排名大致为 250 / 3700\n如果进行仔细的调参，还有一定的提升空间。\n特征工程 # 在参考排行榜头部 notebook 后，我发现此题最重要的部分是特征工程。\n即使上一部分中，我使用了主成分分析，但仍远远不如直接从特征出发。\n参考大量他人文档，引用了高分公开测试集，经过一定的参数调整后，得到结果如下。\n但我个人认为，这种针对数据集的调整的泛用性不一定强。因此在大部分实际工作中，并不具有普遍性。\n四、具体实验 # 简单线性回归 # 首先检查 input # 特别是训练集和测试集的 shape\n# This Python 3 environment comes with many helpful analytics libraries installed # It is defined by the kaggle/python Docker image: https://github.com/kaggle/docker-python # For example, here\u0026#39;s several helpful packages to load import numpy as np # linear algebra import pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv) # Input data files are available in the read-only \u0026#34;../input/\u0026#34; directory # For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory import os for dirname, _, filenames in os.walk(\u0026#39;/kaggle/input\u0026#39;): for filename in filenames: print(os.path.join(dirname, filename)) # You can write up to 20GB to the current directory (/kaggle/working/) that gets preserved as output when you create a version using \u0026#34;Save \u0026amp; Run All\u0026#34; # You can also write temporary files to /kaggle/temp/, but they won\u0026#39;t be saved outside of the current session /kaggle/input/house-prices-advanced-regression-techniques/sample_submission.csv /kaggle/input/house-prices-advanced-regression-techniques/data_description.txt /kaggle/input/house-prices-advanced-regression-techniques/train.csv /kaggle/input/house-prices-advanced-regression-techniques/test.csv train_data = pd.read_csv(\u0026#34;/kaggle/input/house-prices-advanced-regression-techniques/train.csv\u0026#34;) test_data = pd.read_csv(\u0026#34;/kaggle/input/house-prices-advanced-regression-techniques/test.csv\u0026#34;) print(\u0026#34;Train Data Shape:\u0026#34;, train_data.shape) print(\u0026#34;Test Data Shape:\u0026#34;, test_data.shape) Train Data Shape: (1460, 81) Test Data Shape: (1459, 80) 进行特征工程 # 将 input 进行 transform\n# 检查列名 print(train_data.iloc[0, :]) print(\u0026#34;-------------\u0026#34;) print(test_data.iloc[0, :]) # 其中 test_data 没有最后的 SalePrice Id 1 MSSubClass 60 MSZoning RL LotFrontage 65.0 LotArea 8450 ... MoSold 2 YrSold 2008 SaleType WD SaleCondition Normal SalePrice 208500 Name: 0, Length: 81, dtype: object ------------- Id 1461 MSSubClass 20 MSZoning RH LotFrontage 80.0 LotArea 11622 ... MiscVal 0 MoSold 6 YrSold 2010 SaleType WD SaleCondition Normal Name: 0, Length: 80, dtype: object 显然 id 这一列对数据预测没有实际意义\n对特征进行整合，并准备进行特征工程\nfeatures = pd.concat((train_data.iloc[:, 1:-1], test_data.iloc[:, 1:])) print(features.shape) print(\u0026#34;--------\u0026#34;) print(features.iloc[0, :]) (2919, 79) -------- MSSubClass 60 MSZoning RL LotFrontage 65.0 LotArea 8450 Street Pave ... MiscVal 0 MoSold 2 YrSold 2008 SaleType WD SaleCondition Normal Name: 0, Length: 79, dtype: object 将数组进行归一化，如公式所示 $$ (x - \\mu) / \\sigma$$\n# numeric_features 是特征中非对象类型（即整数与浮点数）的 index numeric_features = features.dtypes[features.dtypes != \u0026#39;object\u0026#39;].index features[numeric_features] = features[numeric_features].apply( lambda x: (x - x.mean()) / (x.std())) # 在标准化数据之后，所有均值消失。因此我们可以将缺失值设置为 0 features[numeric_features] = features[numeric_features].fillna(0) # 接下来处理布尔值。dummy_na 表示是否单独提出 nan 在新版本下，get_dummies 会转化为 uint8\n但 uint8 不能转化为 numpy，因此要使用 dtype=int\nfeatures = pd.get_dummies(features, dummy_na=True, dtype=int) features.shape (2919, 330) from torch import nn import torch n_train = train_data.shape[0] # 强制将 object 转为 float64 # features = features.astype(str) # 先将所有列转换为字符串 # features = features.apply(pd.to_numeric, errors=\u0026#39;coerce\u0026#39;) print(features[:].to_numpy().dtype) train_features = torch.tensor(features[:n_train].values, dtype=torch.float32) test_features = torch.tensor(features[n_train:].values, dtype=torch.float32) train_labels = torch.tensor( train_data.SalePrice.values.reshape(-1, 1), dtype=torch.float32) float64 下面开始进行线性回归训练，选择 MSE 做 loss。\n为了方便对比其他模型，线性回归是一个好的 baseline。\nloss = nn.MSELoss() input_features = features.shape[1] # 其中 shape[1] 是列数，也就是特征数 def get_net(): net = nn.Sequential(nn.Linear(input_features,1)) return net 然而，房价的差异在自身房价不同的情况下，不能直接用 abs(target - predict) 直接代表误差\n此题官方使用的是 $$ \\sqrt {\\frac {1}{n} \\sum _ {i=1}^ {n} (\\log y_ {i}-\\log _ {y}i)^ {2} }$$ .\n即 均方根对数误差（RMSLE）\n而其配合 MSE 就是 均方根对数误差（MSLE）\n此外，为保证均方根的合理性，要将 tensor 切割在 (1, inf) 之间\nnumpy 的 clip() 和 tensor 的 clamp() 作用相同\ndef log_rmse(net, features, labels): # 为了在取对数时进一步稳定该值，将小于1的值设置为1 clipped_preds = torch.clamp(net(features), 1, float(\u0026#39;inf\u0026#39;)) rmse = torch.sqrt(loss(torch.log(clipped_preds), torch.log(labels))) return rmse.item() # 将 tensor 标量化 下面开始训练代码\nfrom torch.utils.data import TensorDataset, DataLoader def train(net, train_features, train_labels, test_features, test_labels, num_epochs, learning_rate, weight_decay, batch_size): train_ls, test_ls = [], [] # 用 Dataset 和 DataLoader 进行打包 dataset = TensorDataset(train_features, train_labels) train_iter = DataLoader(dataset, batch_size=batch_size, shuffle=True) optimizer = torch.optim.Adam(net.parameters(), lr = learning_rate, weight_decay = weight_decay) # 传入 weight_decay 从而方便进行 L2 正则化 for epoch in range(num_epochs): for X, y in train_iter: optimizer.zero_grad() l = loss(net(X), y) l.backward() optimizer.step() train_ls.append(log_rmse(net, train_features, train_labels)) # 记录训练 loss if test_labels is not None: test_ls.append(log_rmse(net, test_features, test_labels)) # 记录测试 loss return train_ls, test_ls K 折交叉检验 # 由于数据量较小，可以使用 K 折检验，使得模型更稳定\nimport matplotlib.pyplot as plt # 划分 K 折交叉验证数据集 def get_k_fold_data(k, fold_idx, X, y): assert k \u0026gt; 1 fold_size = X.shape[0] // k # 每折数据大小 X_valid = X[fold_idx * fold_size: (fold_idx + 1) * fold_size, :] y_valid = y[fold_idx * fold_size: (fold_idx + 1) * fold_size] # 训练集由剩余 k-1 份数据组成 （即 留一法） X_train_parts = [] y_train_parts = [] for i in range(k): if i == fold_idx: continue X_part = X[i * fold_size: (i + 1) * fold_size, :] y_part = y[i * fold_size: (i + 1) * fold_size] X_train_parts.append(X_part) y_train_parts.append(y_part) # 拼接所有训练集部分 X_train = torch.cat(X_train_parts, dim=0) # dim = 0 表示按照行合并 y_train = torch.cat(y_train_parts, dim=0) return X_train, y_train, X_valid, y_valid # 执行 k 折检验 def k_fold(k, X_train, y_train, num_epochs, lr, weight_decay, batch_size): train_loss_sum, valid_loss_sum = 0, 0 for fold in range(k): # 进行 K 次留一法 X_tr, y_tr, X_val, y_val = get_k_fold_data(k, fold, X_train, y_train) net = get_net() train_ls, valid_ls = train(net, X_tr, y_tr, X_val, y_val, num_epochs, lr, weight_decay, batch_size) # 记录 loss_sum （只记录训练每折训练结束的 loss） train_loss_sum += train_ls[-1] valid_loss_sum += valid_ls[-1] # 仅在第一折时绘制损失曲线 if fold == 0: # 画图 plt.plot(range(1, num_epochs + 1), train_ls, label=\u0026#39;train\u0026#39;) # 训练损失 plt.plot(range(1, num_epochs + 1), valid_ls, label=\u0026#39;valid\u0026#39;) # 验证损失 plt.xlabel(\u0026#39;epoch\u0026#39;) plt.ylabel(\u0026#39;rmse\u0026#39;) plt.xlim([1, num_epochs]) plt.yscale(\u0026#39;log\u0026#39;, base=2) # y 轴使用对数尺度 plt.legend() plt.show() print(f\u0026#39;折 {fold + 1}，训练 log rmse: {float(train_ls[-1]):.6f}, \u0026#39; f\u0026#39;验证 log rmse: {float(valid_ls[-1]):.6f}\u0026#39;) return train_loss_sum / k, valid_loss_sum / k 调配参数 # num_epochs = 500 k = 3 lr = 2 weight_decay = 1e-3 batch_size = 128 train_l, valid_l = k_fold(k, train_features, train_labels, num_epochs, lr, weight_decay, batch_size) print(f\u0026#39;{k}-折验证: 平均训练log rmse: {float(train_l):f}, \u0026#39; f\u0026#39;平均验证log rmse: {float(valid_l):f}\u0026#39;) ​\n折 1，训练 log rmse: 0.169430, 验证 log rmse: 0.160753 折 2，训练 log rmse: 0.159886, 验证 log rmse: 0.173186 折 3，训练 log rmse: 0.160932, 验证 log rmse: 0.172761 3-折验证: 平均训练log rmse: 0.163416, 平均验证log rmse: 0.168900 保存为 CSV # 不同于上面的 K 折检验, 在实际提交 kaggle 时，要将所有的训练集传入训练\ndef train_and_pred(train_features, test_features, train_labels, test_data, num_epochs, lr, weight_decay, batch_size): net = get_net() train_ls, _ = train(net, train_features, train_labels, None, None, num_epochs, lr, weight_decay, batch_size) plt.plot(range(1, num_epochs + 1), train_ls, label=\u0026#39;train\u0026#39;) # 训练损失 plt.xlabel(\u0026#39;epoch\u0026#39;) plt.ylabel(\u0026#39;rmse\u0026#39;) plt.xlim([1, num_epochs]) plt.yscale(\u0026#39;log\u0026#39;, base=2) # y 轴使用对数尺度 plt.legend() plt.show() print(f\u0026#39;训练log rmse：{float(train_ls[-1]):f}\u0026#39;) # 将网络应用于测试集。 preds = net(test_features).detach().numpy() # 将 tensor 不在跟踪梯度，并转为标量 # 将其重新格式化以导出到 CSV 格式 test_data[\u0026#39;SalePrice\u0026#39;] = pd.Series(preds.reshape(1, -1)[0]) submission = pd.concat([test_data[\u0026#39;Id\u0026#39;], test_data[\u0026#39;SalePrice\u0026#39;]], axis=1) # 只保留 id 和预测价格 submission.to_csv(\u0026#39;submission.csv\u0026#39;, index=False) num_epochs = 1500 lr = 2 weight_decay = 1e-3 batch_size = 128 train_and_pred(train_features, test_features, train_labels, test_data, num_epochs, lr, weight_decay, batch_size) ​\n训练log rmse：0.124836 MLP 和多种优化 # 单独一个线性层的成绩并不好\n将单独的线性层换成多重感知机\n# 测试 cuda import torch device = torch.device(\u0026#34;cuda\u0026#34; if torch.cuda.is_available() else \u0026#34;cpu\u0026#34;) print(device) cuda 进行特征工程 # 将 input 进行 transform\n# 检查列名 print(train_data.iloc[0, :]) print(\u0026#34;-------------\u0026#34;) print(test_data.iloc[0, :]) # 其中 test_data 没有最后的 SalePrice Id 1 MSSubClass 60 MSZoning RL LotFrontage 65.0 LotArea 8450 ... MoSold 2 YrSold 2008 SaleType WD SaleCondition Normal SalePrice 208500 Name: 0, Length: 81, dtype: object ------------- Id 1461 MSSubClass 20 MSZoning RH LotFrontage 80.0 LotArea 11622 ... MiscVal 0 MoSold 6 YrSold 2010 SaleType WD SaleCondition Normal Name: 0, Length: 80, dtype: object 显然 id 这一列对数据预测没有实际意义\n对特征进行整合，并准备进行特征工程\nfeatures = pd.concat((train_data.iloc[:, 1:-1], test_data.iloc[:, 1:])) print(features.shape) print(\u0026#34;--------\u0026#34;) print(features.iloc[0, :]) (2919, 79) -------- MSSubClass 60 MSZoning RL LotFrontage 65.0 LotArea 8450 Street Pave ... MiscVal 0 MoSold 2 YrSold 2008 SaleType WD SaleCondition Normal Name: 0, Length: 79, dtype: object 将数组进行归一化，如公式所示 $$ (x - \\mu) / \\sigma$$\n# numeric_features 是特征中非对象类型（即整数与浮点数）的 index numeric_features = features.dtypes[features.dtypes != \u0026#39;object\u0026#39;].index features[numeric_features] = features[numeric_features].apply( lambda x: (x - x.mean()) / (x.std())) # 在标准化数据之后，所有均值消失。因此我们可以将缺失值设置为 0 features[numeric_features] = features[numeric_features].fillna(0) 在新版本下，get_dummies 会转化为 uint8\n但 uint8 不能转化为 numpy，因此要使用 dtype=int\n# 接下来处理布尔值。dummy_na 表示是否单独提出 nan features = pd.get_dummies(features, dummy_na=True, dtype=int) features.shape (2919, 330) 进行主成分分析，并划分训练集、测试集\nfrom torch import nn from sklearn.decomposition import PCA import torch n_train = train_data.shape[0] # 强制将 object 转为 float64 # features = features.astype(str) # 先将所有列转换为字符串 # features = features.apply(pd.to_numeric, errors=\u0026#39;coerce\u0026#39;) pca = PCA(n_components=100) features_pca = pca.fit_transform(features) print(features_pca.shape) train_features = torch.tensor(features[:n_train].values, dtype=torch.float32) test_features = torch.tensor(features[n_train:].values, dtype=torch.float32) (2919, 100) 对主成分分析进行可视化，看一下累计贡献图\nimport seaborn as sns import matplotlib.pyplot as plt explained_variance_ratio = np.cumsum(pca.explained_variance_ratio_) # 图一 累计主成分贡献图 plt.figure(figsize=(10, 6)) plt.plot(range(1, 101), explained_variance_ratio, marker=\u0026#39;o\u0026#39;, linestyle=\u0026#39;--\u0026#39;, color=\u0026#39;b\u0026#39;) plt.xlabel(\u0026#34;Number of Principal Components\u0026#34;) plt.ylabel(\u0026#34;Cumulative Explained Variance Ratio\u0026#34;) plt.title(\u0026#34;PCA Cumulative Explained Variance\u0026#34;) plt.grid() plt.axhline(y=0.80, color=\u0026#39;r\u0026#39;, linestyle=\u0026#39;--\u0026#39;, label=\u0026#34;80% Explained Variance\u0026#34;) plt.axhline(y=0.90, color=\u0026#39;g\u0026#39;, linestyle=\u0026#39;--\u0026#39;, label=\u0026#34;90% Explained Variance\u0026#34;) plt.legend() plt.show() # 图二 具体成果贡献图 explained_variance = pca.explained_variance_ratio_ top_10_components = np.argsort(explained_variance)[-20:][::-1] loadings = pd.DataFrame(pca.components_, columns=features.columns, index=[f\u0026#34;PC{i+1}\u0026#34; for i in range(100)]) top_10_loadings = loadings.iloc[top_10_components] top_20_features = top_10_loadings.abs().sum().nlargest(40).index top_10_loadings = top_10_loadings[top_20_features] plt.figure(figsize=(14, 8)) sns.heatmap(top_10_loadings, cmap=\u0026#34;coolwarm\u0026#34;, annot=False, linewidths=0.5) plt.xlabel(\u0026#34;Top 40 Most Important Features\u0026#34;) plt.ylabel(\u0026#34;Top 20 Principal Components\u0026#34;) plt.title(\u0026#34;Feature Contributions to Top 10 Principal Components\u0026#34;) plt.show() ​ ​\n# 计算均值和标准差 sale_price = np.array(train_data.SalePrice.values, dtype=np.float32).reshape(-1, 1) mean = sale_price.mean() std = sale_price.std() normalized = (sale_price - mean) / std # 转换为 PyTorch Tensor train_labels = torch.from_numpy(normalized) print(train_labels) tensor([[ 0.3473], [ 0.0073], [ 0.5362], ..., [ 1.0776], [-0.4885], [-0.4208]]) 模型搭建 # 下面开始进行线性回归训练，选择 MSE 做 loss。\n为了方便对比其他模型，线性回归是一个好的 baseline。\nloss = nn.MSELoss() input_features = features.shape[1] # 其中 shape[1] 是列数，也就是特征数 def get_net(): net = nn.Sequential( nn.Linear(input_features, 256), nn.ReLU(), nn.Dropout(0.5), nn.Linear(256, 64), nn.ReLU(), nn.Dropout(0.5), nn.Linear(64, 1) ) return net 然而，房价的差异在自身房价不同的情况下，不能直接用 abs(target - predict) 直接代表误差\n此题官方使用的是 $$ \\sqrt {\\frac {1}{n} \\sum _ {i=1}^ {n} (\\log y_ {i}-\\log _ {y}i)^ {2} }$$ .\n即 均方根对数误差（RMSLE）\n而其配合 MSE 就是 均方根对数误差（MSLE）\n此外，为保证均方根的合理性，要将 tensor 切割在 (1, inf) 之间\nnumpy 的 clip() 和 tensor 的 clamp() 作用相同\ndef log_rmse(net, features, labels, device): # 为了在取对数时进一步稳定该值，将小于 1 的值设置为 1 features, labels = features.to(device), labels.to(device) # 只添加这一行 test_labels = (labels.clone() * std) + mean clipped_preds = torch.clamp(net(features).clone() * std + mean, 1, float(\u0026#39;inf\u0026#39;)) rmse = torch.sqrt(loss(torch.log(clipped_preds), torch.log(test_labels))) return rmse.item() 下面开始训练代码\nfrom torch.utils.data import TensorDataset, DataLoader from tqdm import tqdm def train(net, train_features, train_labels, test_features, test_labels, num_epochs, learning_rate, weight_decay, batch_size, device): net.to(device) train_features, train_labels = train_features.to(device), train_labels.to(device) if test_features is not None and test_labels is not None: test_features, test_labels = test_features.to(device), test_labels.to(device) train_ls, test_ls = [], [] # 用 Dataset 和 DataLoader 进行打包 dataset = TensorDataset(train_features, train_labels) train_iter = DataLoader(dataset, batch_size=batch_size, shuffle=True) optimizer = torch.optim.Adam(net.parameters(), lr=learning_rate, weight_decay=weight_decay) for epoch in tqdm(range(num_epochs), desc=\u0026#34;Training\u0026#34;): net.train() # 进入训练模式 for X, y in train_iter: X, y = X.to(device), y.to(device) # 确保数据在 GPU 上 optimizer.zero_grad() l = loss(net(X), y) # 计算损失 l.backward() optimizer.step() # 记录训练损失 net.eval() train_ls.append(log_rmse(net, train_features, train_labels, device)) # 确保 loss 计算时数据在 GPU 上 if test_labels is not None: test_ls.append(log_rmse(net, test_features, test_labels, device)) return train_ls, test_ls K 折交叉检验 # import matplotlib.pyplot as plt # 划分 K 折交叉验证数据集 def get_k_fold_data(k, fold_idx, X, y): assert k \u0026gt; 1 fold_size = X.shape[0] // k # 每折数据大小 X_valid = X[fold_idx * fold_size: (fold_idx + 1) * fold_size, :] y_valid = y[fold_idx * fold_size: (fold_idx + 1) * fold_size] # 训练集由剩余 k-1 份数据组成 （即 留一法） X_train_parts = [] y_train_parts = [] for i in range(k): if i == fold_idx: continue X_part = X[i * fold_size: (i + 1) * fold_size, :] y_part = y[i * fold_size: (i + 1) * fold_size] X_train_parts.append(X_part) y_train_parts.append(y_part) # 拼接所有训练集部分 X_train = torch.cat(X_train_parts, dim=0) # dim = 0 表示按照行合并 y_train = torch.cat(y_train_parts, dim=0) return X_train, y_train, X_valid, y_valid # 执行 k 折检验 def k_fold(k, X_train, y_train, num_epochs, lr, weight_decay, batch_size, device): train_loss_sum, valid_loss_sum = 0, 0 for fold in range(k): # 进行 K 次留一法 X_tr, y_tr, X_val, y_val = get_k_fold_data(k, fold, X_train, y_train) net = get_net() train_ls, valid_ls = train(net, X_tr, y_tr, X_val, y_val, num_epochs, lr, weight_decay, batch_size, device) # 记录 loss_sum （只记录训练每折训练结束的 loss） train_loss_sum += train_ls[-1] valid_loss_sum += valid_ls[-1] # 仅在第一折时绘制损失曲线 if fold == 0: # 画图 plt.plot(range(1, num_epochs + 1), train_ls, label=\u0026#39;train\u0026#39;) # 训练损失 plt.plot(range(1, num_epochs + 1), valid_ls, label=\u0026#39;valid\u0026#39;) # 验证损失 plt.xlabel(\u0026#39;epoch\u0026#39;) plt.ylabel(\u0026#39;rmse\u0026#39;) plt.xlim([1, num_epochs]) plt.yscale(\u0026#39;log\u0026#39;, base=2) # y 轴使用对数尺度 plt.legend() plt.show() print(f\u0026#39;折 {fold + 1}，训练 log rmse: {float(train_ls[-1]):.6f}, \u0026#39; f\u0026#39;验证 log rmse: {float(valid_ls[-1]):.6f}\u0026#39;) return train_loss_sum / k, valid_loss_sum / k num_epochs = 1000 lr = 0.0001 k = 3 weight_decay = 1e-3 batch_size = 512 train_l, valid_l = k_fold(k, train_features, train_labels, num_epochs, lr, weight_decay, batch_size, device) print(f\u0026#39;{k}-折验证: 平均训练log rmse: {float(train_l):f}, \u0026#39; f\u0026#39;平均验证log rmse: {float(valid_l):f}\u0026#39;) Training: 100%|██████████| 1000/1000 [00:11\u0026lt;00:00, 83.82it/s] 折 1，训练 log rmse: 0.060021, 验证 log rmse: 0.121284 Training: 100%|██████████| 1000/1000 [00:12\u0026lt;00:00, 81.13it/s] 折 2，训练 log rmse: 0.059339, 验证 log rmse: 0.133545 Training: 100%|██████████| 1000/1000 [00:12\u0026lt;00:00, 82.40it/s] 折 3，训练 log rmse: 0.060882, 验证 log rmse: 0.133310 3-折验证: 平均训练log rmse: 0.060081, 平均验证log rmse: 0.129380 ​ ​\n保存为 CSV # 不同于上面的 K 折检验, 在实际提交 kaggle 时，要将所有的训练集传入训练\nimport matplotlib.pyplot as plt def train_and_pred(train_features, test_features, train_labels, test_data, num_epochs, lr, weight_decay, batch_size): net = get_net().to(device) train_ls, _ = train(net, train_features, train_labels, None, None, num_epochs, lr, weight_decay, batch_size, device) plt.plot(range(1, num_epochs + 1), train_ls, label=\u0026#39;train\u0026#39;) # 训练损失 plt.xlabel(\u0026#39;epoch\u0026#39;) plt.ylabel(\u0026#39;rmse\u0026#39;) plt.xlim([1, num_epochs]) plt.yscale(\u0026#39;log\u0026#39;, base=2) # y 轴使用对数尺度 plt.legend() plt.show() print(f\u0026#39;训练log rmse：{float(train_ls[-1]):f}\u0026#39;) # 将网络应用于测试集。 preds = net(test_features.to(device)).detach().cpu().numpy() # 将 tensor 不再跟踪梯度，并转为标量 preds = preds * std + mean # 将其重新格式化以导出到 CSV 格式 test_data[\u0026#39;SalePrice\u0026#39;] = pd.Series(preds.reshape(1, -1)[0]) submission = pd.concat([test_data[\u0026#39;Id\u0026#39;], test_data[\u0026#39;SalePrice\u0026#39;]], axis=1) # 只保留 id 和预测价格 submission.to_csv(\u0026#39;submission.csv\u0026#39;, index=False) num_epochs = 2000 lr = 0.0001 k = 3 weight_decay = 1e-3 batch_size = 512 train_and_pred(train_features, test_features, train_labels, test_data, num_epochs, lr, weight_decay, batch_size) Training: 100%|██████████| 2000/2000 [00:34\u0026lt;00:00, 58.16it/s] 训练log rmse：0.083971 五、结论与讨论 # 1. 线性回归：简单但有效 # 最开始，我选择了最基础的线性回归模型，实际上 PyTorch 里 nn.Linear() 就能轻松实现。虽然简单，但只要数据预处理得当，比如归一化、数据类型转换、独热编码等，线性回归的效果其实也不错。\n在这个过程中，我发现 K 折交叉验证 是个非常重要的工具，它让我能更客观地评估模型的泛化能力，避免单次训练结果的偶然性。此外，损失函数的选择 也很关键，这里 MSELoss()（均方误差）效果最好，而 RMSE（均方根误差）更适合作为最终评估指标。\n小结：线性回归虽然简单，但如果数据处理得当，表现并不差，甚至可以作为一个可靠的基线模型。\n2. MLP：神经网络并不总是更好 # 接下来，我尝试把线性模型升级成 MLP（多层感知机），希望它能学到更复杂的特征。然而，模型刚训练出来就发现了一个大问题：严重的过拟合。\n为什么会这样？主要有两个原因：\nMLP 结构过于复杂，参数太多，导致模型学到了很多无关的噪声数据。 损失函数 MSE 在不同房价区间的影响不同，高价房的误差会被放大。 为了解决这些问题，我做了几项调整：\n加入 Dropout（0.5）和 L2 正则化，减少过拟合 对标签归一化，让 MSE 在不同房价区间的影响更均衡 使用 PCA（主成分分析）降维，减少无关特征 结果确实有提升，但神经网络并不是万能的，如果数据特征没选好，模型再复杂也没用。\n小结：神经网络并不总是比线性回归好，尤其是数据量不大时，复杂模型反而容易过拟合。\n3. 特征工程才是关键 # 在调整 MLP 的过程中，我逐渐意识到：模型的选择往往没那么重要，真正决定表现的其实是数据本身。\n后来，我参考了一些别人的思路，尝试从特征工程入手，比如：\n针对房价预测的特性，设计更合适的特征 结合已有的高分测试集，调整特征组合方式 调整之后，模型的表现确实更好了，但这个过程让我有些思考： 这些优化是否真的有普遍适用性？如果换个数据集，效果还会这么好吗？\n小结：模型的复杂度并不是提升效果的关键，如何处理数据、如何提取有用特征，才是真正决定模型表现的核心。\n4. 我的感悟 # 简单模型+好数据 \u0026gt; 复杂模型+普通数据，线性回归如果数据处理得当，效果不会比 MLP 差太多。\n","date":"2025 年 3 月 11 日","externalUrl":null,"permalink":"/posts/house_price/","section":"","summary":"","title":"kaggle 房价预测：课程报告","type":"posts"},{"content":"","date":"2025 年 3 月 11 日","externalUrl":null,"permalink":"/tags/pytorch/","section":"","summary":"","title":"Pytorch","type":"tags"},{"content":"","date":"2025 年 3 月 11 日","externalUrl":null,"permalink":"/","section":"陈驰水-个人博客","summary":"","title":"陈驰水-个人博客","type":"page"},{"content":"","date":"2025 年 3 月 11 日","externalUrl":null,"permalink":"/tags/%E5%9B%9E%E5%BD%92%E4%BB%BB%E5%8A%A1/","section":"","summary":"","title":"回归任务","type":"tags"},{"content":"","date":"2025 年 3 月 11 日","externalUrl":null,"permalink":"/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/","section":"","summary":"","title":"机器学习","type":"categories"},{"content":"","date":"2025 年 3 月 11 日","externalUrl":null,"permalink":"/tags/%E8%AF%BE%E7%A8%8B%E6%8A%A5%E5%91%8A/","section":"","summary":"","title":"课程报告","type":"tags"},{"content":" 本博客为 Pytorch 的一些基本操作的备忘录，会持续更新。 本文大多来自于 2023 年初学 pytorch 的笔记，后经过整理。\nLLM 生成过于方便，导致很多 pytorch 的操作都忘了很多。\n经常 Debug 很久才发现是很基础的调包问题。\n因此特意整理一些常用的操作作为备忘录。\n其中很多内容来自 2023 年看的 小土堆教程 和 李沐老师的动手学习深度学习\n非常推荐：pytorch 实用教程\ntensor 与 array # 相互转化如下：\nimport numpy as np import torch # numpy 转为 tensor x = np.ones(5) print(type(x)) x = torch.tensor(x) print(type(x)) # tensor 转为 numpy x = torch.ones(5) x_numpy = x.detach().numpy() # detach() 切断计算图，不再计算梯度，但仍共享存储 一般而言，在 cuda 加速时 tensor 在 GPU 上。\nx = torch.ones(5) x = x.detach().cpu().numpy() 当需要使用到标量 tensor 时（比如统计 loss 等），可以将 tensor 标量化。\nloss_value = loss.item() # 现在可以用 loss_value 进行日志记录或其他 Python 计算 print(f\u0026#34;Loss: {loss_value}\u0026#34;) 当然，tensor 和 array 的转化其实没那么简单，比如经常遇到一些类型问题。\n此外，数据从 GPU 到 CPU 转化往往会占用一定的性能，因此能在 tensor 上完成的操作尽量转成 array 再操作。\nPyTorch 操作 NumPy 操作 说明 tensor.clamp() np.clip() 将值限制在指定范围内 torch.cat() np.concatenate() 沿指定维度连接数组 tensor.view() array.reshape() 改变数组形状，不改变数据 tensor.permute() np.transpose() 维度重排 tensor.unsqueeze() np.expand_dims() 增加维度 tensor.repeat() np.tile() 重复数组 tensor.t() array.T 2D张量的转置 dataset 和 dataloader # 实例化 Dataset 作用是告诉程序数据集在哪 并进行转化\n其中 root 表示数据集本地位置，train 表示是否训练，download 表示在线下载\n使用 transforms 中的 Compose 并结合 ToTensor\n在载入数据中可以直接进行转化\n# 此节主要了解部分标准数据集的使用方法 import torchvision from torch.utils.tensorboard import SummaryWriter # 下面开始配合 transform dataset_transform = torchvision.transforms.Compose([ torchvision.transforms.ToTensor() ]) # 下面演示 CIFAR10 数据集 # 其中 root 表示数据集本地位置，train 表示训练，download 表示在线下载 train_set = torchvision.datasets.CIFAR10(root=\u0026#34;./dataset\u0026#34;, train=True, transform=dataset_transform, download=True) test_set = torchvision.datasets.CIFAR10(root=\u0026#34;./dataset\u0026#34;, train=False, transform=dataset_transform, download=True) # 可知数据集格式为 PIL 和 target print(test_set[0]) print(test_set.classes) # 显示数据集的分类 # 获取数据 体会数据类型 img, target = test_set[0] print(img) print(target) print(test_set.classes[target]) writer = SummaryWriter(\u0026#34;logs\u0026#34;) for i in range(10): img, target = test_set[i] writer.add_image(\u0026#34;test_img\u0026#34;, img, i) 相比 DataSet 其更像是一个分拣器，将数据集分成 n 个一组\n可以将 DataSet 理解为牌堆，将 DataLoader 理解为手牌\nDataLoader 也同样有着较多参数，下面进行介绍\nimport torchvision from torch.utils.tensorboard import SummaryWriter # datasets 实例化过程和上一节相同 dataset_transform = torchvision.transforms.Compose([ torchvision.transforms.ToTensor() ]) train_set = torchvision.datasets.CIFAR10(root=\u0026#34;./dataset\u0026#34;, train=True, transform=dataset_transform) test_set = torchvision.datasets.CIFAR10(root=\u0026#34;./dataset\u0026#34;, train=False, transform=dataset_transform) from torch.utils.data import DataLoader # dataset：输入已经实例化的数据集 # batch_size=4：这指定了每个批次中包含的样本数量，模型将会根据每个批次的数据计算梯度并更新模型参数 # shuffle=True：DataLoader 是否在每个 epoch 开始时打乱数据集，以增加训练的随机性 # 1. iteration：1个iteration等于使用batchsize个样本训练一次； # 2. epoch：1个epoch等于使用训练集中的全部样本训练一次； # num_workers=0：这是指定用于数据加载的子进程数量。默认值为 0，表示数据将在主进程中加载，增加 num_workers 可以加速数据加载 # drop_last=False：当数据集的样本数量不能被 batch_size 整除时，如果设置为 True，最后一个不完整的批次会被丢弃；如果设置为 False，最后一个不完整的批次仍然会被保留 test_loader = DataLoader(dataset=test_set, batch_size=4, shuffle=True, num_workers=0, drop_last=False) # 由于 batch_size 为四，则进行四个一组打包 for i, data in enumerate(test_loader): if i \u0026gt; 5: break imgs, targets = data print(\u0026#34;---------\u0026#34;) print(len(imgs)) print(targets) writer = SummaryWriter(\u0026#34;logs\u0026#34;) # 由于 batch_size 为四，则进行四个一组打包 for epoch in range(3): for i, (imgs, targets) in enumerate(test_loader): writer.add_images(\u0026#34;epoch:{}\u0026#34;.format(epoch), imgs, i) writer.close() tensor transforms\n# 注意 此处只是导入 vision 的 transforms # 还有其他领域 如 text 的 transforms from torchvision import transforms from torch.utils.tensorboard import SummaryWriter from PIL import Image writer = SummaryWriter(\u0026#34;tensor_logs\u0026#34;) # 先学习 tensor (张量) 的数据类型 image_path = \u0026#34;data/reality_data/train/ants_image/0013035.jpg\u0026#34; img = Image.open(image_path) print(type(img)) # 将变化工具实例化 tensor_trans = transforms.ToTensor() print(type(tensor_trans)) # 用 tensor_trans 变化 img tensor_img = tensor_trans(img) print(type(tensor_img)) # 可以看到 tensor 本质上是多维数组 可以理解为向量矩阵 print(tensor_img) # 下面结合 TensorBoard 表示 writer.add_image(\u0026#34;tensor\u0026#34;, tensor_img) # 下面演示 Normalize 设置均方和标准差都是 1/2 trans_norm = transforms.Normalize([0.5, 0.5, 0.5], [0.5, 0.5, 0.5]) print(trans_norm) img_norm = trans_norm(tensor_img) print(img_norm) writer.add_image(\u0026#34;Normalize\u0026#34;, img_norm) # 下面演示 Resize # 要注意 Resize 传入的是 PIL，而非 tensor # 其参数传入一个代表正方形 多个表示长宽 print(img.size) trans_resize = transforms.Resize((512, 512)) img_resize = trans_resize(img) print(img_resize.size) # 下一步将新图像转化为张量 img_resize = tensor_trans(img_resize) print(img_resize) writer.add_image(\u0026#34;Resize\u0026#34;, img_resize) # Compose - resize - 2 # Compose 实际上就是组合功能 下面组合 Resize 和 ToTensor trans_resize_2 = transforms.Resize(512) # 前面函数的输出要匹配后面函数的输入 trans_compose = transforms.Compose([trans_resize_2, tensor_trans]) img_resize_2 = trans_compose(img) writer.add_image(\u0026#34;Resize\u0026#34;, img_resize_2, 1) # RandomCrop 随机裁剪 trans_random = transforms.RandomCrop((128, 256)) trans_compose2 = transforms.Compose([trans_random, tensor_trans]) for i in range(10): img_crop = trans_compose2(img) writer.add_image(\u0026#34;RandomCrop\u0026#34;, img_crop, i) writer.close() tensorboard # TensorBoard 是 TensorFlow 中强大的可视化工具，支持标量、文本、图像、音频、视频 TensorBoard 可以为下面 Transforms 的使用铺路 在控制台输入 打开网页即可查看可视化结果\n其中 logs 为名字 需要匹配 SummaryWriter(\u0026quot;\u0026quot;)\ntensorboard --logdir=logs tensorboard --logdir=logs --port=6007 第二个为指定端口号\n当进行更新时 只需要刷新TB网页即可\nfrom torch.utils.tensorboard import SummaryWriter import numpy as np from PIL import Image writer = SummaryWriter(\u0026#34;logs1\u0026#34;) image_path = \u0026#34;data/reality_data/train/ants_image/0013035.jpg\u0026#34; img_PIL = Image.open(image_path) img_array = np.array(img_PIL) print(type(img_array)) # shape 得到的是高度 宽度 通道 # 通道是图像的属性 指的是 RGB print(img_array.shape) # 需要导入的图像是 numpy 类型的 # 需要指定 img_array 的 shape 类型为 H (height) W (weight) C (channel) writer.add_image(\u0026#34;test\u0026#34;, img_array, 1, dataformats=\u0026#39;HWC\u0026#39;) image_path = \u0026#34;data/reality_data/train/bees_image/16838648_415acd9e3f.jpg\u0026#34; img_PIL = Image.open(image_path) img_array = np.array(img_PIL) print(type(img_array)) writer.add_image(\u0026#34;test\u0026#34;, img_array, 2, dataformats=\u0026#39;HWC\u0026#39;) # 下面测试添加函数图像 # 要注意 TB 只支持一个函数一次拟合 多次 add_scalar 不会清空之前的数据 for i in range(100): writer.add_scalar(\u0026#34;y=2x\u0026#34;, -i, i) for i in range(1, 100): writer.add_scalar(\u0026#34;y=1/x\u0026#34;, 1 / i, i) writer.close() 经典 MLP # import torch import torch.nn as nn import torch.optim as optim from torch.utils.data import DataLoader, TensorDataset import matplotlib.pyplot as plt import numpy as np # 设置随机种子 torch.manual_seed(42) # 1. 定义MLP模型 class MLP(nn.Module): def __init__(self, input_size, hidden_size, output_size): super(MLP, self).__init__() # 定义网络层 self.layer1 = nn.Linear(input_size, hidden_size) self.relu = nn.ReLU() self.layer2 = nn.Linear(hidden_size, output_size) def forward(self, x): # 前向传播 x = self.layer1(x) x = self.relu(x) x = self.layer2(x) return x # 2. 生成一些示例数据 x_data = torch.linspace(-5, 5, 200).reshape(-1, 1) y_data = 2 * x_data + torch.randn_like(x_data) * 0.5 # 3. 创建数据集和数据加载器 dataset = TensorDataset(x_data, y_data) dataloader = DataLoader(dataset, batch_size=32, shuffle=True) # 4. 初始化模型、损失函数和优化器 input_size = 1 hidden_size = 10 output_size = 1 model = MLP(input_size, hidden_size, output_size) criterion = nn.MSELoss() optimizer = optim.SGD(model.parameters(), lr=0.01) # 5. 训练循环 num_epochs = 100 loss_history = [] for epoch in range(num_epochs): epoch_loss = 0.0 for batch_x, batch_y in dataloader: # 前向传播 outputs = model(batch_x) loss = criterion(outputs, batch_y) # 反向传播和优化 optimizer.zero_grad() # 清除梯度 loss.backward() # 计算梯度 optimizer.step() # 更新参数 epoch_loss += loss.item() # 记录每个epoch的平均损失 avg_loss = epoch_loss / len(dataloader) loss_history.append(avg_loss) # 每10个epoch打印一次损失 if (epoch + 1) % 10 == 0: print(f\u0026#39;Epoch [{epoch+1}/{num_epochs}], Loss: {avg_loss:.4f}\u0026#39;) # 6. 评估模型 model.eval() with torch.no_grad(): predictions = model(x_data) # 7. 可视化结果 plt.figure(figsize=(12, 5)) # 绘制损失曲线 plt.subplot(1, 2, 1) plt.plot(loss_history) plt.title(\u0026#39;Training Loss\u0026#39;) plt.xlabel(\u0026#39;Epoch\u0026#39;) plt.ylabel(\u0026#39;Loss\u0026#39;) # 绘制预测结果 plt.subplot(1, 2, 2) plt.scatter(x_data.numpy(), y_data.numpy(), label=\u0026#39;Data\u0026#39;, alpha=0.4) plt.plot(x_data.numpy(), predictions.numpy(), \u0026#39;r\u0026#39;, linewidth=2, label=\u0026#39;Prediction\u0026#39;) plt.title(\u0026#39;Model Prediction\u0026#39;) plt.xlabel(\u0026#39;x\u0026#39;) plt.ylabel(\u0026#39;y\u0026#39;) plt.legend() plt.tight_layout() plt.show() # 打印一些模型参数 print(\u0026#34;Model parameters:\u0026#34;) for name, param in model.named_parameters(): print(f\u0026#34;{name}: {param.data}\u0026#34;) 经典 CNN # 卷积层 # 不在此处写卷积原理了 一般在初始化中定义好卷积函数 conv1, conv2 一般调用 Conv2d 包，其他很少使用 卷积核由种子随机生成，在后续的反向传播中调整 Conv2d 使用方法\nin_channels 指输入通道 彩色图一般为 3\nout_channels 是输出通道 指的是用n个卷积核得到n个结果通道\nkernel_size 是卷积核的大小\nstride 是步长 默认为一\npadding 指是否填充原图像边缘 默认填充零\n池化层 # 常用最大池化，即在一定范围矩阵内取最大值\n主要目的是降低数据维度\n常用 MaxPool2d 其参数大部分和卷积相同\nceil_mode 当为True时，其输出大小为向上取整，简单来说，和 padding 类似，不足剩余卷积核的部分是否选最大值出\nimport torch import torchvision from torch import nn, reshape, flatten from torch.nn import Conv2d, MaxPool2d, ReLU, Linear, Flatten from torch.utils.data import DataLoader from torch.utils.tensorboard import SummaryWriter # 之前解释过的 dataset 和 dataloader dataset = torchvision.datasets.CIFAR10(\u0026#34;./dataset\u0026#34;, train=False, transform=torchvision.transforms.ToTensor()) dataloader = DataLoader(dataset, batch_size=64) class MY_NN(nn.Module): def __init__(self): super(MY_NN, self).__init__() # 第一个卷积卷积函数 # in_channels 指输入通道 彩色图一般为 3 # out_channels 是输出通道 指的是用n个卷积核得到n和结果通道 # kernel_size 是卷积核的大小 # stride 是步长 默认为一 # padding 指是否填充原图像边缘 默认填充零 self.conv1 = Conv2d(in_channels=3, out_channels=6, kernel_size=3, stride=1, padding=0) # 向前传播进行一层卷积 def forward(self, x): x = self.conv1(x) return x my_nn = MY_NN() writer = SummaryWriter(\u0026#34;logs\u0026#34;) for step, (imgs, targets) in enumerate(dataloader): if step == 0: print(imgs.shape) # 注意此处是 add_images writer.add_images(\u0026#34;input\u0026#34;, imgs, step) output = my_nn(imgs) if step == 0: print(output.shape) # 此处的 output 是六通道 无法直接输出 # 强制转化为三通道或一通道进行输出 # -1 表示自动判断批处理大小 output = reshape(output, (-1, 3, 30, 30)) writer.add_images(\u0026#34;output_conv\u0026#34;, output, step) # 最大池化层 class MY_NN_Pool(nn.Module): def __init__(self): super(MY_NN_Pool, self).__init__() # kernel_size stride padding 与卷积操作相同 # ceil_mode 当为True时，其输出大小为向上取整，简单来说，和 padding 类似，不足剩余卷积核的部分是否选最大值 self.maxpool1 = MaxPool2d(kernel_size=3, padding=0, ceil_mode=True) # 向前传播进行一层卷积 def forward(self, x): x = self.maxpool1(x) return x my_nn_pool = MY_NN_Pool() for step, (imgs, targets) in enumerate(dataloader): output = my_nn_pool(imgs) if step == 0: print(output.shape) output = reshape(output, (-1, 3, 30, 30)) writer.add_images(\u0026#34;output_pool\u0026#34;, output, step) # 激活函数 class MY_NN_Activitions(nn.Module): def __init__(self): super(MY_NN_Activitions, self).__init__() # inplace 为 True 时为浅拷贝，否则为深拷贝 self.relu1 = ReLU(inplace=False) # 向前传播进行一层卷积 def forward(self, x): x = self.relu1(x) return x class MY_NN_linear(nn.Module): def __init__(self): super(MY_NN_linear, self).__init__() # 注意线性变化是一维的 # in_features 要匹配输入大小，设置 out_features 是指定输出大小，bias 指是否偏置 # 此处的 196608 是为了适配输入 self.linear1 = Linear(in_features=196608, out_features=10, bias=False) # 向前传播进行一层卷积 def forward(self, x): # 我的 dataloader 会取不完整的一个 bitch_size 因此会导致最后一个保证 # 因此需要加一个判断 size 的操作 if x.shape == torch.Size([196608]): x = self.linear1(x) return x my_nn_linear = MY_NN_linear() for i, (imgs, targets) in enumerate(dataloader): # 由于输入要是一位的 则需要将其拍扁 output = flatten(imgs) if i == 0: print(output) output = my_nn_linear(output) if i == 0: print(output) writer.close() # 测试上面的方法 class NN_final_test(nn.Module): def __init__(self): super(NN_final_test, self).__init__() self.model1 = nn.Sequential( Conv2d(3, 32, 5, padding=2), MaxPool2d(2), Conv2d(32, 32, 5, padding=2), MaxPool2d(2), Conv2d(32, 64, 5, padding=2), Flatten(), Linear(4096, 64), Linear(64, 10), ) def forward(self, x): x = self.conv1(x) x = self.maxpool1(x) x = self.conv2(x) x = self.maxpool2(x) x = self.conv3(x) x = self.flatten(x) x = self.liner1(x) x = self.liner2(x) return x nn_final_test = NN_final_test() print(nn_final_test) for imgs, targets in dataloader: print(imgs) print(nn_final_test.model1(imgs)) break # 交叉熵损失函数 loss = nn.CrossEntropyLoss() # 优化器 也就是反向传播算法 # 此处用 SGD 随机梯度下降，传入参数与学习率 optim = torch.optim.SGD(nn_final_test.parameters(), lr=0.01) # 进行多轮学习 for epoch in range(20): run_loss = 0 # 计算累计损失率 for imgs, targets in dataloader: outputs = nn_final_test(imgs) result_loss = loss(outputs, targets) # 传入输入和目标函数 optim.zero_grad() # 将梯度清零 result_loss.backward() # 重新计算梯度 optim.step() # 执行 SGD run_loss += result_loss print(run_loss) ","date":"2025 年 3 月 6 日","externalUrl":null,"permalink":"/posts/pytorch_memo/","section":"","summary":"","title":"Pytorch 备忘录","type":"posts"},{"content":" “资源分配型” 动态规划的总结与例题，还包含背包问题的理解。 前言 # 资源分配型动态规划一般题目会表达为：在序列化结构（数组、字符串等）中，用有限的操作资源完成特定操作，使最终收益最大或代价最小。\n注意，这种题目也可能使用搜索，而使用动态规划的关键是：\n当前是否使用资源会影响后续状态 是否有重复子问题 此外，从时间复杂度也能看出该选择此类动态规划，一般该类问题复杂度为: $$O(m n)$$ 其中 n 是数组长度，m 是资源数量。\n通常模板 # 状态定义 # ​\tdp[i][j] = 处理前 i 个元素时，使用 j 次资源后的最优解（最大收益/最小代价）\n状态转移 # 决策 1：不使用资源\ndp[i][j] = dp[i-1][j] + 当前代价（如白砖 + 1，股票未交易保持状态等）\n决策 2：使用资源\nif j \u0026gt;= 1: dp[i][j] = max/min(dp[i - L][j - 1], \u0026hellip;) # L 为资源覆盖长度\n初始化 # 基准状态\ndp[0][0] = 初始代价/收益（如第一个元素是否被覆盖）\n资源越界处理\nfor i in range(L): # 比如前 L 个元素使用一次资源的情况\n用地毯覆盖后的最少白色砖块 # \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e 2209. 用地毯覆盖后的最少白色砖块 原题 # 给你一个下标从 0 开始的二进制字符串 floor，它表示地板上砖块的颜色。\nfloor[i] = '0' 表示地板上第 i 块砖块的颜色是黑色 floor[i] = '1' 表示地板上第 i 块砖块的颜色是白色 同时给你 numCarpets 和 carpetLen。你有 numCarpets 条黑色的地毯，每一条黑色的地毯长度都为 carpetLen 块砖块。请你使用这些地毯去覆盖砖块，使得未被覆盖的剩余白色砖块的数目最小。地毯相互之间可以覆盖。\n请你返回没被覆盖的白色砖块的最少数目。\n示例：\n输入：floor = \u0026#34;10110101\u0026#34;, numCarpets = 2, carpetLen = 2 输出：2 如右侧所示：░█▒▒█▒█░，灰色是被地毯覆盖 思路与题解 # 其中地砖为进度轴、地毯为资源轴。\n设置地砖为 i，地毯为 j，则状态定义为：前 i 个地砖用 j 个地毯后的最小白砖数量。\n状态转移方程见下面代码的注释：\n# 动态规划，有限资源分配问题 # 如果想到状态定义就不算难：前 i 个地砖用 j 个地毯后的最小白砖数量 class Solution: def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -\u0026gt; int: n = len(floor) dp = [[inf] * (numCarpets + 1) for _ in range(n)] dp[0][0] = int(floor[0]) for i in range(carpetLen): # 前 carpetLen 个白格被盖住 dp[i][1] = 0 for i in range(n): for j in range(numCarpets + 1): if floor[i] == \u0026#39;1\u0026#39;: # 如果是白格，最小格子数加一 dp[i][j] = min(dp[i][j], dp[i - 1][j] + 1) if floor[i] == \u0026#39;0\u0026#39;: # 黑格不加 dp[i][j] = min(dp[i][j], dp[i - 1][j]) if i - carpetLen \u0026gt;= 0 and j - 1 \u0026gt;= 0: # 贪心，尽量让地毯不重复铺 dp[i][j] = min(dp[i - carpetLen][j - 1], dp[i][j]) # 如果最后地毯没用完，说明一定可以使得白砖全部被铺满 return dp[n - 1][numCarpets] if dp[n - 1][numCarpets] != inf else 0 买卖股票的最佳时机 IV # \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e 188. 买卖股票的最佳时机 IV 原题 # 给你一个整数数组 prices 和一个整数 k，其中 prices[i] 是某支给定的股票在第 i 天的价格。\n设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。也就是说，你最多可以买 k 次，卖 k 次。\n注意：你不能同时参与多笔交易（即，你必须在再次购买之前出售掉之前的股票）。\n示例 1：\n输入：k = 2, prices = [2, 4, 1] 输出：2 解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4 - 2 = 2。 示例 2：\n输入：k = 2, prices = [3, 2, 6, 5, 0, 3] 输出：7 解释： 在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出，这笔交易所能获得利润 = 6 - 2 = 4。 随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出，这笔交易所能获得利润 = 3 - 0 = 3 提示：\n0 \u0026lt;= k \u0026lt;= 100\n0 \u0026lt;= prices.length \u0026lt;= 1000\n0 \u0026lt;= prices[i] \u0026lt;= 1000\n思路与题解 # 此题用 记忆化搜索 要简单一些，其原理和上面的动态规划相同。\n同样是 i 表示进度轴，j 表示 资源数量。\n根据题目要求，要多一个 当前是否持有股票 的状态。\n# 记忆化搜索或 DP # 此题记忆化搜索好想一点 class Solution: def maxProfit(self, k: int, prices: List[int]) -\u0026gt; int: n = len(prices) @cache # i 是数组下标即当前最后统计的元素，记忆化搜索从后向前容易 # j 是当前剩余的买卖次数 # hold 标记当前是否存有股票 # 如果转成 DP 需要三维 def dfs(i : int, j : int, hold : bool) -\u0026gt; int: if (j == -1): # 次数都用完了 直接返回 # 此处用 -inf 是防止 -inf + price[i] 超过 0 的情况 return -inf if (i == -1): # 返回 -1 代表不可能递归到第一个数时还持有股票 # 实际上存的是第 0 天的两个状态 return -inf if hold else 0 if hold: # 两种可能 前为刚买的 后为之前就存有的，j 只需要在购买时维护 return max(dfs(i - 1, j - 1, False) - prices[i], dfs(i - 1, j, True)) else: # 两种可能 前为刚卖的 后为之前就没有 return max(dfs(i - 1, j, True) + prices[i], dfs(i - 1, j, False)) return dfs(n - 1, k, False) # 最后一定是不持有股票 其他题目 # \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e 410. 分割数组的最大值 状态定义是：数组中前 i 个数在当前切割成 j 个数组\n此外，该题也需要使用前缀和来获取 o1 的区间求和。\n背包问题 # 背包问题，也可以看作这种类型的动态规划。\n一般而言分成 01背包 和 完全背包。\n01背包：每个物品只能选一次。\n完全背包：每个物品可以重复选。\n两者状态定义为：前 i 个物品在容量为 j 的背包中的最大价值\n状态转移方程分别为：（1为01背包、2为完全背包）\ndp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weights[i - 1]] + values[i - 1]) dp[i][j] = max(dp[i - 1][j], dp[i][j - weights[i - 1]] + values[i - 1]) 两道零钱兑换 # \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e 322. 零钱兑换 给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。\n计算并返回可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。\n你可以认为每种硬币的数量是无限的。\n示例 1：\n输入：`coins = [1, 2, 5]`, `amount = 11` 输出：`3` 解释：11 = 5 + 5 + 1 题解：\n此题是经典的完全背包问题。\n但由于其要得到的是最少硬币数量，因此可以看作每个硬币的价值相同（其中的价值不是 amount，而是上面状态转移方程中的 value[]）。\n因此可以节省一个维度，代码如下：\nclass Solution: def coinChange(self, coins: List[int], amount: int) -\u0026gt; int: # DP下标是当前金额 内容是硬币数量 dp = [inf] * (amount + 1) dp[0] = 0 for coin in coins: for i in range(1, amount + 1): if i \u0026lt; coin: continue dp[i] = min(dp[i], dp[i - coin] + 1) return dp[amount] if dp[amount] != inf else -1 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e 518. 零钱兑换 Ⅱ 给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。\n请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。\n假设每一种面额的硬币有无限个。\n题目数据保证结果符合 32 位带符号整数。\n示例 1：\n输入：amount = 5, coins = [1, 2, 5] 输出：4 解释：有四种方式可以凑成总金额： 5=5 5=2+2+1 5=2+1+1+1 5=1+1+1+1+1 题解：\n此题要的是凑出最大零钱的种类，那么为什么不能直接用Ⅰ的思路？ Ⅰ的遍历顺序无关：因为求的是最小值，无论是先遍历硬币还是金额，最终都能得到最少硬币数（例如 coins = [1,2,5]，amount=5，无论顺序如何，最少硬币数都是1）。 Ⅱ的遍历顺序关键：组合数的统计必须避免重复计数（例如 2+1+1 和 1+2+1 视为同一种组合）。 Ⅱ先遍历硬币，后遍历金额的遍历顺序，可以看作通过固定硬币的遍历顺序，保证组合的唯一性。 class Solution: def change(self, amount: int, coins: List[int]) -\u0026gt; int: dp = [0] * (amount + 1) dp[0] = 1 for coin in coins: for i in range(coin, amount + 1): dp[i] += (dp[i - coin]) return dp[amount] ","date":"2025 年 2 月 21 日","externalUrl":null,"permalink":"/posts/%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%BC%8F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","section":"","summary":"","title":"“资源分配型” 动态规划总结","type":"posts"},{"content":"","date":"2025 年 2 月 21 日","externalUrl":null,"permalink":"/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","section":"","summary":"","title":"背包问题","type":"tags"},{"content":"","date":"2025 年 2 月 21 日","externalUrl":null,"permalink":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","section":"","summary":"","title":"动态规划","type":"tags"},{"content":"","date":"2025 年 2 月 21 日","externalUrl":null,"permalink":"/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/","section":"","summary":"","title":"记忆化搜索","type":"tags"},{"content":"","date":"2025 年 2 月 21 日","externalUrl":null,"permalink":"/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","section":"","summary":"","title":"算法与数据结构","type":"categories"},{"content":"","date":"2025 年 2 月 19 日","externalUrl":null,"permalink":"/tags/%E5%8D%9A%E5%BC%88/","section":"","summary":"","title":"博弈","type":"tags"},{"content":" 原题链接：点击这里访问 题目描述 # 贝茜和埃尔茜发现了一行 \\(N\\) 个蛋糕（\\(N\\) 为偶数），大小依次为 \\(a_1, a_2, \\dots, a_N\\)。\n两头奶牛都想吃到尽可能多的蛋糕。但是，作为非常文明的奶牛，她们决定玩一个游戏来分割蛋糕！\n游戏在两头奶牛之间轮流进行回合。\n每个回合进行以下两者之一：\n贝茜 选择两个相邻的蛋糕并将它们堆叠起来，制造大小为两者大小之和的一个新蛋糕。 埃尔茜 选择最左边或最右边的蛋糕藏起来。 当只剩下一个蛋糕时，贝茜吃掉它，而埃尔茜吃掉她藏起来的所有蛋糕。\n如果两头奶牛都采取最优策略以最大化她们吃到的蛋糕量，并且贝茜先进行回合，那么每头奶牛将会吃到多少蛋糕？\n输入格式\n每个测试点包含 \\(T\\) 个独立的测试用例。\n每个测试用例的格式如下：\n第一行包含整数 \\(N\\)。 第二行包含 \\(N\\) 个空格分隔的整数 \\(a_1, a_2, \\dots, a_N\\)。 输出格式\n对于每个测试用例，输出一行，包含两个整数 (b) 和 (e)，表示贝茜和埃尔茜在两头奶牛都采取最优策略的情况下分别吃到的蛋糕量。\n数据范围\n\\(1 \\leq T \\leq 10\\) \\(2 \\leq N \\leq 5 \\times 10^5\\) \\(1 \\leq a_i \\leq 10^9\\) 输入保证一个测试点中的所有 \\(N\\) 之和不超过 \\(10^6\\)。 输入样例\n2 4 40 30 20 10 4 10 20 30 40 输出样例\n60 40 60 40 样例解释\n对于第一个测试用例，在最优策略下：\n贝茜将堆叠中间两个蛋糕。现在蛋糕的大小为 [40, 50, 10]。 埃尔茜将吃掉最左边的蛋糕。现在剩余的蛋糕的大小为 [50, 10]。 贝茜堆叠剩余的两个蛋糕。 最终，贝茜将吃到 \\(30+20+10=60\\) 的蛋糕，而埃尔茜将吃到 \\(40\\) 的蛋糕。\n第二个测试用例是第一个测试用例反转的情况，因此答案相同。\n解题思路 # 根据数据规模可知时间复杂度最多支持 nlogn 因此可以排除 博弈论 和 动态规划（DP） 这类通常需要 O(n²) 或更高复杂度的解法。我们需要找到更优的解法，如 贪心 或 二分查找 + 前缀和 等方法。\n因此想去找博弈通解：\n埃尔茜只能吃 n // 2 - 1 个\n埃尔茜每次都会吃当前左右两边中最小的蛋糕\n贝茜的最优策略是不合并靠近左右边界的蛋糕\n这样可以让埃尔茜的选择变得更有限，从而使她的总得分尽可能小\n因此贝茜吃到的是连续 n // 2 + 1 个蛋糕的最小和\no1区间求和 -\u0026gt; 前缀和\n题解 # import math t = int(input()) while t \u0026gt; 0: t -= 1 # python 循环输入不能写 while t -= 1 n = int(input()) arr = list(map(int, input().split())) sum_arr = sum(arr) sum_min = math.inf prefix = [0] * (n + 1) for i in range(1, n + 1): prefix[i] = prefix[i - 1] + arr[i - 1] for i in range(n // 2 + 1, n + 1): sum_min = min(sum_min, prefix[i] - prefix[i - n // 2 - 1]) # print(\u0026#34;@\u0026#34;, sum_min) print(sum_min, sum_arr - sum_min) ","date":"2025 年 2 月 19 日","externalUrl":null,"permalink":"/posts/cake-game/","section":"","summary":"","title":"蛋糕游戏题解 - 贪心博弈","type":"posts"},{"content":"","date":"2025 年 2 月 19 日","externalUrl":null,"permalink":"/tags/%E5%89%8D%E7%BC%80%E5%92%8C/","section":"","summary":"","title":"前缀和","type":"tags"},{"content":"","date":"2025 年 2 月 19 日","externalUrl":null,"permalink":"/tags/%E8%B4%AA%E5%BF%83/","section":"","summary":"","title":"贪心","type":"tags"},{"content":" 此博客为数论基础板子，以及一些注意事项和例题。 数论内容知识点比较零碎且容易遗忘，因此便对其进行总结。\n内容都为数论基础知识点，板子主要用 C++ 表示。\n快速幂 # 标准的 a ^ b mod p 形式的快速幂：\nlong long fast_pow(long long a, long long b, long long mod) { long long res = 1; long long base = a % mod; while (b) { if (b \u0026amp; 1) res = (res * base) % mod; base = (base * base) % mod; b \u0026gt;\u0026gt;= 1; } return res; } 时间复杂度为:\n$$ O(\\log b) $$\n如果要考虑非正数整数则：\ndouble newX = 0; if (b == 0) return 1; if (b \u0026lt; 0) { b = -b; newX = 1 / x; } C++ 的 pow() 库函数处理的是浮点数，因此在运行数值较大是会出现精度错误。在比赛或面试中，遇到指数大于十的幂运算时，就建议手搓快速幂。\npython 的 pow() 不会有这个问题，可以放心使用。\n标准的 a ^ b 形式的快速幂：\nlong long fast_pow(long long a, long long b) { long long res = 1; long long base = a; while (b) { if (b \u0026amp; 1) res = (res * base); base = (base * base); b \u0026gt;\u0026gt;= 1; } return res; } 最大公约数 # 一般而言，用库函数就可以了。\n注意 gcd() 在 c++17 才引用，C++11 用 __gcd()。\n辗转相除法的思想要了解下。\nlong long my_gcd(long long a, long long b) { return __gcd(a, b); // // 辗转相除法 // return b == 0 ? a : gcd(b, a % b); } 最小公倍数 # 最小公倍数为 abs(a * b) / __gcd(a, b)\nlong long lcm(long long a, long long b) { return abs(a * b) / __gcd(a, b); } 素数筛 # 素数筛目的是找出 2 到 n 的所有素数（即质数）。\n埃式筛 # 埃式筛的基本思想从 2 到 N 枚举，如果当前数未被标记为合数，则其为素数，并将它的倍数全部标记为合数。\nvector\u0026lt;bool\u0026gt; sieve_of_eratosthenes(int n) { vector\u0026lt;bool\u0026gt;is_prime(n + 1, true); // 0 和 1 不是素数 is_prime[0] = false; is_prime[1] = false; for(int i = 2; i * i \u0026lt;= n; i++) if (is_prime[i]) for (int j = i * i; j \u0026lt;= n; j += i) is_prime[j] = false; return is_prime; } 时间复杂度：\n$$O\\left(n \\log \\log n\\right)$$\n线性筛 # 相比埃式筛多维护一个已确定的质数数组。\nvector\u0026lt;bool\u0026gt; sieve_of_eratosthenes(int n) { vector\u0026lt;bool\u0026gt; is_prime(n + 1, true); vector\u0026lt;int\u0026gt; primes; is_prime[0] = is_prime[1] = false; for (int i = 2; i \u0026lt;= n; i++) { if (is_prime[i]) { primes.push_back(i); } for (int p : primes) { if (i * p \u0026gt; n) break; // 超出范围 is_prime[i * p] = false; // 标记 i * p 为非素数 if (i % p == 0) break; // 保证每个数只被其最小质因数筛选一次 } } return is_prime; // 返回布尔数组 } 时间复杂度：\n$$O(n)$$\n质因数分解 # 获取小于 n 的质因数集合。\n质因数：能整除 n 的质数。 基本思想如下：\nn 的质因数最大不会超过 sqrt(n)。 从小到大找 n 的因数，每找到一个就将 n 反复除去该因数。 vector\u0026lt;long long\u0026gt; primeDivide(long long n) { vector\u0026lt;long long\u0026gt;ans; for (long long i = 2; i * i \u0026lt;= n; i++) { if (n % i == 0) { ans.push_back(i); // 如果要统计每个质因数的个数要在此处计数 while (n % i == 0) { n /= i; } } } // n 本身是质数 要特判 if (n \u0026gt; 1) { ans.push_back(n); } return ans; } 时间复杂度：\n$$O(\\sqrt{n})$$\n例题：\n蓝桥杯 完全平方数 - 完全平方数的每个质因数的指数都是偶数\nCSP认证 因子化简 - 质因数板子加简单判断\n欧拉函数 # 求不超过 n 并且和 n 互为质数的个数。\n互质：n 不为 m 的因数，m 也不为 n 的因数。 上面的质因数分解得到了 n 因数中的质数。\n根据下面的欧拉函数：\n$$\\phi(n) = n \\prod_{p \\mid n} \\left( 1 - \\frac{1}{p} \\right)$$\n$$\\phi(n) = n \\left( 1 - \\frac{1}{p_1} \\right) \\left( 1 - \\frac{1}{p_2} \\right) \\cdots \\left( 1 - \\frac{1}{p_k} \\right)$$\nlong long euler(long long n, long long MOD) { // 1 的欧拉函数是 0 if (n == 1) return 0; vector\u0026lt;long long\u0026gt;factor; factor = primeDivide(n); // 如果 n 本身是质数，注意不能用 size 为 1 判断 if (factor[0] == n) { return (n - 1) % MOD; } long long ans = n; for (auto \u0026amp;i : factor) { // 欧拉函数的公式 ans = ans * (i - 1) / i % MOD; // 注意要这样写才能不触发向下取整 } return ans; } 时间复杂度：\n$$O(\\sqrt{n})$$\n例题：\n蓝桥杯 互质数的个数 - 欧拉函数板子\n","date":"2025 年 2 月 15 日","externalUrl":null,"permalink":"/posts/%E6%95%B0%E8%AE%BA%E5%9F%BA%E7%A1%80/","section":"","summary":"","title":"基础数论 - 模板 \u0026 分析","type":"posts"},{"content":"","date":"2025 年 2 月 15 日","externalUrl":null,"permalink":"/tags/%E6%A8%A1%E6%9D%BF/","section":"","summary":"","title":"模板","type":"tags"},{"content":"","date":"2025 年 2 月 15 日","externalUrl":null,"permalink":"/tags/%E6%95%B0%E8%AE%BA/","section":"","summary":"","title":"数论","type":"tags"},{"content":"","date":"2025 年 2 月 14 日","externalUrl":null,"permalink":"/tags/%E9%9D%A2%E8%AF%95/","section":"","summary":"","title":"面试","type":"tags"},{"content":"","date":"2025 年 2 月 14 日","externalUrl":null,"permalink":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","section":"","summary":"","title":"设计模式","type":"tags"},{"content":" 本博客为吉林大学设计模式本科课程复习笔记。内容参考了教案和 gonghr 学长的博客。 如果你在准备考试，可以看下面根据历年题总结出的重点排序。\n吉林大学软件学院2022级考试几乎完美符合下面总结的重点。\n1.重要度从高到低：\n​\t组合 or 装饰\n​\t状态 or 策略\n​\t适配器 + 桥接（或其他）or 外观\n​\t观察者 or 中介者\n​\t抽象工厂 or 建造者（大概率抽象工厂）\n​\t其他小点：原型，代理，单例，命令，职责链，迭代器\n2.很少考察的内容：\n​\t模板方法不单独考（大概率配合策略模式）\n​\t简单工厂和工厂方法大概率被抽象工厂替代考察\n​\t迭代器和命令难度较高（没考过）\n3.多模式混用：\n​\t适配器 + 其他（大概率桥接）\n​\t模板方法 + 策略模式\n​\t装饰 + 组合\n​\t命令模式 + 其他（难度较高）\n面向对象七原则 # 1. 开闭原则 (OCP) # 定义：软件实体（类、模块、函数等）应该对扩展开放，对修改关闭。\n解释：需要对某个功能进行扩展时，不应该修改已有的代码，而应该通过增加新的代码。此外开闭原则较难实现，尽量接近满足开闭原则即可。\n举例：如果要添加一个三角形的面积计算功能，应该通过扩展一个新的类（如 TriangleAreaCalculator），而不是直接修改现有的 Shape 类。\n2. 里氏代换原则 ( LSP) # 定义：子类对象必须能够替换掉父类对象，并且程序的行为不会发生变化。\n解释：子类应该能够在任何使用父类的地方使用。即父类不应该有子类没实现的功能。\n举例：如果我们有一个父类 Bird，其中有一个方法 fly()，那么如果我们创建了一个 Penguin 子类，它不应该继承 fly() 方法（因为企鹅不能飞）。\n3. 迪米特原则 (LoD) # 定义：也称为“最少知识原则”，一个对象应该尽可能少地了解其他对象。不和陌生人说话，进而降低耦合。\n解释：不希望陌生的类之间建立直接的联系。如果真的有需要建立联系，也希望能通过它的友元类来转达。因此，应用迪米特法则有可能造成的一个后果就是：系统中存在大量的中介类。\n举例：假设有如下代码：a.getB().getC().method()。根据迪米特原则，这种深层次的链式调用是不推荐的。更好的方式是让 a 对象直接提供一个方法调用 method()，而不是通过 B 和 C 对象间接调用。\n4. 单一职责原则 (Single Responsibility Principle, SRP) # 定义：一个类应该只有一个引起变化的原因，或者说一个类应该只负责一件事。\n举例：假设有一个类 UserManager，它同时负责用户的管理和日志记录。根据单一职责原则，应该将日志记录的功能提取到一个独立的 Logger 类中，这样 UserManager 只负责用户管理。\n5. 接口隔离原则 (Interface Segregation Principle, ISP) # 定义：客户端不应该被迫依赖它不使用的接口。\n解释：不应该强迫子类实现其不需要的父类接口。\n举例：假设有一个接口 Worker，其中包含 work() 和 eat() 方法。如果 robot（机器人不需要吃饭）只需要 work() 方法而不需要 eat() 方法，那么应该将接口拆分为 Worker 和 Eater 两个接口。\n解决方法： 6. 依赖倒置原则 (Dependency Inversion Principle, DIP) # 定义：高层模块不应该依赖于低层模块，二者都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。此处的依赖不是面向对象关系的依赖，而与语义上的依赖。\n解释：这个原则提倡通过依赖接口或抽象类，而不是依赖具体实现类，来降低系统的耦合性和提高模块的可扩展性。高层模块不应该直接依赖于低层模块的具体实现，而应该依赖于抽象。\n举例： 7. 组合 / 聚合复用原则 (Composition/Aggregation Reuse Principle, CARP) # 定义：尽可能使用对象的组合/聚合，而不是通过继承来实现复用。\n解释：组合和聚合相比继承更加灵活，它们通过将现有类作为新的类成员来实现功能复用，而不是通过继承来扩展类的行为。这样可以避免因为继承而导致的类之间的强耦合和层次结构的僵化。\n举例：假设有一个类 Car，它需要具备 Engine 的功能，而不是通过继承 Engine 类来实现 Car 的动力系统功能，应该通过组合的方式，让 Car 包含一个 Engine 对象，这样可以更好地实现代码复用。\n通过组合/聚合复用的优缺点 优点：\n新对象存取成员对象的唯一方法是通过成员对象的接口； 这种复用是黑箱复用，因为成员对象的内部细节是新对象所看不见的； 这种复用更好地支持封装性； 这种复用实现上的相互依赖性比较小； 每一个新的类可以将焦点集中在一个任务上； 这种复用可以在运行时间内动态进行，新对象可以动态的引用与子对象类型相同的对象。 作为复用手段可以应用到几乎任何环境中去。 缺点: 就是系统中会有较多的对象需要管理。 通过继承来进行复用的优缺点 优点：\n新的实现较为容易，因为基类的大部分功能可以通过继承的关系自动进入派生类。 修改和扩展继承而来的实现较为容易。 缺点： 继承复用破坏封装性，因为继承将基类的实现细节暴露给派生类。由于基类的内部细节常常是对于派生类透明的，所以这种复用是透明的复用，又称“白箱”复用。 如果基类发生改变，那么派生类的实现也不得不发生改变。 从基类继承而来的实现是静态的，不可能在运行时间内发生改变，没有足够的灵活性。 UML图 # 基础画法如下：\n注意要区分实现和继承的核心是区分 interface 和 abstract 类。\n设计模式定义 # 设计模式的基本要素:\n•模式名称 (Pattern name)\n•问题 (Problem)\n•解决方案 (Solution)\n•效果 (Consequences)\n三大类模式 # 创建型模式主要用于创建对象。\n结构型模式主要用于处理类或对象的组合。\n行为型模式主要用于描述对类或对象怎样交互和怎样分配职责。\n类模式和对象模式 # 类模式处理类和子类之间的关系，这些关系通过继承建立，在编译时刻就被确定下来，是属于静态的。\n静态：你可以通过 Factory.create() 直接调用该方法，而不需要创建 Factory 的实例。\n// 静态工厂方法，通过传入的参数决定创建哪种对象 public static Animal createAnimal(String type) { if (\u0026#34;dog\u0026#34;.equalsIgnoreCase(type)) { return new Dog(); } else if (\u0026#34;cat\u0026#34;.equalsIgnoreCase(type)) { return new Cat(); } return null; } 对象模式处理对象间的关系，这些关系在运行时刻变化，更具动态性。\n类模式：主要解决类之间的继承和实现问题，通过继承和接口实现来复用和扩展行为。（extends和implements）\n对象模式：主要处理对象之间的组合、依赖、聚合等关系，通过组合对象来灵活地扩展功能和行为。（依赖、关联、组合、聚合）\nGoF设计模式（分类表格） # 创建型模式 # 创建型模式特点： # 客户不知道对象的具体类是什么：\n客户端代码不需要知道具体创建对象的类是什么，它只依赖于抽象类或接口。这种方式使得客户端代码与具体的实现类解耦，提升了代码的灵活性和可维护性。 好处：如果对象的具体实现发生变化，客户端代码不必修改，因为它依赖的是抽象接口，而不是具体类。 隐藏了对象实例是如何被创建和组织的：\n创建型模式将对象创建的逻辑封装在类或方法内部，客户端无需关心具体的创建细节。可以通过工厂方法、建造者模式等方式动态地创建不同类型的对象。 好处：对象的创建逻辑可以根据需求动态变化，并且可以轻松替换或扩展对象的创建方式，而不影响客户端代码。 使用场景：\n当你在代码中频繁使用 new 运算符来创建对象时，可以考虑使用创建型模式，将对象的创建逻辑抽象出来，从而提升代码的灵活性、可扩展性和可维护性。\n简单工厂模式（静态工厂方法） # 实现简单工厂模式的难点就在于 “如何选择”实现\n1. 优点： # 职责分离：工厂类负责产品对象的创建，客户端只需消费产品，无需关心创建细节。 降低耦合：客户端不需要知道具体产品类名，只需传递参数即可，减少了代码耦合。 提高灵活性：通过配置或参数化创建，可以动态更换或增加产品类，而无需修改客户端代码。 简化客户端代码：创建逻辑集中在工厂类中，简化了客户端的实现。 2. 缺点： # 单一故障点：工厂类集中所有创建逻辑，若出错会影响整个系统。 增加复杂度：增加了系统中的类，特别是当产品较少时，工厂类显得冗余。 扩展性差：每次新增产品都需修改工厂类，违背“开闭原则”，产品多时工厂逻辑复杂化。 无法继承：使用静态方法创建产品，限制了工厂类形成继承结构，降低了灵活性。 3. 适用场景： # 对象创建较少，逻辑简单。 客户端不关心创建细节，只需提供参数即可。 完整代码示例：\n// 注意静态体现在 public static // 简单工厂模式和工厂方式模式都是类模式，是静态的 public class TVFactory { public static TV produceTV(String brand) throws Exception { if(brand.equalsIgnoreCase(\u0026#34;Haier\u0026#34;)) { System.out.println(\u0026#34;电视机工厂生产海尔电视机！\u0026#34;); return new HaierTV(); } else if(brand.equalsIgnoreCase(\u0026#34;Hisense\u0026#34;)) { System.out.println(\u0026#34;电视机工厂生产海信电视机！\u0026#34;); return new HisenseTV(); } else { throw new Exception(\u0026#34;对不起，暂不能生产该品牌电视机！\u0026#34;); } } } public class HaierTV implements TV { public void play() { System.out.println(\u0026#34;海尔电视机播放中......\u0026#34;); } } public class HisenseTV implements TV { public void play() { System.out.println(\u0026#34;海信电视机播放中......\u0026#34;); }\t} public interface TV { public void play(); } // 在另一个样例中，product 可以用 abstract 类，使用实线空箭头 public abstract class User { public void sameOperation() { System.out.println(\u0026#34;修改个人资料！\u0026#34;); } public abstract void diffOperation(); } 工厂方法模式(Factory Method) # 工厂方法模式的本质是：延迟到子类来选择实现。\n工厂方法模式很好的体现了**“依赖倒置原则”和“开闭原则”**。\n工厂可以是抽象类，也可以是具体类\n代码示例：\n// 最上面和最下面的两个接口 public interface TV { public void play(); } public interface TVFactory { public TV produceTV(); } // 具体工厂 public class HisenseTVFactory implements TVFactory { public TV produceTV() { System.out.println(\u0026#34;海信电视机工厂生产海信电视机。\u0026#34;); return new HisenseTV(); } } // 具体产品 public class HisenseTV implements TV { public void play() { System.out.println(\u0026#34;海信电视机播放中......\u0026#34;); }\t} 抽象工厂模式(Abstract Factory) # 一个具体工厂可以 creat 多个具体产品，就是抽象工厂模式。\n抽象工厂模式的本质是：选择产品簇的实现。\n1. 模式优点： # 隔离具体类的生成：客户端无需知道具体的产品类名，只需要通过抽象工厂接口创建产品，降低了系统的耦合性。 易于更换具体工厂：通过更换具体工厂的实例，可以轻松改变整个系统的行为，增强系统的灵活性。 保证产品族一致性：确保客户端始终使用同一产品族中的对象，避免了产品混用带来的兼容性问题。 符合开闭原则：增加新的具体工厂和产品族无需修改已有系统，扩展方便，符合开闭原则（对扩展开放，对修改关闭）。 高内聚低耦合：通过抽象工厂隔离对象创建，提高了系统的内聚性，降低了耦合性，有助于系统的维护和扩展。 2. 模式缺点： # 扩展困难：抽象工厂规定了所有可能创建的产品集合，增加新的产品种类（产品等级结构）时，需要修改工厂接口和所有子类，扩展较为困难。 开闭原则的倾斜性：虽然增加新的工厂和产品族很方便，但增加新的产品等级结构（新种类产品）较麻烦，需要修改现有的工厂类，违反了开闭原则。 3. 适用环境： # 系统不应依赖产品实例的创建细节：适用于不关心产品类如何被创建、组合和表达的场景。 存在多个产品族：系统中有多于一个产品族，每次只使用其中一个产品族中的相关对象。 产品族的一致使用：同一产品族中的产品需要一起工作，系统设计时需保证这一约束。 提供统一接口的产品库：系统中所有产品通过同一个接口出现，客户端无需依赖具体的实现类。 只有具体工厂代码有区别：\n// 不过是一个工厂可以创造多个产品 public class HaierFactory implements EFactory { public Television produceTelevision() { return new HaierTelevision(); } public AirConditioner produceAirConditioner() { // 这个是空调 return new HairAirConditioner(); } } 建造者模式(Builder) # 核心是“组装”，一步一步创建一个复杂的对象，client 和最后的成品交互。\nBuilder（抽象建造者）： 提供一个用于创建产品各部件的抽象类，一般不是接口。\nConcreteBuilder（具体建造者）： 实现Builder接口，负责具体产品部件的构造和装配。\nDirector（指挥者）： 负责指挥建造的流程，安排复杂对象的建造顺序。通过调用建造者的部件构造和装配方法，完成产品的构建过程。\nProduct（产品角色）： 是最终被构建的复杂对象，通常由多个组成部件构成。\n1. 优点： # 封装性好：客户端无需知道产品内部细节 解耦性强：产品与创建过程分离 扩展性好：易于添加新的建造者，符合开闭原则 精细控制：创建步骤清晰可控 2. 缺点：（建造者类复杂） # 适用范围受限：仅适用于相似产品的创建 类数量增加：产品变化复杂时需要更多建造者类 3. 适用场景： # 产品结构复杂：包含多个组成部分 需要控制生成顺序：产品属性间存在依赖关系 创建过程独立：通过指挥者类统一管理创建过程 复用创建过程：相同流程可创建不同产品 建造者模式与抽象工厂模式的关键区别：\n产品维度不同： 建造者：返回单个完整产品 抽象工厂：返回一系列相关产品（产品族） 构建过程不同： 建造者：强调步骤化构建过程，通过指挥者协调 抽象工厂：直接通过工厂方法获取产品 形象比喻： 建造者：像汽车组装厂，组装完整汽车 抽象工厂：像零配件厂，生产相关配件 下图应该为实线继承，因为 builder 是抽象类\n// 客户端类 public class Client { public static void main(String args[]) { // 动态确定套餐种类，使用 XML 配置读取具体的建造者类 MealBuilder mb = (MealBuilder) XMLUtil.getBean(); KFCWaiter waiter = new KFCWaiter(); // 服务员是指挥者，负责构建套餐 waiter.setMealBuilder(mb); // 服务员设置当前的套餐建造者 Meal meal = waiter.construct();\t// 用 director 中的 construct 构造 Product System.out.println(meal.getFood()); System.out.println(meal.getDrink()); } } // 指挥者类 public class KFCWaiter { private MealBuilder mb; public void setMealBuilder(MealBuilder mb) { this.mb = mb; } // 构建套餐并返回 public Meal construct() { mb.buildFood(); // 构建主食 mb.buildDrink(); // 构建饮料 return mb.getMeal(); // 返回最终构建的套餐 } } // 产品类，表示套餐 public class Meal { // 套餐的部件：食物和饮料 private String food; private String drink; public void setFood(String food) { this.food = food; } public void setDrink(String drink) { this.drink = drink; } public String getFood() { return this.food; } public String getDrink() { return this.drink; } } // 抽象建造者类，定义构建流程的接口 public abstract class MealBuilder { // 需要构建的套餐对象，因此其和 Meal 是组合关系 protected Meal meal = new Meal(); public abstract void buildFood(); public abstract void buildDrink(); // 返回构建好的套餐 public Meal getMeal() { return meal; } } // 具体建造者A，实现套餐A的构建 public class SubMealBuilderA extends MealBuilder { public void buildFood() { meal.setFood(\u0026#34;一个鸡腿堡\u0026#34;); } public void buildDrink() { meal.setDrink(\u0026#34;一杯可乐\u0026#34;); } } // 具体建造者B，实现套餐B的构建 public class SubMealBuilderB extends MealBuilder { public void buildFood() { meal.setFood(\u0026#34;一个鸡肉卷\u0026#34;); } public void buildDrink() { meal.setDrink(\u0026#34;一杯果汁\u0026#34;); } } 原型模式(Prototype) # 模式动机与定义 # 原型模式通过复制对象自身来创建多个相同对象，适用于复杂且频繁创建的场景，节省资源。 不需关心对象类型，直接复制原型对象。符合里氏替换原则，即子类能实现父类所有的功能。 原型模式：通过原型实例指定对象种类，并复制原型创建新对象，无需了解创建细节。 优点 缺点 适用场景 # 优点：\n快速创建对象：能够通过克隆快速创建大量相同或相似的对象，简化了对象的创建过程。 保存对象状态：可以保存对象的中间状态，并基于该状态创建新的对象。 缺点：\n需要改造现有类：每个类都需要实现克隆方法，改造现有类时可能需要修改源代码，不满足开闭原则。 深克隆复杂：如下代码，确实复杂。 适用场景：\n创建成本较大：当创建新对象的成本较大时，通过克隆现有对象来创建新对象可以节省开销。 对象状态变化小：系统需要保存对象的状态，且状态变化较小时，可以使用相似对象的复制。 避免复杂的工厂模式：当不希望使用分层次的工厂类来创建对象时，原型模式可以通过复制原型对象来简化对象的创建过程。 分成两种：浅拷贝、深拷贝的区别如下下图所示\n核心区别是实现的接口不一样，浅拷贝是Cloneable，深拷贝是Serializable，且深拷贝组合的类也需要实现Serializable\n浅拷贝 # 演示代码中还有一个附件类，在 mail(ConcretePrototype) 中组合，用于解释深浅拷贝。\n上图的 object 和 Cloneable 二选一即可。一个是自己写的，一个是 java 带的。\n// 附件类 public class Attachment { // 模拟下载附件的方法 public void download() { System.out.println(\u0026#34;下载附件\u0026#34;); } } // 客户端类，测试克隆功能 public class Client { public static void main(String a[]) { Email email, copyEmail; email = new Email(); // 克隆原始邮件 copyEmail = (Email) email.clone() // 对象是深拷贝 System.out.println(\u0026#34;email==copyEmail?\u0026#34;); System.out.println(email == copyEmail); //false // 附件是同一个对象的浅拷贝 System.out.println(\u0026#34;email.getAttachment==copyEmail.getAttachment?\u0026#34;); System.out.println(email.getAttachment() == copyEmail.getAttachment());//true } } // 邮件类，实现了 Cloneable 接口，支持克隆 public class Email implements Cloneable { // 克隆方法，返回当前对象的浅拷贝 public Object clone() { Email clone = null; try { // 调用父类的 clone() 方法进行浅拷贝 clone = (Email) super.clone(); } catch (CloneNotSupportedException e) { System.out.println(\u0026#34;Clone failure!\u0026#34;); // 如果克隆失败，输出错误信息 } return clone; } // 获取附件的方法 public Attachment getAttachment() { return this.attachment; } // 显示邮件内容的方法 public void display() { System.out.println(\u0026#34;查看邮件\u0026#34;); } } 深拷贝 # import java.io.*; // 附件类，需要实现 Serializable public class Attachment implements Serializable { public void download() { System.out.println(\u0026#34;下载附件\u0026#34;); } } // 客户端类 public class Client { public static void main(String a[]) { Email email, copyEmail = null; email = new Email(); try { // 深克隆 email 对象，区别就在 deep copyEmail = (Email) email.deepClone(); } catch (Exception e) { e.printStackTrace(); } // 对象不是一个对象 System.out.println(\u0026#34;email==copyEmail?\u0026#34;); System.out.println(email == copyEmail); // false，表示是不同的对象 // 附件对象不是一个附件对象 System.out.println(\u0026#34;email.getAttachment==copyEmail.getAttachment?\u0026#34;); System.out.println(email.getAttachment() == copyEmail.getAttachment()); } } // 继承的是 public class Email implements Serializable { private Attachment attachment = null; public Email() { this.attachment = new Attachment(); } // 深克隆实现方法 public Object deepClone() throws IOException, ClassNotFoundException { // 将对象写入字节数组输出流 ByteArrayOutputStream bao = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bao); oos.writeObject(this); // 序列化当前对象到流中 // 从字节数组输入流中读取对象 ByteArrayInputStream bis = new ByteArrayInputStream(bao.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bis); return ois.readObject(); // 反序列化生成新的对象 } // 获取附件的方法 public Attachment getAttachment() { return this.attachment; } // 显示邮件内容的方法 public void display() { System.out.println(\u0026#34;查看邮件\u0026#34;); } } 带原型管理器的原型模式 # 一个维护原型对象集合的专用工厂，通过复制集合中的原型对象来提供克隆服务，并基于抽象原型类实现以支持扩展。本质上 Prototypeable 就是个哈希表。\nimport java.util.*; // 定义颜色接口,继承Cloneable接口以支持克隆 interface MyColor extends Cloneable { public Object clone(); // 克隆方法 public void display(); // 显示颜色 } // 实现红色类 class Red implements MyColor { // 实现克隆方法 public Object clone() { Red r = null; try { r = (Red)super.clone(); // 调用Object的clone()方法 } catch(CloneNotSupportedException e) { } return r; } public void display() { System.out.println(\u0026#34;This is Red!\u0026#34;); } } // 实现蓝色类,结构同Red类 class Blue implements MyColor { public Object clone() { Blue b = null; try { b = (Blue)super.clone(); } catch(CloneNotSupportedException e) { } return b; } public void display() { System.out.println(\u0026#34;This is Blue!\u0026#34;); } } // 原型管理器类 class PrototypeManager { private Hashtable ht = new Hashtable(); // 存储原型对象的哈希表 // 初始化,加入默认原型 public PrototypeManager() { ht.put(\u0026#34;red\u0026#34;, new Red()); ht.put(\u0026#34;blue\u0026#34;, new Blue()); } // 添加新原型 public void addColor(String key, MyColor obj) { ht.put(key, obj); } // 获取原型克隆 public MyColor getColor(String key) { return (MyColor)((MyColor)ht.get(key)).clone(); } } // 客户端测试类 class Client { public static void main(String args[]) { PrototypeManager pm = new PrototypeManager(); // 获取两个红色对象并显示 MyColor obj1 = (MyColor)pm.getColor(\u0026#34;red\u0026#34;); obj1.display(); MyColor obj2 = (MyColor)pm.getColor(\u0026#34;red\u0026#34;); obj2.display(); // 判断两个对象是否相同 System.out.println(obj1 == obj2); // 输出false,因为是克隆对象 } } 相似对象的复制 # 其实就是多个对象类似，一两个值不一样，先复制再改值。\npublic static void main(String args[]) { // 创建原型对象 stu1 = new Student(\u0026#34;张无忌\u0026#34;,\u0026#34;男\u0026#34;,24,\u0026#34;软件工程\u0026#34;,\u0026#34;软件学院\u0026#34;,\u0026#34;中南大学\u0026#34;); // 克隆两个新对象并修改部分属性 stu2 = stu1.clone(); // 克隆stu1 stu2.setStuName(\u0026#34;杨过\u0026#34;); // 只修改姓名 stu3 = stu1.clone(); // 再次克隆stu1 stu3.setStuName(\u0026#34;小龙女\u0026#34;); // 修改姓名和性别 stu3.setStuSex(\u0026#34;女\u0026#34;); } 单例模式(Singleton) # 三个要点：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。\n// 下面为懒汉式，第一次调用才创建对象 // 需要处理好多线程问题 public class Singleton { // 静态变量，保存类的唯一实例 private static Singleton instance = null; // 私有构造函数，防止外部实例化 private Singleton() { } // 静态方法，返回类的唯一实例 public static Singleton getInstance() { if(instance == null) { instance = new Singleton(); } return instance; } } // 下面是饿汉式，在类加载时，便将单例实例创建好 // 该方式的实现是线程安全的，但稍微浪费资源（实例可能用不到） public class HungrySingleton { // 在类加载时，立即初始化实例 private static final HungrySingleton instance = new HungrySingleton(); // 私有构造函数，防止外部实例化 private HungrySingleton() {} // 提供静态方法获取唯一实例 public static HungrySingleton getInstance() { return instance; } } // 哈希表多例模式，不指定数量，而是每个 key 对应一个多例 public class Multiton { // 存储不同实例的Map，按标识符存储 private static Map\u0026lt;String, Multiton\u0026gt; instances = new HashMap\u0026lt;\u0026gt;(); // 私有构造函数，防止外部实例化 private Multiton() { } // 获取多例实例的方法，根据标识符返回不同的实例 public static Multiton getInstance(String key) { if (!instances.containsKey(key)) { instances.put(key, new Multiton()); // 如果不存在，则创建并保存实例 } return instances.get(key); // 返回已有的实例 } } // 三例模式 public class Multiton { // 定义固定数量的实例（如三例） private static final int INSTANCE_COUNT = 3; // 用于存储三个实例的数组 private static final Multiton[] instances = new Multiton[INSTANCE_COUNT]; // 使用一个计数器来轮流分配实例 private static int currentInstanceIndex = 0; // 私有构造函数，防止外部通过 new 创建对象 private Multiton() { } // 获取下一个实例的方法 public static synchronized Multiton getInstance() { // 如果实例未被创建，先创建实例 if (instances[currentInstanceIndex] == null) { instances[currentInstanceIndex] = new Multiton(); } // 获取当前实例 Multiton instance = instances[currentInstanceIndex]; // 循环更新索引，以便下次调用时返回下一个实例 currentInstanceIndex = (currentInstanceIndex + 1) % INSTANCE_COUNT; return instance; } // 示例方法，模拟实例执行的操作 public void doSomething() { System.out.println(\u0026#34;实例 \u0026#34; + this + \u0026#34; 正在执行操作\u0026#34;); } } 结构型模式 # 适配器模式 # 转换匹配，复用功能。将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类 可以一起工作。\n**类适配器模式：**通过继承来实现适配，能更灵活地置换方法，但受限于多重继承和目标类的局限。 **对象适配器模式：**通过组合来实现适配，能够适配多个类，但置换方法较为复杂。\n适合场景：\n系统需要使用现有类，而这些类的接口不符合需求。 适配器模式适用于当系统中需要使用现有类，但它们的接口与系统不兼容的情况。 希望创建一个可复用的适配器类，用于与多个不相关的类（适配者类和目标类）一起工作。 包括将来可能引入的适配者类的子类也能一起适配。 类适配器 # // 被适配者类 (旧的接口) class Adaptee { public void specificRequest() { System.out.println(\u0026#34;Adaptee: Handling specific request\u0026#34;); } } // 目标接口 (客户端期望的接口) interface Target { void request(); } // 适配器类 (实现了Target接口，适配Adaptee) public class Adapter extends Adaptee implements Target { public void request() { specificRequest(); // 把客户端的request方法适配为Adaptee的specificRequest } } // 客户端类 public class Client { public static void main(String[] args) { Target target = new Adapter(); // 客户端通过Target接口使用Adapter target.request(); // 实际上调用的是Adaptee的specificRequest方法 } } 优点：\n灵活性更强 由于适配器类是适配者类的子类，因此可以在适配器类中置换一些适配者的方法 缺点\n多重继承限制，对于不支持多重继承的语言（如 Java、C#），类适配器模式一次最多只能适配一个适配者类。 目标类限制，目标抽象类只能是抽象类，不能是具体类，使用上有一定的局限性。 无法适配子类，不能将一个适配者类及其子类都适配到目标接口。 对象适配器 # // 目标接口 (客户端期望的接口) public class Target { public void request() { System.out.println(\u0026#34;Target: Handling request\u0026#34;); } } // 被适配者类 (旧的接口) public class Adaptee { public void specificRequest() { System.out.println(\u0026#34;Adaptee: Handling specific request\u0026#34;); } } // 适配器类 (通过组合方式实现适配) public class Adapter extends Target { private Adaptee adaptee; // 适配器持有被适配者的引用 // 构造函数，传入被适配者的实例 public Adapter(Adaptee adaptee) { this.adaptee = adaptee; } // 实现Target的request方法，实际上调用Adaptee的specificRequest方法 @Override public void request() { adaptee.specificRequest(); } } // 客户端类，和类对象一致 public class Client { public static void main(String[] args) { Adaptee adaptee = new Adaptee(); Target target = new Adapter(adaptee); target.request(); // 实际上调用的是Adaptee的specificRequest方法 } } 优点：\n适配多个类，一个对象适配器可以将多个不同的适配者适配到同一个目标，即同一个适配器可以将适配者类及其子类都适配到目标接口。 缺点：\n较难置换方法 与类适配器相比，对象适配器要想置换适配者类的方法较为不便。如果需要置换适配者类的一个或多个方法，必须先创建适配者类的子类，在子类中置换方法，再将该子类作为真正的适配者进行适配。 对象适配器还可能如下形式：\n其中 DataOperator 是 target，而两个 adapter 按情况分配适配接口。\n模型扩展 # 默认适配器模式\n双向适配器\n智能适配器\n适配多个适配者\n桥接模式 # 桥接模式的本质：分离抽象和实现\n需要将需求转化为两个维度，固有维度（比如毛笔尺寸）做抽象类，另一个维度（比如毛笔颜色）做接口实现类。\n// 实现部分：Color接口 public interface Color { void bepaint(String penType, String name); } public class Red implements Color { @Override public void bepaint(String penType, String name) { System.out.println(penType + \u0026#34; Red color \u0026#34; + name + \u0026#34;.\u0026#34;); } } public class Green implements Color { @Override public void bepaint(String penType, String name) { System.out.println(penType + \u0026#34; Green color \u0026#34; + name + \u0026#34;.\u0026#34;); } } // 抽象部分：Pen类 public abstract class Pen { protected Color color; // 设置颜色 public void setColor(Color color) { this.color = color; } // 抽象绘画方法 public abstract void draw(String name); } public class SmallPen extends Pen { @Override public void draw(String name) { color.bepaint(\u0026#34;SmallPen\u0026#34;, name); } } public class BigPen extends Pen { @Override public void draw(String name) { color.bepaint(\u0026#34;BigPen\u0026#34;, name); } } // 测试类 public class Client { public static void main(String[] args) { // 创建一种颜色（红色） Color red = new Red(); // 创建一种笔（大号笔），并设置颜色 Pen bigPen = new BigPen(); bigPen.setColor(red); bigPen.draw(\u0026#34;Flower\u0026#34;); // 创建另一种颜色（绿色） Color green = new Green(); // 使用小号笔，并设置为绿色 Pen smallPen = new SmallPen(); smallPen.setColor(green); smallPen.draw(\u0026#34;Tree\u0026#34;); } } 模式优点：\n桥接模式通过对象间的关联解耦了抽象与实现。符合组合/聚合复用原则 减少子类数量：桥接模式可以替代多重/多层继承，避免违背单一职责原则。 提高可扩展性：在任意维度上扩展时，不需修改原有系统，符合开闭原则，系统更具扩展性。 模式缺点：\n增加设计难度：桥接模式要求开发者从一开始就设计抽象层。 需要正确识别系统中的两个独立变化的维度，这需要一定的经验积累，否则使用范围有限。 模式适用环境：\n灵活性需求：当系统需要在抽象化和具体化之间增加更多灵活性，避免静态继承关系时，桥接模式可以通过关联关系实现动态耦合。 独立扩展：当一个类有两个或多个独立变化的维度，并且这些维度需要独立扩展时，桥接模式尤为适用。 避免多重继承：对于不希望使用多重/多层继承，或者因继承导致类急剧增加的系统，桥接模式是更好的选择。用聚合代替多重继承。 适配器模式与桥接模式的联用 # // 抽象部分：报表显示 abstract class ReportDisplay { protected DataCollector dataCollector; public ReportDisplay(DataCollector dataCollector) { this.dataCollector = dataCollector; } public abstract void display(); } // 具体实现：报表显示方式1 class ReportDisplayStyle1 extends ReportDisplay { public ReportDisplayStyle1(DataCollector dataCollector) { super(dataCollector); } @Override public void display() { System.out.println(\u0026#34;Displaying report in style 1:\u0026#34;); dataCollector.collectData(); } } // 实现部分：数据采集接口 interface DataCollector { void collectData(); } // 适配器类：读取Excel文件的适配器，适配Excel API class ExcelFileCollector implements DataCollector { private ExcelAPI excelAPI; public ExcelFileCollector(ExcelAPI excelAPI) { this.excelAPI = excelAPI; } @Override public void collectData() { excelAPI.readExcel(); } } // Excel API 模拟类 class ExcelAPI { public void readExcel() { System.out.println(\u0026#34;Collecting data from Excel file using Excel API.\u0026#34;); } } 组合模式 # 组合模式的本质：**统一叶子对象和组合对象。**处理了树状结构。\n// 抽象类 MyElement，定义 eat() 抽象方法 public abstract class MyElement { public abstract void eat(); } // Plate 类，包含 MyElement 对象的集合，并实现 eat() 方法 public class Plate extends MyElement { private List\u0026lt;MyElement\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); // 注意是私有列表 public void add(MyElement element) { // 组合模式标准的添加元素 list.add(element); } public void delete(MyElement element) { // 删除元素 list.remove(element); } // 实现 eat() 方法，调用每个元素的 eat() // 可以实现 eat() 盘子中的所有水果 @Override public void eat() { for (MyElement element : list) { element.eat(); } } } // Apple 类，具体实现 eat() 方法 public class Apple extends MyElement { @Override public void eat() { System.out.println(\u0026#34;Eating an apple!\u0026#34;); } } // Pear 类，具体实现 eat() 方法 public class Pear extends MyElement { @Override public void eat() { System.out.println(\u0026#34;Eating a pear!\u0026#34;); } } // 测试类 Client public class Client { public static void main(String[] args) { // 创建 MyElement 对象 MyElement obj1, obj2, obj3, obj4, obj5; Plate plate1, plate2, plate3; // 创建水果对象 obj1 = new Apple(); obj2 = new Pear(); // 创建盘子 plate1 并添加水果 plate1 = new Plate(); plate1.add(obj1); plate1.add(obj2); // 创建更多水果对象 obj3 = new Banana(); obj4 = new Banana(); // 创建盘子 plate2 并添加水果 plate2 = new Plate(); plate2.add(obj3); plate2.add(obj4); // 创建 plate3，它可以包含其他盘子和水果 obj5 = new Apple(); plate3 = new Plate(); plate3.add(plate1); plate3.add(plate2); plate3.add(obj5); // 调用 eat() 方法，演示组合模式的效果 System.out.println(\u0026#34;Plate 1 contents:\u0026#34;); plate1.eat(); // Plate 1 吃掉其包含的水果 System.out.println(\u0026#34;\\nPlate 3 contents:\u0026#34;); plate3.eat(); // Plate 3 吃掉 plate1, plate2 和一个 Apple } } 优点：\n统一对象操作：叶子对象与组合对象共享统一的接口，简化了客户端代码，无需区分具体类型。 递归结构：支持将对象组合成更复杂的结构，可以不断递归组合，形成整体-部分层次结构。 易于扩展：新增叶子或组合对象时，客户端无需修改，新的子类能够无缝集成。 缺点：\n类型限制难：很难在编译时限制组合中只能包含特定类型的组件，必须在运行时动态检查。 适用场景：\n表示整体-部分层次结构。 需要统一操作组合结构中的所有对象。 模型扩展 # 透明组合模式：在抽象类中包含了管理成员对象的方法（如包括add()、remove()以及getChild()等），使客户端可以平等的看待所有的对象，缺点是不够安全。\n安全组合模式：与透明组合相反，在抽象组件中没有声明任何用于管理成员对象的方法（水果篮例子就是如此），缺点是不够透明。\n更复杂的组合模式：叶子和 Composite 都可以继续继承，如下图：\n装饰模式 # 装饰模式的本质：**动态组合。**动态是手段，组合才是目的。\n形态上很像组合模式，在 Composite 中继续继承两个子类。\n变形金刚实例如下：\n// 定义基础接口 Transform public interface Transform { public void move(); } // Car 类，实现 Transform 接口，表示一辆车 public final class Car implements Transform { public Car() { System.out.println(\u0026#34;变形金刚是一辆车！\u0026#34;); } @Override public void move() { System.out.println(\u0026#34;在陆地上移动！\u0026#34;); } } // Changer 类，装饰器基类，持有一个 Transform 对象 public class Changer implements Transform { private Transform transform; // 私有变量 public Changer(Transform transform) { // 通过构造函数改变 transform this.transform = transform; } @Override public void move() { transform.move(); } } // Robot 类，继承 Changer，扩展了说话功能 public class Robot extends Changer { public Robot(Transform transform) { super(transform); // 调用父类的构造函数，改变父类的 transform，即改变其 move 函数 System.out.println(\u0026#34;变成机器人！\u0026#34;); } public void say() { System.out.println(\u0026#34;说话！\u0026#34;); } } // Client 测试类 public class Client { public static void main(String[] args) { // 创建一个基础的 Car 对象 Transform camaro = new Car(); camaro.move(); // 在陆地移动 System.out.println(\u0026#34;-----------------------------\u0026#34;); // 使用 Robot 装饰 Car 对象，添加说话功能 Robot optimus = new Robot(camaro); optimus.move(); //还是 Car 的移动功能 optimus.say(); // Robot 的说话功能 } } 多层装饰 # 当 decorator 有多个子类时，可以进行多重装饰。但装饰到最里面一定是某一个 ConcreteComponent。\n历年题中的例子如下：\npublic class Client { public static void main(String[] args) { Person p1, p2; p1 = new Person(\u0026#34;张三\u0026#34;, 5000, 1000, 10000); p2 = new Person(\u0026#34;李四\u0026#34;, 10000, 2000, 20000); Factory.addPerson(\u0026#34;张三\u0026#34;, p1); Factory.addPerson(\u0026#34;李四\u0026#34;, p2); Component e1, m1, personBusiness, personPayback, teamBusiness; String name; e1 = new Employee(); name = p1.getName(); personBusiness = new PersonBusiness(e1); // 张三是员工，装饰了一层 PersonPayback personPayback = new PersonPayback(personBusiness) // 再装饰一层 PersonPayback System.out.print(name); System.out.println(personPayback.getDes(name)); System.out.println(personPayback.getBonus(name)); m1 = new Manager(); name = p2.getName(); personBusiness = new PersonBusiness(m1); // 李四是员工，装饰一层 PersonPayback personPayback = new PersonPayback(personBusiness); // 再装饰一层 teamBusiness = new TeamBusiness(personPayback); System.out.print(name); System.out.println(teamBusiness.getDes(name)); System.out.println(teamBusiness.getBonus(name)); } } /* 张三普通员工获得个人业务奖金获得个人回款奖金 151.0 李四经理获得个人业务奖金获得个人回款奖金获得团队业务奖金 502.0 */ 模式优点\n灵活性高：相比继承，装饰模式更灵活。继承是静态的，而装饰模式通过将功能分离到不同的装饰器中，可以在运行时动态组合功能，决定最终的行为。 易于复用：装饰器将每个功能独立实现，简化了功能的复用。多个装饰器可以叠加在同一对象上，或者同一个装饰器可以用于不同对象，提升了功能的复用性。 简化高层定义：高层定义只需要定义基本功能，通过组合装饰器来动态增加功能，避免在高层设计时考虑所有功能需求。 模式缺点\n对象数量增加：每个装饰器负责不同功能，可能会导致大量细粒度对象的产生，增加系统资源消耗，影响性能。\n调试复杂：由于装饰模式涉及多次功能叠加，调试可能需要逐级排查装饰链。\n适用环境\n需要动态、透明地为单个对象添加职责，且不影响其他对象。 无法通过继承扩展系统，或继承不利于系统维护时，适合使用装饰模式。特别是当扩展过多或类被定义为不可继承（如 Java 中的 final 类）时，装饰模式是更好的选择。 模式扩展 # 半透明装饰模式：上面变形金刚的例子就是半透明，允许 client 调用具体的实现类（例子中是robot）。好处是可以添加新的功能，比如例子中的说话。\n透明装饰模式：所有的功能都在接口或抽象类中表现，client 只调用最高层的接口或抽象类，导致其不能添加新功能，只能在原有的功能上修改。在多重加密系统中使用。\n装饰模式简化：删去了最高层的接口或抽象类，转而用具体组件类来代替，要求具体组件功能实现较少：\n外观模式 # 外观模式的本质：封装交互，简化调用。\n外观模式是迪米特法则的具体体现。\n// Fan 类，表示风扇 public class Fan { public void on() { System.out.println(\u0026#34;风扇打开！\u0026#34;); } public void off() { System.out.println(\u0026#34;风扇关闭！\u0026#34;); } } // Light 类，表示灯光 public class Light { private String position; public Light(String position) { this.position = position; } public void on() { System.out.println(this.position + \u0026#34;灯打开！\u0026#34;); } public void off() { System.out.println(this.position + \u0026#34;灯关闭！\u0026#34;); } } // GeneralSwitchFacade 类，作为开关的外观模式 public class GeneralSwitchFacade { private Light[] lights = new Light[4]; // 用私有变量关联具体类 private Fan fan; private AirConditioner ac; private Television tv; public GeneralSwitchFacade() { // 组合成一个开关 lights[0] = new Light(\u0026#34;左前\u0026#34;); ... fan = new Fan(); ac = new AirConditioner(); tv = new Television(); } // 打开所有设备 public void on() { for (Light light : lights) { light.on(); } fan.on()；... } // 关闭所有设备 public void off() { for (Light light : lights) { light.off(); } fan.off(); ... } } // Client 测试类 public class Client { public static void main(String[] args) { GeneralSwitchFacade gsf = new GeneralSwitchFacade(); gsf.on(); // 打开所有设备 System.out.println(\u0026#34;-----------------------\u0026#34;); gsf.off(); // 关闭所有设备 } } 模式优点\n简化客户端代码：减少了客户端需要处理的对象数量. 降低耦合性：外观模式实现了客户端与子系统之间的松耦合。 分层结构清晰 需要暴露给外部的功能集中在外观类中，方便客户端使用，同时隐藏了系统内部的复杂细节。 不影响直接访问子系统：外观模式提供了访问子系统的统一入口，但并不限制用户直接使用子系统类，保留了系统的灵活性。 模式缺点\n对子系统类限制不严格：外观模式无法严格限制客户端直接访问子系统类，可能导致系统复杂度增加。 可能违背开闭原则：如果设计不当，增加新的子系统可能需要修改外观类的源代码，从而违背开闭原则。 适用环境\n当需要为复杂子系统提供一个简单接口时，可以使用外观模式。 当客户端程序与多个子系统之间存在很大依赖时，外观模式可以通过引入外观类将子系统与客户端解耦。 在层次化结构中，外观模式可以为每一层定义统一的入口。 模型扩展 # 一个系统有多个外观类：在通常情况下，只有一个外观类（使用单例），比如例子中只有一个开关。但实际上也有需要使用多个外观类的情况，每个外观类都负责和一些特定的子系统交互。不要试图通过外观类为子系统增加新行为。\n抽象外观类：若有多个外观类，单纯的设计会导致违反开闭原则，因此往往通过抽象外观类进行设计。使得在引入抽象外观类之后，不需要修改原有外观类。\n代理模式 # 代理模式的本质：控制对象访问。\n远程代理 (Remote Proxy)\n功能：为远程对象提供本地代理，简化跨网络的对象调用。 应用场景：分布式系统，如 DCOM、Web Service、Java RMI、CORBA。 优点：客户端可以像调用本地对象一样访问远程对象，隐藏了网络通信的复杂性。 虚拟代理 (Virtual Proxy)\n功能：延迟创建资源消耗大的对象，只有在需要时才真正创建。 应用场景：系统中有高成本对象（如图像、文件等）的按需加载。 优点：优化性能，减少系统初始开销，节省内存和计算资源。 保护代理 (Protect Proxy)\n功能：根据用户权限控制对对象的访问。 应用场景：需要基于角色或权限进行访问控制的系统。 优点：增强安全性，确保不同用户只能访问他们有权操作的功能。 缓冲代理 (Cache Proxy)\n功能：为目标操作的结果提供缓存，减少重复操作。 应用场景：频繁访问不经常变化的数据，如数据查询缓存。 优点：提高性能，减少计算或数据获取的开销。 智能引用代理 (Smart Reference Proxy)\n功能：在对象引用时，增加额外操作，如记录调用次数、管理对象生命周期。 应用场景：需要监控对象使用或增加引用管理的场景。 优点：增强对象管理功能，提供更多控制和监控能力。 防火墙代理 (Firewall Proxy)\n功能：控制对网络资源的访问，保护对象免受不可信客户端的侵害。 应用场景：网络安全系统，如公司的防火墙。 优点：提高系统安全性，限制对敏感资源的非法访问。 同步代理 (Synchronization Proxy)\n功能：在多线程环境下，确保对对象的安全访问。 应用场景：并发系统，如分布式系统中的同步访问控制。 优点：防止数据竞争，确保多线程的并发安全性。 写入时复制代理 (Copy-On-Write Proxy)\n功能：延迟对象的复制操作，直到真正需要时才进行复制。 应用场景：需要优化内存和性能的场景，特别是只读对象的复制。 优点：减少不必要的深拷贝操作，优化性能和资源使用。 // 客户端类 public class Client { public static void main(String[] args) { // 使用XMLUtil从配置中获取权限对象，假设返回的是代理类 AbstractPermission permission = (AbstractPermission) XMLUtil.getBean(); // 初始权限级别为0，尝试执行各种操作 permission.modifyUserInfo();... // 设置权限级别为1，再次尝试执行操作 permission.setLevel(1); permission.modifyUserInfo();... } } // 抽象权限接口，定义所有权限操作 public interface AbstractPermission { void modifyUserInfo(); // 修改用户信息权限 void viewNote(); // 查看帖子权限 void publishNote(); // 发布帖子权限 void modifyNote(); // 修改帖子权限 void setLevel(int level); // 设置权限级别 } // 真实权限类，实现具体的权限操作 public class RealPermission implements AbstractPermission { @Override public void modifyUserInfo() { // 需要权限的功能 System.out.println(\u0026#34;修改用户信息！\u0026#34;); } @Override public void viewNote() { // 不需要权限的功能 // 可以一直查看帖子，无需权限 } } // 权限代理类，控制访问权限 public class PermissionProxy implements AbstractPermission { // 私有变量，关联关系。虽然有 new，但从生命周期的角度看应该是关联而非组合。 private RealPermission permission = new RealPermission(); // 持有真实权限对象 private int level = 0; // 默认权限级别为0 @Override public void modifyUserInfo() { if (level == 0) { System.out.println(\u0026#34;对不起，你没有修改用户信息的权限!\u0026#34;); } else if (level == 1) { permission.modifyUserInfo(); } } @Override public void viewNote() { // 可以直接查看不需要权限 System.out.println(\u0026#34;查看帖子！\u0026#34;); } } 模式优点\n降低耦合性：代理模式在调用者和被调用者之间引入代理，减少了它们之间的直接依。 符合开闭原则：客户端针对抽象接口编程。 提升系统性能：远程代理和虚拟代理可以将资源密集型操作从本地转移或延迟执行。 权限控制：保护代理可以根据用户权限控制访问，提供不同级别的功能，增强系统的安全性。 缓存优化：缓冲代理通过缓存操作结果，提高重复操作的效率，缩短执行时间。 模式缺点\n性能开销：代理模式增加了一层间接性，可能导致请求处理变慢，尤其是在频繁调用时。 实现复杂：某些代理模式（如远程代理、缓存代理）的实现较为复杂，开发和维护成本较高。 适用环境\n当客户端需要访问远程对象时，可以使用远程代理，屏蔽网络通信的复杂性。 当需要延迟创建高成本对象时，可以使用虚拟代理，减少系统初始开销。 当需要为频繁访问的结果提供缓存时，适合使用缓冲代理，避免重复计算。 当需要控制权限访问时，适合使用保护代理，基于用户权限提供不同功能。 当需要在对象引用时执行额外操作（如计数、管理）时，可以使用智能引用代理。 模型扩展 # 动态代理： Java 反射机制（主要是 java.lang.reflect.Proxy 和 InvocationHandler）来实现。\n// 抽象主题接口，定义了代理类与真实主题类共有的行为 public interface AbstractSubject { void request(); // 抽象方法，代理类和真实主题类都会实现 } // 真实主题类A，实现了AbstractSubject接口 public class RealSubjectA implements AbstractSubject { @Override public void request() { System.out.println(\u0026#34;真实主题类A！\u0026#34;); } } // 真实主题类B，实现了AbstractSubject接口 public class RealSubjectB implements AbstractSubject { @Override public void request() { System.out.println(\u0026#34;真实主题类B！\u0026#34;); } } // 动态代理类，负责在真实对象方法调用前后执行额外操作 import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; public class DynamicProxy implements InvocationHandler { private Object obj; // 持有被代理的真实对象 // 无参构造方法 public DynamicProxy() {} // 有参构造方法，传入被代理对象 public DynamicProxy(Object obj) { this.obj = obj; } // 动态代理的核心方法，拦截对代理对象的所有方法调用 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { preRequest(); // 调用前操作 method.invoke(obj, args); // 调用真实对象的方法 postRequest(); // 调用后操作 return null; } public void preRequest() { // 调用前的操作（如日志记录） System.out.println(\u0026#34;调用之前！\u0026#34;); } public void postRequest() { // 调用后的操作（如日志记录） System.out.println(\u0026#34;调用之后！\u0026#34;); } } // 客户端类，演示如何使用动态代理 import java.lang.reflect.Proxy; public class Client { public static void main(String[] args) { InvocationHandler handler; // 动态代理的调用处理器 AbstractSubject subject; // 抽象主题接口 // 使用动态代理代理真实主题类A handler = new DynamicProxy(new RealSubjectA()); subject = (AbstractSubject) Proxy.newProxyInstance( AbstractSubject.class.getClassLoader(), new Class[]{AbstractSubject.class}, handler ); subject.request(); // 调用代理对象的方法，触发invoke方法 System.out.println(\u0026#34;------------------------------\u0026#34;); // 使用动态代理代理真实主题类B handler = new DynamicProxy(new RealSubjectB()); subject = (AbstractSubject) Proxy.newProxyInstance( AbstractSubject.class.getClassLoader(), new Class[]{AbstractSubject.class}, handler ); subject.request(); // 调用代理对象的方法，触发invoke方法 } } 行为型模式 # 行为型模式(Behavioral Pattern)是对在不同的对象之间划分责任和算法的抽象化。\n行为型模式不仅仅关注类和对象的结构，而且重点关注它们之间的相互作用。\n责任链模式 # 职责链模式的本质：分离职责，动态组合。\n职责链可以是直线，树，环等等，常见的是直线。\n和组合模式比较像，区别如下：\n处理方式不同：\n在 职责链模式 中，如果一个对象处理了请求，链条的传递就终止了，处理者唯一。 在 组合模式 中，操作会应用到所有子对象上，处理是递归的，可能会遍历整个树形结构。 应用场景不同：\n职责链模式 适用于多个对象都有机会处理请求的情况，但处理者不明确，希望请求自动沿着链传递直到找到合适的处理者。 组合模式 适用于需要表示部分-整体层次结构的场景，希望客户端无差别地处理单个对象和组合对象。 // 主任类，处理较短时间的请假 public class Director extends Leader { public Director(String name) { super(name); // 调用父类的构造函数 } // 处理请假请求 public void handleRequest(LeaveRequest request) { if (request.getLeaveDays() \u0026lt; 3) { // 如果请假天数少于3天，主任处理 System.out.println(\u0026#34;主任\u0026#34; + name + \u0026#34;审批员工\u0026#34; + request.getLeaveName() + \u0026#34;的请假条，请假天数为\u0026#34; + request.getLeaveDays() + \u0026#34;天。\u0026#34;); } else { if (this.successor != null) { // 如果超过3天，且有上级领导，交给下一个领导处理 this.successor.handleRequest(request); } } } } // 总经理类，处理较大时间范围的请假 ... // 抽象领导类，定义了职责链中的公共行为 public abstract class Leader { protected String name; // 领导的姓名，注意最好用 protected protected Leader successor; // 下一个处理请求的领导，最好用 protected，如果是树，应该用列表表示 public Leader(String name) { this.name = name; } public void setSuccessor(Leader successor) { // 设置下一个处理者 this.successor = successor; } public abstract void handleRequest(LeaveRequest request);// 抽象方法，处理请假请求 } // 请假请求类，封装请假者的姓名和请假天数 public class LeaveRequest { private String leaveName; // 请假者的姓名 private int leaveDays; // 请假天数 public LeaveRequest(String leaveName, int leaveDays) { // 构造函数 this.leaveName = leaveName; this.leaveDays = leaveDays; } // 经典 set 与 get public void setLeaveName(String leaveName) { this.leaveName = leaveName; } 。。。 public String getLeaveName() { return this.leaveName; } 。。。 } // 客户端类，模拟请假审批流程 public class Client { public static void main(String args[]) { // 创建各级审批领导 Leader objDirector, objManager, objGeneralManager, objViceGeneralManager; objDirector = new Director(\u0026#34;王明\u0026#34;); objManager = new Manager(\u0026#34;赵强\u0026#34;);... // 设置职责链，将各级领导串联起来，类似链表 objDirector.setSuccessor(objManager); objManager.setSuccessor(objViceGeneralManager); objViceGeneralManager.setSuccessor(objGeneralManager); LeaveRequest lr4 = new LeaveRequest(\u0026#34;赵六\u0026#34;, 25); // 赵六请假25天 objDirector.handleRequest(lr4); // 处理请求 } } 模式扩展： # 职责链模式分为纯的职责链模式和不纯的职责链模式：\n纯的职责链模式：每个处理者要么处理请求，要么将请求传递给下一个处理者，且不返回。（比如上面的请假例子） 不纯的职责链模式：每个处理者可以处理请求并将请求继续传递，或者在处理后终止传递。 优点缺点： # 模式优点\n降低耦合度：职责链模式将请求的发送者与处理者解耦，发送者无需知道具体的处理者是谁，只需将请求提交到链上。 简化对象连接：每个处理对象只需要保存对其后继者的引用，而不需要保存对所有可能处理者的引用，简化了对象之间的连接关系。 灵活性高：职责链结构可以在运行时动态修改，处理者可以在链中动态增加、删除或重新排序。 符合开闭原则：增加新的处理者时不需要修改现有代码，只需在客户端重新构建职责链即可。 模式缺点\n请求可能得不到处理：如果链末尾没有合适的处理者，或职责链配置不当，可能导致请求得不到任何处理。 性能开销：对于较长的职责链，处理请求需要经过多个对象，可能导致处理效率降低。 调试困难：链条过长时，调试和跟踪请求的处理过程可能会变得复杂。 可能产生循环调用：如果存在环形结构，可能会导致循环调用，进而引发系统死循环。 适用环境\n当有多个对象可以处理同一请求时，职责链模式适用于在请求发出时不明确指定请求的接收者。 当请求的处理对象在运行时动态确定时，职责链模式可以灵活地调整处理者的顺序或增加新的处理者。 当需要将请求提交给一组处理者中的某一个或某几个，而不必明确指定具体的处理者时，职责链模式适用。 当希望客户端只需将请求提交给职责链，而不关心具体的处理过程时。 命令模式 # 命令模式的本质：封装请求。\n// 命令模式的实现：将请求封装成对象，使得请求的发送者和接收者解耦。 // 这里的例子是电视遥控器控制电视的开、关、换台操作。 // 抽象命令接口，定义了所有具体命令类的统一操作接口 public interface AbstractCommand { public void execute(); } // 具体命令类：打开电视命令 public class TVOpenCommand implements AbstractCommand { private Television tv; // 构造方法中关联接收者（电视） public TVOpenCommand() { tv = new Television(); } // 执行命令，调用电视的开机方法 public void execute() { tv.open(); } } // 具体命令类：关闭电视命令 public class TVCloseCommand implements AbstractCommand { ... } // 具体命令类：切换电视频道命令 public class TVChangeCommand implements AbstractCommand { ... } // 接收者类：电视，包含具体的操作方法 public class Television { public void open() { System.out.println(\u0026#34;打开电视机！\u0026#34;); } public void close() { System.out.println(\u0026#34;关闭电视机！\u0026#34;); } public void changeChannel() { System.out.println(\u0026#34;切换电视频道！\u0026#34;); } } // 调用者类：遥控器，负责执行命令 public class Controller { private AbstractCommand openCommand, closeCommand, changeCommand; // 遥控器构造函数，传入具体的命令对象 public Controller(AbstractCommand openCommand, AbstractCommand closeCommand, AbstractCommand changeCommand) { this.openCommand = openCommand; this.closeCommand = closeCommand; this.changeCommand = changeCommand; } public void open() { // 调用打开电视的命令 openCommand.execute(); } public void change() { // 调用切换频道的命令 changeCommand.execute(); } public void close() { // 调用关闭电视的命令 closeCommand.execute(); } } // 客户端类：设置命令并触发请求 public class Client { public static void main(String[] args) { // 创建具体命令对象 AbstractCommand openCommand = new TVOpenCommand(); AbstractCommand closeCommand = new TVCloseCommand(); AbstractCommand changeCommand = new TVChangeCommand(); // 创建遥控器（调用者），并传入命令对象 Controller control = new Controller(openCommand, closeCommand, changeCommand); // 模拟使用遥控器控制电视操作 control.open(); // 打开电视 control.change(); // 切换频道 control.close(); // 关闭电视 } } 模型扩展 # 命令队列： # 它用于将多个命令对象按顺序存储在一个队列中，并在适当的时机依次执行这些命令。命令队列的主要作用是将命令的请求和执行解耦，允许命令的执行可以被延迟或批量处理。\nclass CommandQueue { //定义一个ArrayList来存储命令队列 private ArrayList\u0026lt;Command\u0026gt; commands = new ArrayList\u0026lt;Command\u0026gt;(); public void addCommand(Command command) { commands.add(command); } public void removeCommand(Command command) { commands.remove(command); } //循环调用每一个命令对象的execute()方法 public void execute() { for (Object command : commands) { ((Command)command).execute(); } } } class Invoker { private CommandQueue commandQueue; //维持一个CommandQueue对象的引用 //构造注入 public Invoker(CommandQueue commandQueue) { this.commandQueue =commandQueue; } //设值注入 public void setCommandQueue(CommandQueue commandQueue) { this.commandQueue = commandQueue; } //调用CommandQueue类的execute()方法 public void call() { commandQueue.execute(); } } 请求日志： # 模式通常用于记录系统中执行的命令或操作，以便后续进行操作的回放、撤销（undo）或恢复（redo）。\n// 配置文件操作类：请求接收者 // 实现Serializable接口，确保对象可以被序列化并写入文件 class ConfigOperator implements Serializable { // 插入新节点 public void insert(String args) { System.out.println(\u0026#34;增加新节点：\u0026#34; + args); } // 修改节点 public void modify(String args) { System.out.println(\u0026#34;修改节点：\u0026#34; + args); } // 删除节点 public void delete(String args) { System.out.println(\u0026#34;删除节点：\u0026#34; + args); } } // 配置文件设置窗口类：请求发送者 // 负责调用具体的命令对象并保存执行日志 class ConfigSettingWindow { // 定义一个集合来存储每一次操作时的命令对象 private ArrayList\u0026lt;Command\u0026gt; commands = new ArrayList\u0026lt;Command\u0026gt;(); private Command command; // 注入具体命令对象 public void setCommand(Command command) { this.command = command; } // 执行配置文件修改命令，同时将命令对象添加到命令集合中 public void call(String args) { command.execute(args); commands.add(command); } // 记录请求日志，生成日志文件，将命令集合写入日志文件 public void save() { FileUtil.writeCommands(commands); } // 从日志文件中提取命令集合，并循环调用每一个命令对象的execute()方法来实现配置文件的重新设置 public void recover() { ArrayList list; list = FileUtil.readCommands(); for (Object obj : list) { ((Command)obj).execute(); } } } // 工具类：文件操作类 // 负责将命令集合序列化写入日志文件及从日志文件中读取命令集合 class FileUtil { // 将命令集合写入日志文件 public static void writeCommands(ArrayList commands) { try { FileOutputStream file = new FileOutputStream(\u0026#34;config.log\u0026#34;); // 创建对象输出流用于将对象写入到文件中 ObjectOutputStream objout = new ObjectOutputStream(new BufferedOutputStream(file)); // 将对象写入文件 objout.writeObject(commands); objout.close(); } catch (Exception e) { System.out.println(\u0026#34;命令保存失败！\u0026#34;); e.printStackTrace(); } } // 从日志文件中提取命令集合 public static ArrayList readCommands() { try { FileInputStream file = new FileInputStream(\u0026#34;config.log\u0026#34;); // 创建对象输入流用于从文件中读取对象 ObjectInputStream objin = new ObjectInputStream(new BufferedInputStream(file)); // 将文件中的对象读出并转换为ArrayList类型 ArrayList commands = (ArrayList)objin.readObject(); objin.close(); return commands; } catch (Exception e) { System.out.println(\u0026#34;命令读取失败！\u0026#34;); e.printStackTrace(); return null; } } } 撤销操作： # // 抽象命令类：定义命令的接口，包含执行和撤销操作。 abstract class AbstractCommand { // 执行操作，传入参数并返回执行结果 public abstract int execute(int value); // 撤销操作，返回撤销后的结果 public abstract int undo(); } // 具体命令类：实现了抽象命令类，负责调用接收者（Adder）的具体操作。该类封装了对加法操作的请求并实现了撤销功能。 class ConcreteCommand extends AbstractCommand { private Adder adder = new Adder(); // 接收者（实际执行加法操作的类） // 存储上一次操作的值，用于撤销 private int value; // 执行加法操作，并存储当前操作的值 public int execute(int value) { this.value = value; return adder.add(value); } // 撤销上一次加法操作，通过加上一个相反的值 public int undo() { return adder.add(-value); } } // 调用者类：表示计算器窗口，通过命令对象来执行和撤销操作。 // 该类负责管理命令对象，并通过命令对象执行或撤销操作。 class CalculatorForm { private AbstractCommand command; // 设置具体的命令对象 public void setCommand(AbstractCommand command) { this.command = command; } public void compute(int value) { // 执行运算操作，并输出运算结果 int result = command.execute(value); System.out.println(\u0026#34;执行运算，运算结果为：\u0026#34; + result); } public void undo() { // 撤销上一次运算操作，并输出撤销后的结果 int result = command.undo(); System.out.println(\u0026#34;执行撤销，运算结果为：\u0026#34; + result); } } // 接收者类：实际执行加法操作的类。 class Adder { private int num = 0; // 记录当前的累计值 // 执行加法操作，并返回加法后的结果 public int add(int value) { num += value; return num; } } // 客户端类：负责创建命令对象和调用者，并触发操作。 class Client { public static void main(String args[]) { // 创建调用者（计算器窗口） CalculatorForm form = new CalculatorForm(); // 创建具体命令对象（加法命令） ConcreteCommand command = new ConcreteCommand(); // 将命令对象设置到调用者 form.setCommand(command); form.compute(10); // 输出：执行运算，运算结果为：10 form.undo(); // 输出：执行撤销，运算结果为：15 } } 宏命令： # 递归调用它所包含的每个成员命令的execute()方法。执行一个宏命令将触发多个具体命令的执行，从而实现对命令的批处理。\n优点缺点 # 模式优点\n更松散的耦合：命令模式将请求的发送者与接收者完全解耦，发送者只需要调用命令，而不需要知道具体的接收者是谁。相同的请求者可以使用不同的接收者，相同的接收者也可以为不同的请求者服务。 更动态的控制：命令模式可以将请求封装为对象，并动态进行参数化、队列化和日志化操作，使系统更加灵活。请求可以在不修改调用者的情况下被延迟执行或加入队列。 更容易的组合命令：命令模式允许你轻松实现命令队列或宏命令（组合多个命令的命令），使得系统可以执行复杂的操作序列。 更好的扩展性：命令模式符合“开闭原则”，可以轻松添加新的命令对象而无需修改现有代码。 模式缺点\n类的膨胀：命令模式可能会引入大量的具体命令类，每个操作对应一个具体的命令类，在一些复杂系统中可能导致类的数量急剧增加。 增大系统开销：由于命令对象的引入，系统需要为每个请求生成额外的命令对象，可能会导致一定的内存开销和处理开销，特别是当命令数量较多时。 请求排队的复杂性：如果命令模式与请求队列等复杂处理机制结合，可能会增加系统的复杂性，尤其是在管理命令的执行顺序和撤销操作时。 适用环境\n需要抽象出执行的动作：当需要将执行的动作抽象出来，并且将其参数化时，命令模式能够很好地将这些动作封装成命令对象，然后实现参数化配置。 需要在不同时间指定、排列和执行请求：如果系统要求在不同时间点指定请求并按照一定的顺序执行，命令模式可以将请求封装为命令对象，并通过队列或日志机制来管理它们的执行顺序。 需要支持撤销和重做操作：命令模式可以方便地实现撤销（Undo）和重做（Redo）操作。通过管理已执行的命令对象，可以支持对操作进行回滚或重做。 系统崩溃后的操作恢复：如果系统崩溃后需要恢复之前的操作，命令模式可以将操作请求封装成命令对象，并结合日志来记录命令列表，在系统恢复时重新执行这些命令。 事务性系统：在事务性系统中，命令模式能够将事务的操作封装为命令对象，正向遍历执行事务操作，出现异常时反向遍历进行回滚操作，实现事务管理。 迭代器模式 # 迭代器模式的本质：控制访问聚合对象中的元素。\n下图中使用内部类来实现上面 Concretelterator 关联 ConcreteAggregate\n而 createlterator 函数体现了依赖关系\n// 迭代器接口：定义用于遍历电视机频道的方法 public interface TVIterator { void setChannel(int i); // 设置当前频道 void next(); // 移动到下一个频道 void previous(); // 移动到上一个频道 boolean isLast(); // 判断是否为最后一个频道 Object currentChannel(); // 获取当前频道 boolean isFirst(); // 判断是否为第一个频道 } // 电视接口：提供创建迭代器的工厂方法 // 这是工厂方法模式的一部分，具体的电视机类将实现该接口，提供相应的迭代器 public interface Television { TVIterator createIterator(); } // TCL电视机类：实现Television接口并提供具体的频道及迭代器实现 public class TCLTelevision implements Television { private Object[] obj = { \u0026#34;湖南卫视\u0026#34;, \u0026#34;北京卫视\u0026#34;, \u0026#34;上海卫视\u0026#34;, \u0026#34;湖北卫视\u0026#34;, \u0026#34;黑龙江卫视\u0026#34; }; // 创建并返回具体的迭代器对象 public TVIterator createIterator() { return new TCLIterator(); } // TCL电视的迭代器实现：实现TVIterator接口，能够遍历TCL电视机的频道 class TCLIterator implements TVIterator { private int currentIndex = 0; // 移动到下一个频道 public void next() { if (currentIndex \u0026lt; obj.length) { currentIndex++; } } public void previous() { ... } } } // Skyworth电视机类：实现Television接口并提供具体的频道及迭代器实现 public class SkyworthTelevision implements Television { private Object[] obj = { \u0026#34;CCTV-1\u0026#34;, \u0026#34;CCTV-2\u0026#34;, \u0026#34;CCTV-3\u0026#34;, \u0026#34;CCTV-4\u0026#34;, \u0026#34;CCTV-5\u0026#34;, \u0026#34;CCTV-6\u0026#34;, \u0026#34;CCTV-7\u0026#34;, \u0026#34;CCTV-8\u0026#34; }; // 创建并返回具体的迭代器对象 public TVIterator createIterator() { return new SkyworthIterator(); } // Skyworth电视的迭代器实现：实现TVIterator接口，能够遍历Skyworth电视机的频道 private class SkyworthIterator implements TVIterator { private int currentIndex = 0; ... } } // 客户端类：模拟电视机操作，通过遍历器显示频道 public class Client // 正向遍历并显示所有频道 public static void display(Television tv) { TVIterator i = tv.createIterator(); System.out.println(\u0026#34;电视机频道：\u0026#34;); while (!i.isLast()) { System.out.println(i.currentChannel().toString()); i.next(); } } // 逆向遍历并显示频道 public static void reverseDisplay(Television tv) { TVIterator i = tv.createIterator(); i.setChannel(5); // 设置当前频道为第5个 System.out.println(\u0026#34;逆向遍历电视机频道：\u0026#34;); while (!i.isFirst()) { i.previous(); System.out.println(i.currentChannel().toString()); } } // 主程序入口，模拟从XML文件中获取具体的电视机对象并进行频道遍历 public static void main(String a[]) { Television tv; tv = (Television) XMLUtil.getBean(); // 动态获取具体的电视机对象 display(tv); System.out.println(\u0026#34;--------------------------\u0026#34;); reverseDisplay(tv); } } 模式扩展 # 内部迭代器和外部迭代器\n内部迭代器指的是由迭代器自己来控制迭代下一个元素的步骤，客户端无法干预，因此，如果想要在迭代的过程中完成工作的话，客户端就需要把操作传给迭代器，迭代器在迭代的时候会在每个元素上执行这个操作。\n外部迭代器指的是由客户端来控制迭代下一个元素的步骤，像前面的示例一样，客户端必须显示的调用next来迭代下一个元素。常见的实现多属于外部迭代器。\n带迭代策略的迭代器:\n实现的一个基本思路，就是先把聚合对象的聚合数据获取到，并存储到迭代器里面来，这样迭代器就可以按照不同的策略来迭代数据了。 双向迭代器: 可以同时向前或向后\n优点缺点： # 优点：\n支持多种遍历方式：通过替换不同的迭代器，可以在同一个聚合对象上使用不同的遍历算法。。 简化聚合类设计：迭代器模式将遍历逻辑从聚合类中分离，使得聚合类不再负责数据的遍历，简化了聚合类的设计。 符合开闭原则：引入抽象层后，新增聚合类和迭代器类时无需修改原有代码。 缺点：\n类的数量增加：由于职责分离，每增加一个新的聚合类通常需要对应增加一个迭代器类，导致类的数量成对增加，增加了系统的复杂性。 抽象迭代器设计难度高：设计一个通用的抽象迭代器并不容易，必须充分考虑未来的扩展需求，且这些子类不能用于所有类型的聚合结构。 适用环境：\n无须暴露内部结构：当需要访问聚合对象的内容，但不希望暴露其内部表示时，可以使用迭代器模式。 支持多种遍历方式：当需要为聚合对象提供多种遍历方式。 统一接口：为不同的聚合结构提供统一的遍历接口，客户端可以通过一致的方式操作不同的聚合结构。 中介者模式 # 中介者模式的本质：封装交互。\n// 中介者模式：抽象中介者 public abstract class AbstractChatroom { public abstract void register(Member member); // 注册成员 public abstract void sendText(String from, String to, String message); // 发送文本 public abstract void sendImage(String from, String to, String image); // 发送图片 } // 具体中介者：处理成员之间的消息传递 import java.util.*; public class ChatGroup extends AbstractChatroom { private Hashtable\u0026lt;String, Member\u0026gt; members = new Hashtable\u0026lt;\u0026gt;(); // 用哈希表存储对象 public void register(Member member) { // 注册成员，将成员加入聊天室 if (!members.contains(member)) { members.put(member.getName(), member); member.setChatroom(this); // 设置成员所属的聊天室 } } // 发送文本信息，并进行敏感词过滤 public void sendText(String from, String to, String message) { Member member = members.get(to); String newMessage = message.replaceAll(\u0026#34;C\u0026#34;, \u0026#34;*\u0026#34;); // 替换敏感词 member.receiveText(from, newMessage); // 接收文本 } // 发送图片，如果图片内容过长则发送失败 public void sendImage(String from, String to, String image) { Member member = members.get(to); if (image.length() \u0026gt; 5) { System.out.println(\u0026#34;图片太大，发送失败！\u0026#34;); } else { member.receiveImage(from, image); // 接收图片 } } } // 抽象同事类：成员基类 public abstract class Member { protected AbstractChatroom chatroom; // 中介者引用，用 protected protected String name; public Member(String name) { this.name = name; } ...// 经典 get 和 set public abstract void sendText(String to, String message); public abstract void sendImage(String to, String image); // 接收文本信息 public void receiveText(String from, String message) { System.out.println(from + \u0026#34;发送文本给\u0026#34; + this.name + \u0026#34;，内容为：\u0026#34; + message); } // 接收图片信息 public void receiveImage(String from, String image) { System.out.println(from + \u0026#34;发送图片给\u0026#34; + this.name + \u0026#34;，内容为：\u0026#34; + image); } } // 具体同事类：钻石会员 public class DiamondMember extends Member { public DiamondMember(String name) { super(name); } // 钻石会员可以发送文本 public void sendText(String to, String message) { System.out.println(\u0026#34;钻石会员发送信息：\u0026#34;); chatroom.sendText(name, to, message); // 通过中介者发送 } // 钻石会员可以发送图片 public void sendImage(String to, String image) { System.out.println(\u0026#34;钻石会员发送图片：\u0026#34;); chatroom.sendImage(name, to, image); // 通过中介者发送 } } // 具体同事类：普通会员 public class CommonMember extends Member { ... } // 客户端：模拟聊天室中的操作 public class Client { public static void main(String[] args) { // 创建具体中介者（聊天室） AbstractChatroom happyChat = new ChatGroup(); Member member1 = new DiamondMember(\u0026#34;张三\u0026#34;); // 创建多个会员（同事） Member member2 = new DiamondMember(\u0026#34;李四\u0026#34;); happyChat.register(member1); // 将会员注册到聊天室 happyChat.register(member2); // 模拟会员之间的消息传递 member1.sendText(\u0026#34;李四\u0026#34;, \u0026#34;李四，你好！\u0026#34;); member2.sendText(\u0026#34;张三\u0026#34;, \u0026#34;张三，你好！\u0026#34;); } } 优点缺点： # 优点：\n松散耦合：中介者模式通过将多个同事对象之间的交互逻辑封装到中介者对象中，减少了同事对象之间的直接依赖。各个同事对象可以独立变化或复用，避免了“牵一发而动全身”的问题。 集中控制交互：所有同事对象之间的交互逻辑由中介者集中管理，交互行为发生变化时，只需修改中介者对象，而无需修改同事对象，增强了系统的可扩展性和维护性。 多对多变成一对多：引入中介者后，同事对象之间的多对多关系变为中介者和同事对象之间的一对多关系，简化了对象间的关系，使系统结构更加清晰且易于理解和实现。 缺点：\n过度集中化：随着同事对象的交互复杂度增加，中介者对象可能变得非常复杂，承担过多的逻辑，导致中介者难以管理和维护，甚至出现“上帝对象”的问题。 适用环境：\n复杂的对象交互：当一组对象之间的通信方式复杂且相互依赖，导致系统难以维护时，可以采用中介者模式将交互逻辑集中管理，减少对象之间的直接依赖。 减少对象直接依赖：当一个对象需要与多个对象交互并导致耦合度过高时，可以使用中介者模式，将其与其他对象的交互封装到中介者中，降低耦合度并提高对象的复用性。 中介者模式和外观模式的区别\n备忘录模式 # 备忘录模式的本质：保存和恢复内部状态。\n// 备忘录模式：发起人类，负责创建和恢复备忘录 public class UserInfoDTO { private String account; private String password; private String telNo; ...//经典set get // 创建备忘录，保存当前状态 public Memento saveMemento() { return new Memento(account, password, telNo); } // 从备忘录中恢复状态 public void restoreMemento(Memento memento) { this.account = memento.getAccount(); this.password = memento.getPassword(); this.telNo = memento.getTelNo(); } // 显示当前状态 public void show() { System.out.println(\u0026#34;Account: \u0026#34; + this.account); System.out.println(\u0026#34;Password: \u0026#34; + this.password); System.out.println(\u0026#34;TelNo: \u0026#34; + this.telNo); } } // 备忘录模式：备忘录类，负责存储发起人的状态 class Memento { private String account; private String password; private String telNo; // 构造方法，保存状态 public Memento(String account, String password, String telNo) { this.account = account; this.password = password; this.telNo = telNo; } ...// 经典set get } // 备忘录模式：管理者类，负责保存和恢复备忘录 public class Caretaker { private Memento memento; // 获取备忘录 public Memento getMemento() { return memento; } // 保存备忘录 public void setMemento(Memento memento) { this.memento = memento; } } public class Client { public static void main(String[] args) { // 创建发起人（UserInfoDTO）和管理者（Caretaker） UserInfoDTO user = new UserInfoDTO(); Caretaker caretaker = new Caretaker(); // 设置初始状态 user.setAccount(\u0026#34;zhangsan\u0026#34;); user.setPassword(\u0026#34;123456\u0026#34;); user.setTelNo(\u0026#34;13000000000\u0026#34;); System.out.println(\u0026#34;状态一：\u0026#34;); user.show(); // 保存状态一到备忘录 // 把 save 里面 new 出来的 set 到caretaker 中 caretaker.setMemento(user.saveMemento()); user.setPassword(\u0026#34;111111\u0026#34;); user.setTelNo(\u0026#34;13100001111\u0026#34;); System.out.println(\u0026#34;状态二：\u0026#34;); user.show(); // 从备忘录中恢复到状态一 user.restoreMemento(caretaker.getMemento()); System.out.println(\u0026#34;回到状态一：\u0026#34;); user.show(); } } 优点缺点 # 优点：\n提供状态恢复机制：备忘录模式允许用户在状态无效或出错时，方便地回到某个特定的历史步骤，恢复之前的状态。 封装状态信息：备忘录对象对外部封装了原发器的状态，其他代码无法直接修改备忘录中的数据，从而保护了原发器的状态不被外界破坏。 支持多次撤销：通过使用列表、堆栈等集合来存储多个备忘录对象，可以实现多次的撤销操作，允许用户恢复到更早的状态。 缺点：\n资源消耗较大：如果原发器类的成员变量过多，每次保存状态都会占用大量的存储空间和系统资源，尤其是在需要频繁保存状态的情况下，资源消耗问题会更加突出。 适用环境：\n需要保存并恢复对象状态时：当需要保存对象的全部或部分状态以便日后恢复，或者实现撤销功能时，备忘录模式是一个合适的选择。 保护对象历史状态的封装性：当不希望对象的历史状态被外界对象破坏或暴露实现细节时，可以使用备忘录模式来保证对象状态的封装性和安全性。 备忘录模式和命令模式的组合使用 # 两者都提供了撤销或回到某个节点的功能，在命令模式执行撤回或重做的命令时，使用备忘录模式。\n备忘录模式和原型模式的组合使用 # 在原发器对象创建备忘录对象的时候，如果原发器对象中全部或者大部分的状态都需要保存，一个简洁的方式就是直接用原型模式克隆一个原发器对象。\n观察者模式 # 观察者模式的本质：触发联动。\n// 观察者接口：定义了观察者的接口，所有观察者都必须实现 response() 方法 public interface MyObserver { void response(); // 抽象响应方法 } // 具体观察者类：Dog 实现了 MyObserver 接口，定义了具体的响应行为 public class Dog implements MyObserver { @Override public void response() { System.out.println(\u0026#34;狗跟着叫！\u0026#34;); } } // 具体观察者类：Mouse 实现了 MyObserver 接口，定义了具体的响应行为 public class Mouse implements MyObserver { @Override public void response() { System.out.println(\u0026#34;老鼠吓得四处逃窜！\u0026#34;); } } public abstract class MySubject { // 用于存储观察者的列表，可以有多个观察者 protected ArrayList\u0026lt;MyObserver\u0026gt; observers = new ArrayList\u0026lt;\u0026gt;(); public void attach(MyObserver observer) { // 注册观察者方法 observers.add(observer); } public void detach(MyObserver observer) { // 注销观察者方法 observers.remove(observer); } // 抽象方法，具体的子类需要实现该方法来通知所有观察者 public abstract void cry(); } // 具体主体类：Cat 继承 MySubject，并实现 cry() 方法 public class Cat extends MySubject { @Override public void cry() { System.out.println(\u0026#34;猫叫了！\u0026#34;); // 通知所有注册的观察者，在父类中 for (MyObserver observer : observers) { // 在这里控制唤醒哪些观察者 observer.response(); } } } // 客户端代码：测试观察者模式 public class Client { public static void main(String[] args) { MySubject subject = new Cat(); // 创建多个观察者对象 MyObserver obs1 = new Mouse(); MyObserver obs3 = new Dog(); subject.attach(obs1); // 注册观察者到主体 subject.attach(obs3); // 触发主体行为（猫叫），并通知所有观察者 subject.cry(); } } 学习通例题： # // 回调函数接口 interface Runnable { void run(); } // 事件触发器类 class Trigger { // 事件名称与回调函数列表的映射 private Map\u0026lt;String, List\u0026lt;Runnable\u0026gt;\u0026gt; eventMap = new HashMap\u0026lt;\u0026gt;(); // 注册事件 public void on(String eventName, Runnable callback) { if (callback != null) { eventMap.computeIfAbsent(eventName, k -\u0026gt; new ArrayList\u0026lt;\u0026gt;()).add(callback); } } // 触发事件 public void raiseEvent(String eventName) { System.out.println(\u0026#34;Process \u0026#34; + eventName + \u0026#34; start\u0026#34;); List\u0026lt;Runnable\u0026gt; callbacks = eventMap.get(eventName); if (callbacks != null) { for (Runnable callback : callbacks) { callback.run(); // 执行回调 } } System.out.println(\u0026#34;Process \u0026#34; + eventName + \u0026#34; end\u0026#34;); } } // 示例回调函数 class Func01 implements Runnable { public void run() { System.out.println(\u0026#34;func01()\u0026#34;); } } class Func02 implements Runnable { public void run() { System.out.println(\u0026#34;func02()\u0026#34;); } } class Func03 implements Runnable { public void run() { System.out.println(\u0026#34;func03()\u0026#34;); } } // 测试代码 public class Main { public static void main(String[] args) { // 创建事件触发器 Trigger trigger = new Trigger(); // 注册事件 trigger.on(\u0026#34;event01\u0026#34;, new Func01()); trigger.on(\u0026#34;event01\u0026#34;, new Func02()); trigger.on(\u0026#34;event02\u0026#34;, new Func02()); trigger.on(\u0026#34;event03\u0026#34;, new Func03()); // 触发事件 trigger.raiseEvent(\u0026#34;event01\u0026#34;); trigger.raiseEvent(\u0026#34;event02\u0026#34;); trigger.raiseEvent(\u0026#34;event03\u0026#34;); trigger.raiseEvent(\u0026#34;event01\u0026#34;); // 再次触发 event01 trigger.raiseEvent(\u0026#34;event02\u0026#34;); // 再次触发 event02 } } 优点缺点： # 优点：\n解耦目标与观察者：目标对象只依赖于抽象的观察者接口，不需要知道具体的观察者类，降低了耦合度。 动态联动：通过动态注册和管理观察者，允许在运行时控制通知范围，实现灵活的联动效果。 支持广播通信：目标对象可向所有注册的观察者广播通知，适应一对多的通信需求，同时也可扩展限制广播的范围。 符合开闭原则：增加新的观察者无需修改现有代码，系统扩展性强。 缺点：\n性能问题：每次通知都会广播给所有观察者，可能导致性能浪费。应及时注销不需要的观察者。 避免死循环：若两个对象互为观察者和目标，可能产生相互通知的死循环，需要特别注意设计。 适用环境：\n对象间存在依赖关系：一个对象的改变需要通知其他对象，但不需知道具体有哪些对象会受到影响。 触发链场景：当需要创建链式触发机制时，使用观察者模式可以让一个对象的行为依次影响其他对象。 状态模式 # 状态模式的本质：根据状态来分离和选择行为。\n状态模式将一个对象的状态从该对象中分离出来，封装到专门的状态类中，使得对象状态可以灵活变化。\n关键是状态转移以及 state 中的 statecheck 函数\n// 抽象状态类：定义了用户行为的抽象接口 public abstract class AbstractState { protected ForumAccount acc; // 用户账户 protected int point; // 用户积分 protected String stateName; // 状态名称 // 状态检查方法，子类具体实现 public abstract void checkState(int score); // 文件下载行为，默认实现 public void downloadFile(int score) { System.out.println(acc.getName() + \u0026#34;下载文件，扣除\u0026#34; + score + \u0026#34;积分。\u0026#34;); this.point -= score; checkState(score); System.out.println(\u0026#34;剩余积分为：\u0026#34; + this.point + \u0026#34;，当前级别为：\u0026#34; + acc.getState().stateName); } ... } // 具体状态类：新手状态 public class PrimaryState extends AbstractState { public PrimaryState(AbstractState state) { this.acc = state.acc; this.point = state.getPoint(); this.stateName = \u0026#34;新手\u0026#34;; } public PrimaryState(ForumAccount acc) { this.point = 0; this.acc = acc; this.stateName = \u0026#34;新手\u0026#34;; } @Override public void downloadFile(int score) { System.out.println(\u0026#34;对不起，\u0026#34; + acc.getName() + \u0026#34;，您没有下载文件的权限！\u0026#34;); } @Override public void checkState(int score) { if (point \u0026gt;= 1000) { acc.setState(new HighState(this)); } else if (point \u0026gt;= 100) { acc.setState(new MiddleState(this)); } } } // 具体状态类：高手状态 public class MiddleState extends AbstractState { ... } // 具体状态类：专家状态 public class HighState extends AbstractState { ... } // 用户账户类：负责管理用户的状态 public class ForumAccount { private AbstractState state; private String name; public ForumAccount(String name) { // 改变状态 this.name = name; this.state = new PrimaryState(this); // ForumAccount 和 PrimaryState 相互关联 } public void setState(AbstractState state) { // 经典 set 与 get this.state = state; } public AbstractState getState() { return this.state; } public String getName() { return this.name; } public void downloadFile(int score) { state.downloadFile(score); } public void writeNote(int score) { state.writeNote(score); } public void replyNote(int score) { state.replyNote(score); } } // 客户端代码：用于测试状态模式的实现 public class Client { public static void main(String[] args) { ForumAccount account = new ForumAccount(\u0026#34;张三\u0026#34;); account.writeNote(20); account.downloadFile(20); account.replyNote(100); ... } } 实例2 # 画出状态转移图：\n实例代码（工程性质很强，不是传统模板）：\n// 抽象状态类：定义账户状态的抽象行为 abstract class AccountState { protected Account acc; // 关联的账户对象 public abstract void deposit(double amount); // 存款操作 public abstract void withdraw(double amount); // 取款操作 public abstract void computeInterest(); // 计算利息 // 最重要的：状态检查与转换 public abstract void stateCheck(); } // 正常状态：具体状态类 class NormalState extends AccountState { // 通过账户对象创建正常状态 public NormalState(Account acc) { this.acc = acc; } // 通过状态对象创建正常状态 public NormalState(AccountState state) { this.acc = state.acc; } // 存款操作并检查状态转换 public void deposit(double amount) { acc.setBalance(acc.getBalance() + amount); stateCheck(); } // 取款操作并检查状态转换 public void withdraw(double amount) { acc.setBalance(acc.getBalance() - amount); stateCheck(); } // 正常状态下无需支付利息 public void computeInterest() { System.out.println(\u0026#34;正常状态，无须支付利息！\u0026#34;); } // 状态转换逻辑 public void stateCheck() { if (acc.getBalance() \u0026gt; -2000 \u0026amp;\u0026amp; acc.getBalance() \u0026lt;= 0) { acc.setState(new OverdraftState(this)); } else if (acc.getBalance() == -2000) { acc.setState(new RestrictedState(this)); } else if (acc.getBalance() \u0026lt; -2000) { System.out.println(\u0026#34;操作受限！\u0026#34;); } } } // 透支状态：具体状态类 class OverdraftState extends AccountState { // 通过状态对象创建透支状态 public OverdraftState(AccountState state) { this.acc = state.acc; } // 存款操作并检查状态 public void deposit(double amount) { acc.setBalance(acc.getBalance() + amount); stateCheck(); } // 取款操作并检查状态 public void withdraw(double amount) { acc.setBalance(acc.getBalance() - amount); stateCheck(); } // 透支状态下计算利息 public void computeInterest() { System.out.println(\u0026#34;计算利息！\u0026#34;); } // 状态转换逻辑 public void stateCheck() { if (acc.getBalance() \u0026gt; 0) { acc.setState(new NormalState(this)); } else if (acc.getBalance() == -2000) { acc.setState(new RestrictedState(this)); } else if (acc.getBalance() \u0026lt; -2000) { System.out.println(\u0026#34;操作受限！\u0026#34;); } } } // 受限状态：具体状态类 class RestrictedState extends AccountState { // 通过状态对象创建受限状态 public RestrictedState(AccountState state) { this.acc = state.acc; } // 存款操作并检查状态 public void deposit(double amount) { acc.setBalance(acc.getBalance() + amount); stateCheck(); } // 受限状态下取款失败 public void withdraw(double amount) { System.out.println(\u0026#34;帐号受限，取款失败\u0026#34;); } // 受限状态下计算利息 public void computeInterest() { System.out.println(\u0026#34;计算利息！\u0026#34;); } // 状态转换逻辑 public void stateCheck() { if (acc.getBalance() \u0026gt; 0) { acc.setState(new NormalState(this)); } else if (acc.getBalance() \u0026gt; -2000) { acc.setState(new OverdraftState(this)); } } } // 账户类：负责管理账户的当前状态 class Account { private AccountState state; // 账户当前状态 private String owner; // 账户持有者 private double balance; // 账户余额 // 构造函数，初始化账户并设置初始状态为正常状态 public Account(String owner, double balance) { this.owner = owner; this.balance = balance; this.state = new NormalState(this); // 初始状态为正常状态 System.out.println(this.owner + \u0026#34;注册成功，初始余额为：\u0026#34; + this.balance); } // 存款操作，将操作委托给当前状态 public void deposit(double amount) { state.deposit(amount); System.out.println(\u0026#34;存款 \u0026#34; + amount + \u0026#34; 元，当前余额：\u0026#34; + this.balance); System.out.println(\u0026#34;当前账户状态：\u0026#34; + state.getClass().getSimpleName()); } // 取款操作，将操作委托给当前状态 public void withdraw(double amount) { state.withdraw(amount); System.out.println(\u0026#34;取款 \u0026#34; + amount + \u0026#34; 元，当前余额：\u0026#34; + this.balance); System.out.println(\u0026#34;当前账户状态：\u0026#34; + state.getClass().getSimpleName()); } // 计算利息，将操作委托给当前状态 public void computeInterest() { state.computeInterest(); } // 设置账户状态 public void setState(AccountState state) { this.state = state; } // 获取账户当前状态 public AccountState getState() { return this.state; } // 设置账户余额 public void setBalance(double balance) { this.balance = balance; } // 获取账户余额 public double getBalance() { return this.balance; } } // 客户端测试代码 class Client { public static void main(String args[]) { Account acc = new Account(\u0026#34;张三\u0026#34;, 0.0); // 创建账户并初始化 acc.deposit(1000); // 存款 1000 acc.withdraw(2000); // 取款 2000，进入透支状态 acc.deposit(3000); // 存款 3000，返回正常状态 acc.withdraw(4000); // 取款 4000，再次进入透支状态 acc.withdraw(1000); // 取款 1000，进入受限状态 acc.computeInterest(); // 计算利息 } } 优点缺点 # 优点\n简化逻辑控制 将状态处理封装到独立类中，分散复杂的控制逻辑，使得代码结构清晰，便于维护。 状态与行为分离 通过公共接口分离状态和行为，应用程序只需关注状态切换，而无需关心具体行为处理。 扩展性强 新增状态只需增加实现类，并在状态维护中加入转换逻辑，扩展方便。 显式状态转换 独立的状态对象使转换明确，保证状态一致性，避免内部状态不一致问题。 缺点\n类和对象增多 引入多个状态类，增加系统的复杂性和运行开销。 实现复杂 不当使用可能导致结构复杂，增加设计和维护难度。 对开闭原则支持有限 新增状态时需修改状态转换逻辑，影响开闭原则。 适用场景\n对象行为依赖其内部状态，且状态变化会引起行为变化。 代码中存在大量与状态相关的条件判断，影响代码的灵活性和可维护性。 模型扩展 # 共享状态：如果希望在系统中实现多个环境对象实例共享一个或多个状态对象，那么需要将这些状态对象定义为环境的静态成员对象。\n// 开关类：管理开关状态 class Switch { private State state; // 当前状态 private static State onState = new OnState(); // 打开状态， 静态 private static State offState = new OffState(); // 关闭状态， 静态 private String name; // 开关名称 // 构造函数，初始化为打开状态 public Switch(String name) { this.name = name; this.state = onState; // 默认状态为打开 } public void setState(State state) { this.state = state; } public void on() { // 开关打开操作 System.out.print(name); state.on(this); } public void off() { // 开关关闭操作 System.out.print(name); state.off(this); } // 根据类型获取状态 public static State getState(String type) { if (type.equalsIgnoreCase(\u0026#34;on\u0026#34;)) { return onState; } else { return offState; } } } // 抽象状态类：定义开关状态的行为接口 abstract class State { public abstract void on(Switch s); public abstract void off(Switch s); } class OnState extends State {// 打开状态类 public void on(Switch s) { System.out.println(\u0026#34;已经打开！\u0026#34;); } public void off(Switch s) { System.out.println(\u0026#34;关闭！\u0026#34;); s.setState(Switch.getState(\u0026#34;off\u0026#34;)); // 转换到关闭状态 } } class OffState extends State {// 关闭状态类 public void on(Switch s) { System.out.println(\u0026#34;打开！\u0026#34;); s.setState(Switch.getState(\u0026#34;on\u0026#34;)); // 转换到打开状态 } public void off(Switch s) { System.out.println(\u0026#34;已经关闭！\u0026#34;); } } // 客户端测试代码 class Client { public static void main(String[] args) { Switch s1 = new Switch(\u0026#34;开关1\u0026#34;); Switch s2 = new Switch(\u0026#34;开关2\u0026#34;); s1.on(); // 开关1 打开 s2.on(); // 开关2 打开 s1.off(); // 开关1 关闭 s2.off(); // 开关2 关闭 s2.on(); // 开关2 打开 s1.on(); // 开关1 已经打开 } } 简单状态模式：简单状态模式是指状态都相互独立，没有状态转化，遵循“开闭原则”。\n可切换状态的状态模式：也就是上面实例中的模式，在具体状态类内部需要调用环境类Context的setState()方法进行状态的转换操作，在具体状态类中可以调用到环境类的方法。\n状态模式和观察者模式的区别：这两个模式都是在状态发生改变的时候触发行为，只不过观察者模式的行为是固定的，那就是通知所有的观察者，而状态模式是根据状态来选择不同的处理，当状态发生改变的时候，动态改变行为。\n策略模式 # 策略模式的本质：分离算法，选择实现。\n结构上和简单状态模式非常相似，策略模式更强调策略的选择，而状态模式强调状态的多变。\n// 定义排序策略接口 public interface Sort { int[] sort(int[] arr); } // ArrayHandler 类：持有 Sort 策略对象 public class ArrayHandler { private Sort sortObj; // 设置具体的排序策略 public void setSortObj(Sort sortObj) { this.sortObj = sortObj; } // 调用策略进行排序 public int[] sort(int[] arr) { return sortObj.sort(arr); } } // 冒泡排序实现类 public class BubbleSort implements Sort { public int[] sort(int[] arr) { // 省略排序具体实现 return arr; } } // 插入排序实现类 public class InsertionSort implements Sort { public int[] sort(int[] arr) { // 省略排序具体实现 return arr; } } // Client 类：客户端代码 public class Client { public static void main(String[] args) { int[] arr = {1, 4, 6, 2, 5, 3, 7, 10, 9}; ArrayHandler arrayHandler = new ArrayHandler(); // 获取具体的排序策略对象 Sort sort = (Sort) XMLUtil.getBean(); arrayHandler.setSortObj(sort); // 设置策略 // 执行排序 int[] result = arrayHandler.sort(arr); // 输出排序结果 for (int i : result) { System.out.print(i + \u0026#34;, \u0026#34;); } } } 优点缺点 # 优点\n算法复用：将算法封装在策略类中，多个环境可复用，避免重复代码。 管理算法族：通过继承共享公共代码，简化算法管理。 减少条件语句：避免大量条件判断，将算法选择与实现分离。 替代继承：支持运行时动态切换算法，遵循单一职责原则。 符合开闭原则：便于在不修改现有代码的情况下扩展新算法。 缺点\n增加复杂度：客户端需了解所有策略并自行选择，增加系统复杂性。 类数量多：每个策略都需要独立类，类数量随策略增多而增加。 仅适用于平等算法：不适合嵌套或组合算法的复杂场景。 适用场景\n动态选择算法：系统需在多种算法间切换时。 避免复杂条件判断：通过策略模式简化多重选择语句。 隐藏算法细节：封装复杂算法，提升安全性和可维护性。 算法扩展 # 策略模式与状态模式的比较：\n模板方法模式 # 模板方法模式的本质：固定算法骨架。\n模板模式的结构非常简单，如下：\npublic abstract class BankTemplateMethod { public void takeNumber() { System.out.println(\u0026#34;取号排队。\u0026#34;); } public abstract void transact();\tpublic void evaluate() { System.out.println(\u0026#34;反馈评分。\u0026#34;); } // 模板模式的核心是改变一个过程中的一部分 public void process() { this.takeNumber(); this.transact(); this.evaluate(); } } 上面例子就是继承，下面可以看看钩子方法。让子类能够插入或跳过算法中的某些步骤。\n// 核心在下面的 isValid 中体现钩子方法，这样跳过了父类的 convertData() public abstract class HookDemo { public abstract void getData(); public void convertData() { System.out.println(\u0026#34;通用的数据转换操作。\u0026#34;); } public abstract void displayData(); public void process() { getData(); if (isValid()) { convertData(); } displayData(); } public boolean isValid() { return true; } } class SubHookDemo extends HookDemo { public void getData() { System.out.println(\u0026#34;从XML配置文件中获取数据。\u0026#34;); } public void displayData() { System.out.println(\u0026#34;以柱状图显示数据。\u0026#34;); } public boolean isValid() { return false; } } class Client { public static void main(String a[]) { HookDemo hd; hd = new SubHookDemo(); hd.process(); } } 作业多的一道题！ # import java.util.*; // 回调函数接口 interface Runnable { void run(); } // 事件触发器类 class Trigger { // 事件名称与回调函数列表的映射 private Map\u0026lt;String, List\u0026lt;Runnable\u0026gt;\u0026gt; eventMap = new HashMap\u0026lt;\u0026gt;(); // 注册事件 public void on(String eventName, Runnable callback) { if (callback != null) { eventMap.computeIfAbsent(eventName, k -\u0026gt; new ArrayList\u0026lt;\u0026gt;()).add(callback); } } // 触发事件 public void raiseEvent(String eventName) { System.out.println(\u0026#34;Process \u0026#34; + eventName + \u0026#34; start\u0026#34;); List\u0026lt;Runnable\u0026gt; callbacks = eventMap.get(eventName); if (callbacks != null) { for (Runnable callback : callbacks) { callback.run(); // 执行回调 } } System.out.println(\u0026#34;Process \u0026#34; + eventName + \u0026#34; end\u0026#34;); } } // 示例回调函数 class Func01 implements Runnable { public void run() { System.out.println(\u0026#34;func01()\u0026#34;); } } class Func02 implements Runnable { public void run() { System.out.println(\u0026#34;func02()\u0026#34;); } } class Func03 implements Runnable { public void run() { System.out.println(\u0026#34;func03()\u0026#34;); } } // 测试代码 public class Main { public static void main(String[] args) { // 创建事件触发器 Trigger trigger = new Trigger(); // 注册事件 trigger.on(\u0026#34;event01\u0026#34;, new Func01()); trigger.on(\u0026#34;event01\u0026#34;, new Func02()); trigger.on(\u0026#34;event02\u0026#34;, new Func02()); trigger.on(\u0026#34;event03\u0026#34;, new Func03()); // 触发事件 trigger.raiseEvent(\u0026#34;event01\u0026#34;); trigger.raiseEvent(\u0026#34;event02\u0026#34;); trigger.raiseEvent(\u0026#34;event03\u0026#34;); trigger.raiseEvent(\u0026#34;event01\u0026#34;); // 再次触发 event01 trigger.raiseEvent(\u0026#34;event02\u0026#34;); // 再次触发 event02 } } Java 语法： # 1. 深拷贝与浅拷贝 # 浅拷贝 # 浅拷贝是指创建一个新对象，但其中的字段（特别是引用类型的字段）仍然指向原始对象中相同的引用。\n特点\n基本类型的字段会被复制。 引用类型的字段不会被复制，只是复制引用，两个对象共享同一个引用类型的实例。 实现方式\n实现 Cloneable 接口并重写 clone() 方法。 使用 super.clone() 来进行浅拷贝。 class Person implements Cloneable { String name; int age; public Person(String name, int age) { this.name = name; this.age = age; } // 浅拷贝 @Override protected Object clone() throws CloneNotSupportedException { return super.clone(); // 这是浅拷贝 } } public class Main { public static void main(String[] args) throws CloneNotSupportedException { Person p1 = new Person(\u0026#34;Alice\u0026#34;, 25); Person p2 = (Person) p1.clone(); // 浅拷贝 System.out.println(p1.name == p2.name); // true，引用相同 } } 深拷贝 # 深拷贝是指创建一个新对象，并且递归地复制所有字段，包括引用类型字段所引用的对象，使得新对象与原对象完全独立。\n实现方式： 手动克隆每一个引用类型的字段。 使用序列化进行深拷贝（通过将对象序列化再反序列化来实现深拷贝）。 class Address { String city; public Address(String city) { this.city = city; } } class Person implements Cloneable { String name; int age; Address address; public Person(String name, int age, Address address) { this.name = name; this.age = age; this.address = address; } // 深拷贝 @Override protected Object clone() throws CloneNotSupportedException { Person cloned = (Person) super.clone(); cloned.address = new Address(this.address.city); // 深拷贝，创建新的Address return cloned; } } public class Main { public static void main(String[] args) throws CloneNotSupportedException { Address address = new Address(\u0026#34;New York\u0026#34;); Person p1 = new Person(\u0026#34;Alice\u0026#34;, 25, address); Person p2 = (Person) p1.clone(); // 深拷贝 System.out.println(p1.address.city == p2.address.city); // false，引用不同 } } 2. 列表（List） # 列表（List） 是 Java 中常用的数据结构之一，用于存储有序的元素集合。List 接口有多个实现类，如 ArrayList 和 LinkedList。\nArrayList # 基于动态数组实现，支持快速的随机访问。 插入和删除操作代价较高，尤其是在列表中间进行操作时，因为需要移动元素。 import java.util.ArrayList; import java.util.List; public class Main { public static void main(String[] args) { // 创建一个ArrayList List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); // 添加元素 list.add(\u0026#34;Alice\u0026#34;); list.add(\u0026#34;Bob\u0026#34;); list.add(\u0026#34;Charlie\u0026#34;); // 获取元素 System.out.println(list.get(1)); // 输出：Bob // 删除元素 list.remove(0); // 遍历列表 for (String name : list) { System.out.println(name); } } } 3. 哈希表（HashMap） # 哈希表（HashMap） 是 Java 中用于存储键值对的常用数据结构之一。它基于哈希函数实现，能够在常数时间内完成插入、删除和查找操作。\nHashMap 的常用操作 # import java.util.HashMap; import java.util.Map; public class Main { public static void main(String[] args) { // 创建一个HashMap Map\u0026lt;String, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); // 添加键值对 map.put(\u0026#34;Alice\u0026#34;, 25); map.put(\u0026#34;Bob\u0026#34;, 30); map.put(\u0026#34;Charlie\u0026#34;, 35); // 获取值 System.out.println(map.get(\u0026#34;Alice\u0026#34;)); // 输出：25 // 删除键值对 map.remove(\u0026#34;Bob\u0026#34;); // 遍历HashMap for (Map.Entry\u0026lt;String, Integer\u0026gt; entry : map.entrySet()) { System.out.println(entry.getKey() + \u0026#34;: \u0026#34; + entry.getValue()); } } } 4. 关键字： # abstract：用于声明抽象类或抽象方法，不能直接实例化。\nabstract class Animal { public abstract void sound(); } interface：用于声明接口，类通过 implements 实现接口中的方法。\ninterface Animal { void sound(); } extends：用于声明类的继承关系，子类继承父类的属性和方法。\nclass Dog extends Animal { void sound() { System.out.println(\u0026#34;Bark\u0026#34;); } } implements：用于声明类实现接口，一个类可以实现一个或多个接口。\nclass Dog implements Animal { public void sound() { System.out.println(\u0026#34;Bark\u0026#34;); } } public、protected、private：用于声明类、方法或变量的访问权限。\npublic class Animal { protected String name; private void sound() { } } static：用于声明类变量或类方法，不依赖对象实例访问。\npublic static int count = 0; // 静态变量 final：用于声明常量、不可继承的类、不可重写的方法。\npublic final class Constants { public static final double PI = 3.14; } super：用于引用父类的构造方法或方法。\nclass Dog extends Animal { Dog() { super.sound(); } } this：用于引用当前对象，通常用于区分类的成员变量与局部变量。\nclass Animal { private String name; Animal(String name) { this.name = name; } } Serializable：原型模式深拷贝，序列化基类。\npublic class Attachment implements Serializable Cloneable：原型模式浅拷贝，可以克隆基类。\npublic class Email implements Cloneable 5. 输入输出 # // 创建 Scanner 对象，用于从控制台读取输入 Scanner scanner = new Scanner(System.in); // 读取字符串 System.out.print(\u0026#34;Enter your name: \u0026#34;); String name = scanner.nextLine(); 简答题总结 # 2018 # 为什么优先使用对象组合而不是类继承 因为继承会使类之间高度耦合，组合确实比继承更加灵活，也更有助于代码维护。\n请举例说明你对创建型设计模式的理解 创建型模式分为5种：简单工厂模式、工厂模式、抽象工厂模式、原型模式、单例模式。它重点在于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。\n请举例说明哪些情况下可以使用组合模式 宏命令，MVC中的View图，文件夹的管理\n抽象工厂模式和原型模式有哪些相同和不同，可以联合使用吗？ 抽象工厂模式：通常由工厂方法模式来实现。但一个工厂中往往含有多个工厂方法生成一系列的产品。这个模式强调的是客户代码一次保证只使用一个系列的产品。当要切换为另一个系列的产品，换一个工厂类即可。 原型模式：工厂方法的最大缺点就是，对应一个继承体系的产品类，要有一个同样复杂的工厂类的继承体系。原型模式中的工厂方法为clone，它会返回一个拷贝（可以是浅拷贝，也可以是深拷贝，由设计者决定）。为了保证用户代码中到时可以通过指针调用clone来动态绑定地生成所需的具体的类。这些原型对象必须事先构造好。 原型模式相对工厂方法模式的另一个好处是，拷贝的效率一般对构造的效率要高。 二者可以联合成为原型工厂模式\n请给出一个适合使用策略模式的示例场景，并说明与不使用策略模式相比，使用策略模式有哪些优点 超市的各种折扣策略。 策略模式满足“开闭原则”，超市可以在不修改原有系统的基础上选择算法和行为，对现有优惠策略的变更非常方便。策略模式可以避免使用多重条件转移语句\n2017 # 请举例说明你对白箱复用和黑箱复用的理解 继承就是白箱复用，对于父类的封装性不好；组合时黑箱复用，调用者并不清楚依赖对象的实现细节。\nGOF设计模式有几种类型，分别包括那些模式 23种，分别是创建型模式（5种）、结构型模式（7种）、行为型模式（11种）\n请举例说明桥接模式如何将抽象部分与它的实现部分分离，使它们可以独立地变化 假如你有一个几何形状Shape类，从它能扩展出两个子类： 圆形Circle和 方形Square 。 你希望对这样的类层次结构进行扩展以使其包含颜色，所以你打算创建名为红色Red和蓝色Blue的形状子类。 如图所示的桥接模式uml图实现了在颜色和形状两个维度上的划分：\n简述组合模式和装饰模式的基本思路，并说明两者有何异同 组合模式是组合多个对象形成树形结构以表示’整体-部分’的关系层次，组合模式对单个对象和组合对象的使用具有一致性。 装饰模式则强调能给一个对象增加一些额外的职责和功能。 二者都属于结构型模式，意在将类或者对象结合在一起形成更大的结构。 组合模式相较于装饰模式，实现对象往往含有树形结构，并且引入了抽象容器构建类使得客户端能以一致的方式处理树形结构中的叶子节点和容器节点。\n2016 # 简述什么是硬编码，并说明硬编码有什么缺点？ 硬编码是将数据直接嵌入到程序或其他可执行对象的源代码中的软件开发实践。其特点有： ①硬编码数据通常只能通过编辑源代码和重新编译可执行文件来修改 ②硬编码的数据通常表示不变的信息，例如物理常量，版本号和静态文本元素。\n简述类适配器模式和对象适配器模式的基本思想，并说明两者有和异同 二者的基本思想都是：将一个类的接口变成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。 不同在于对象适配器——将Adapter类作修改，不是继承Adaptee类，而是持有Adaptee的实例，以解决兼容性的问题。对象适配器更符合“合成复用原则”（系统中尽量使用关联关系来替代继承关系）。\n简述工厂方法模式和抽象工厂模式的基本思想，并说明两者有何异同 工厂模式：定义一个用于创建对象的借口，让子类决定实例化哪一个类。 抽象工厂模式：为创建一组相关或相互依赖的对象提供一个接口，而且无需指定他们的具体类。 基本思想都是将对象的创建与使用分离。 区别在于：产品是否单一，如果产品单一，最合适用工厂模式，但是如果有多个业务品种、业务分类时，通过抽象工厂模式产生需要的对象是一种非常好的解决方式。再通俗深化理解下：工厂模式针对的是一个产品等级结构 ，抽象工厂模式针对的是面向多个产品等级结构的。\n简述状态模式和策略模式的基本思想，并说明两者有何异同？ 策略模式定义了算法族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。 状态模式允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。 状态模式策略模式很相似，都将类的\u0026quot;状态\u0026quot;封装了起来，在执行动作时进行自动的转换，从而实现，类在不同状态下的同一动作显示出不同结果。 但状态模式与策略模式的区别在于，这种转换是\u0026quot;自动\u0026quot;，\u0026ldquo;无意识\u0026quot;的。\n现在大多数软件都有撤销和重做的功能，请问这种功能一般是草用什么设计模式实现的，并举例说明是如何实现的。 主要使用的是命令模式 。\n2015 # 面向对象软件设计中，给一个类或对象增加行为（新功能）的方式有哪些？请举例说明 继承机制：使用继承机制是给现有类添加功能的一种有效途径，通过继承一个现有类可以使得子类在拥有自身方法的同时还拥有父类的方法，但是这种方法是静态的，用户不能控制增加行为的方式和时机。\n关联机制：将一个类的对象嵌入另一个对象中，由另一个对象来调用嵌入对象的行为同时扩展其行为，我们称另一个对象为装饰器。\n装饰模式：装饰者模式允许动态地为对象增加新的功能，而无需修改现有类的代码。这种模式通过将对象封装到另一个对象中来实现扩展。\n简述外观模式和中介者模式的基本思想，并说明两者有何异同？ 外观模式：为子系统的一组接口提供一个统一的入口。 中介者模式：用一个中介对象来封装一系列的对象交互，使原有个对象之间不需要显示地相互引用，从而使其耦合松散。 外观模式封装的是子系统外部和子系统内部模块间的交互；而中介者模式是提供多个平等的同事对象之间交互关系的封装，一般是用在内部实现上。也就是说外观模式是外部到系统内部的单向的交互，中介者模式是内部多个模块的多向的交互。\n请给出一个适合使用状态模式的示例场景，并说明与不适用状态模式相比，有哪些优点？ 在标准大气压条件下，水在温度低于0℃为固态，0~100℃为液态，大于100℃为气态。 用状态模式的优点： ①封装了状态的转换规则，可以对相应代码进行集中管理 ②将与状态相关的行为放在一个类，只需要注入不同状态即可让环境对象拥有不同的行为 ③状态模式避免了使用庞大的条件语句与转换代码\n你认为设计模式能否增强软件复用性？请列举两个模式并结合实例进行说明。 能。1. 工厂模式（Factory Pattern）\n工厂模式将对象的创建逻辑集中在工厂类中，客户端只需通过工厂获取对象，而无需直接实例化。这样，创建逻辑可以复用，且扩展时只需修改工厂类，不影响客户端代码。\n示例：\nclass ShapeFactory: def create_shape(self, shape_type): if shape_type == \u0026#34;circle\u0026#34;: return Circle() if shape_type == \u0026#34;rectangle\u0026#34;: return Rectangle() 通过工厂模式，不同的客户端都可以复用同一工厂创建对象，扩展时无需修改客户端代码。\n策略模式（Strategy Pattern）\n策略模式将算法封装在独立的类中，允许在运行时动态替换算法。不同的策略可被不同客户端复用，同时新策略添加时无需修改现有代码。\n示例：\nclass ShoppingCart: def __init__(self, strategy): self.strategy = strategy def checkout(self, amount): self.strategy.pay(amount) 策略模式使得不同的支付方式可灵活替换和复用，扩展性强。\n这两种模式均通过解耦和模块化设计提高了代码的维护性和复用性。\n2014.2 # 在面向对象设计时，采用水平关联（含依赖、组合、聚合、普通关联等）的方法或者继承都可以适应变化。请说明两种方式在适应变化上各自的优缺点。 组合关系—— 优点①不破环封装性，类之间松耦合，彼此相对独立 ②具有较好的可扩展性 ③在运行时，整体对象可以选择不同类型的局部对象 ④整体可以对局部进行包装，封装局部类的接口提供新的接口 缺点①整体类不能自动获得和局部类同样的接口 ②创建整体类的对象时需要创建所有局部类的对象\n继承关系—— 优点①子类能自动继承父类的接口 ②子类对象创建时，无需创建父类对象 缺点①破坏封装性，父类子类之间紧耦合，子类依赖父类实现，缺乏独立性 ②支持扩展，但往往以增加系统结构为代价 ③不支持动态继承，在运行时子类无法选择不同的父类 ④子类不能改变父类的接口\n变化整体上分为接口变化和实现变化。若这两类变化同时存在，通常应首先采用那种设计模式分离稳定与变化部分？举例说明如何设计。 工厂方法、桥接模式、策略模式都可以。 所谓的变化部分我们可以理解为接口或者类的扩展，而呈现给客户的只是一个统一的接口，用户不必关心内部如何实现，只要每次调用同一个方法，只传不同即可，而针对接口的变化，采用以上结合适配器模式即可转换关键代码部分。\n请举例说明什么是简单工厂方法？什么是单件（单例）模式？分别是如何实现的？ 简单工厂模式可以根据参数的不同返回不同类的实例。 单例模式是确保莫一个类只有一个实例，并且能自行实例化并向这个系统提供这个实例。\n线性聚集关系是一种现实中常见的逻辑关系，如一个A聚集多个B，一个B聚集多个C，…….。使用合成模式可以统一的接口访问各个部分。请给出本例应用合成模式的设计类图。子类聚集父类时该模式的特点之一，请再说出也具有该特点的其它几个模式的名称。 装饰模式、观察者模式\n为达到某些设计目的，设计时可以同时组合使用多个设计模式。请举出一个同时组合使用策略模式和对象适配器模式。要求给出例子的应用场景，设计方案。 应用场景：User中提供给用户的接口是一个普通的按钮，通过点击按钮实现排序算法，该排序算法可能在不同的时间发生改变（用户可以实现其他算法，按钮也可能变成倒计时等形式触发算法行为）。\n2014.3 # 软件公司要开发一个图形界面组件库，界面组件分为两大类，一类是单元控件（例如：按钮、文本框等），一类是容器控件，例如对话框、表单等，请问采用何种模式设计比较好？请画出UML设计类图 组合模式，\n化妆品公司的报表系统可将不同月份的销售数据以柱状图、曲线图和饼状图等多种形式展示出来。各个月份的销售数据可以从文本文件中获取，也可以从数据库中获取，还可以从Excel文件中获取，如果需要从Excel文件中获取数据，则需要调用与Excel相关的API，而这个API是现有系统所不具备的，该API由厂商提供。请问采用何种模式设计比较好？请画出UML设计类图。 桥接模式+适配器模式\n你认为面向对象方法中类设计的难点是什么，如何应对？ 难点：设计可复用的类要求必须找到相关的对象，以适当的粒度归类，在定义类的接口和继承层次，建立对象间的基本关系。你的设计应该对手头的问题有针对性，同时对将来的问题和需求也要有足够的通用性。你也希望避免重复设计或尽可能少做重复设计。 应对方法：学习设计模式，用更加简单方便的设计和体系结构。\n请阐述你对开闭原则的理解，以及如何设计能达到开闭原则的要求？ 理解：软件实体（模块、类、方法）应对扩展开放，对修改关闭，可以让软件系统复用，并易于维护。 设计方法： ①对软件系统中不变的部分加以抽象成不变的接口，以应对未来的扩展。 ②接口最小功能设计原则：原有的接口要么可以应对未来的扩展，不足的部分可以通过定义新的接口来实现。 ③模块之间的调用通过抽象接口进行，这样即使实现层发生变化，也无需修改调用方的代码。 综上，软件系统是否具有良好的接口（抽象）设计是判断软件系统是否满足开闭原则的一种重要的判断基准。\n请举例说明在应用标准外观模式时可能产生的问题，以及对应的解决方案。 存在的问题是：可能通过继承一个外观类在子系统中加入了新的行为。\n银行信用卡中心的电子账单系统包括了发送器、账单、广告信和发送队列等对象，其中广告信的业务逻辑是：先到数据库中把客户信息一个一个的取出，每个客户都生成一份个性化的邮件，然后交给发送机进行发送处理。请问使用哪种模式设计广告信较好？如何设计？ 每个客户都要发送一个个性化邮件，所以使用原型模式\n开发一个用于数值计算的大型程序库，他的功能是强大的，但需要使用者具备较高的数学专业知识。为方便菜鸟级用户的使用，需要提供一个简化版的，但同时又不希望影响专业人员的使用。使用那种设计模式较好？如何设计？ 外观模式\n在2D游戏的开发中，需要绘制地图，地图由大量的“一样的图块”拼接而成，而“图块”的种类有限，目前有草地、海洋、沙漠、山地等，未来肯定要增加种类，但不会太多太频繁。采用何种模式设计“图块”类比较好？如何设计？ 人物构成要素复杂，应该用建造者模式，地图块只有有限的几种，一整个地图上大面积重复，应该用享元\n其他 # 当一个系统要由多个产品系列中的一个来配置时，我们选择抽象工厂模式\n当创建复杂对象的算法应该独立于该对象的组成部分以及他们的装配方式时，我们选择建造者模式\n当一个类希望由它的子类来指定它所创建的对象的时候，我们选择工厂模式\n当一个系统应该独立于它的产品创建、构成和表示时，要使用抽象工厂模式\n当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时，要使用单例模式\n当你想使用一个已经存在的类，而他的接口不符合你的需求时，要使用适配器模式\n当你想表示对象的部分-整体层次结构，要使用组合模式\n当不能采用生成子类的方法进行扩充时，要使用装饰模式\n当你要为一个复杂子系统提供一个简单接口时，要使用外观模式\n一个应用程序使用了大量的对象，要使用享元模式\n在需要用比较通用和复杂的对象指针代替简单的指针的时候，使用代理模式\n你想在不明确指定接收者的情况下，向对各对象中的一个提交一个请求时，要使用职责链模式\n访问一个聚合对象的内容而无需暴露它的内部表示，要使用迭代器模式\n一组对象以定义良好但是复杂的方式进行通信，产生的相互依赖关系结构混乱且难以理解，要使用中介者模式\n当对一个对象的改变需要同时改变其他对象，而不知道具体有多少对象有待改变，要使用观察者模式\n一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变它的行为，要使用状态模式\n","date":"2025 年 2 月 14 日","externalUrl":null,"permalink":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%BA%94%E8%AF%95%E7%AC%94%E8%AE%B0/","section":"","summary":"","title":"设计模式 - 应试笔记","type":"posts"},{"content":"","date":"2025 年 2 月 14 日","externalUrl":null,"permalink":"/categories/%E5%BA%94%E8%AF%95%E7%AC%94%E8%AE%B0/","section":"","summary":"","title":"应试笔记","type":"categories"},{"content":"","date":"2025 年 2 月 14 日","externalUrl":null,"permalink":"/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/","section":"","summary":"","title":"机器学习","type":"tags"},{"content":" 本博客为吉林大学机器学习本科课程复习笔记。 课程内容主要来自于斯坦福 cs229。\n在应试之外，此博客对机器学习入门也能提供一定的参考。\n部分内容直接来自 PPT 讲义截图，可能对阅读产生不便，请谅解。\n本博客分为三部分，请自行在目录跳转。\n知识点内容总结 考试复习重点 考试数学推导重点（手写） 第01章-绪论 # 推理期-\u0026gt;知识期-\u0026gt;学习期\n符号主义学习:\n✓决策树：以信息论为基础，最小化信息熵\n✓基于逻辑的学习：用逻辑进行知识表示，通过修改扩充逻辑表达式对数据进行归纳\n连接主义学习:\n✓神经网络和深度学习\n统计学习:\n✓支持向量机及核方法\n✓2006年卡耐基梅隆大学成立第一个“机器学习系”系主任\u0026ndash;机器学习奠基人之一T. Mitchell教授\n新的方向：集成学习 强化学习 迁移学习 深度学习\n第02章-线性回归 # 假设函数 / 拟合函数： # 重点看其中的参数定义\n代价函数 # 绝对误差，平方和误差\n线性回归示例 # 注意上图最后一个公式挺重要的\n特征规范化 # （维度特征 - 均值）/ 标准差\nx1 = (x1 - mean(x1)) / std(x1)\n用来将尺度缩放到 -1 到 1 之间\n需要注意的是，特征缩放并不是一件很严格的事，他只是为了优化梯度下降效率的一个技巧，换句话说，没有明确的标准来规定每个向量的数据尺度应该是多少，从经验上来讲，[-1, 1]的尺度可以接受1/3到30左右的尺度偏差\n目标函数（最小二乘法） # 注意对比目标函数和代价函数，基本上目标函数就是多了个min\n一般而言，1/2应该为1/2m，使得函数值和数据量有关。\n这里的 2m 可以看做是方便后续计算而多写了一个 2 ，因为损失函数总会对某个变量求导，而恰好可以与平方项的求导结果抵消\n最小二乘法的正规方程 # 正规方程是直接用梯度和目标函数反推参数的方法，和梯度下降并列。直接计算出每个参数，精准且无需超参数但计算量大。\n梯度下降法 # 关键因子计算： # 即线性回归下的梯度下降可以简化公式\n即参数 θi 的梯度 = 误差值 * xi\nBGD vs SGD # 解决的是协调多样本梯度下降，其中 SGD 更常用\n学习率 # 正规方程 vs 梯度下降 # 局部加权线性回归 # 每项中添加 w 作为系数，一般用高斯核：\n欠拟合、过拟合、正则化 # 样本离群点：指显著偏离总体分布的异常数据点，可能影响统计分析结果。\n欠拟合（Underfitting）\n欠拟合发生在模型对训练数据的学习不足，无法很好地捕捉训练数据的规律，也无法在训练集和测试集上表现出良好的性能。 这通常是因为模型的复杂度太低，无法表示训练数据中的模式。 过拟合（Overfitting）\n过拟合发生在模型对训练数据学习得过多，甚至学习到了训练数据中的噪声和细节，从而失去了对新数据的泛化能力。 过拟合的模型在训练集上的表现非常好，但在测试集上的表现较差。 正则化（Regularization）\n定义\n正则化是一种用于防止过拟合的技术，通过在损失函数中加入额外的约束项（正则化项），限制模型的复杂度，从而提高模型的泛化能力。 原理\n在模型的损失函数中加入正则化项，通过对模型参数施加惩罚，限制参数的大小或稀疏性，使模型避免过度拟合训练数据。\nL1正则化（Lasso Regularization）\n在损失函数中加入参数的 L1 范数（即参数的绝对值之和）。\n优点：会使一些参数变为 0，从而实现特征选择，得到稀疏模型。\nL2正则化（Ridge Regularization）\n在损失函数中加入参数的 L2 范数（即参数的平方和）。\n优点：不会使参数变为 0，但能有效减小参数的值，防止过拟合。\n正则化项：（下图L1 L2 反了2）\nElastic Net 正则化\nL1 和 L2 正则化的结合，综合两者的优点。 第03章-逻辑回归 # 激活函数 # 单位阶跃函数\nsigmoid 逻辑回归的概率假设 # 对数几率变换 # Odds = 事件发生的概率 / 事件不发生的概率\nOdds = P(A) / [1 - P(A)]\n似然函数 # 注意 PPT 上的形式中 i 在右上角，并加括号。\n梯度法 最大似然函数 # 线性回归梯度法的关键因子为：\n形式上和逻辑回归的梯度上升维持相似：\n其假设函数对比如下：\n牛顿法 极大似然函数 # 牛顿法和梯度法对比 # 模型评估方法 # 训练集 (training): • 用于学习的数据集合 • 通常50 - 80 %的数据 验证集(validation):（平时很少使用到） • 用于设置和调整超参数的数据集合 • 通常10 - 20 %的数据 测试集(test): • 一组用于评估完整训练模型性能的数据 • 在评估测试集性能之后，不能进一步调优模型 • 通常10 - 30 %的数据 样本集的划分\n1. 留出法\n留出法是对数据集进行一次性划分，将数据分为训练集和测试集，用于评估模型性能。\n关键点：\n分层采样：在划分数据集时，按类别比例（或其他特征）进行分层采样，确保训练集和测试集的分布与原始数据一致。\n数据划分比例\n通常将数据的 2/3 到 4/5 用于训练，剩余部分用于测试（验证）。 测试集的样本数量建议大于 30，以保证评估结果的可靠性。\n优点\n简单直接，计算开销小。 缺点\n测试集划分的结果可能会受到数据分割方式的影响，存在一定随机性。 训练数据量较少时，模型可能无法充分学习。\n2. 交叉验证法\n交叉验证法是一种更稳定和常用的模型验证方法，通过多次划分和训练来全面评估模型性能。\n关键点：\nK 折交叉验证\n将数据集分为 K 个互斥的子集，每次将其中 1 个子集作为验证集，其余 K-1 个子集作为训练集。 这个过程重复 K 次，确保每个子集都被用作验证集一次。\n通常取 K=10（10 折交叉验证），以获得较好的性能评估。 分层采样\n和留出法类似，分层采样确保每个子集中的数据分布与原始数据一致。 K=样本数（留一法 Leave-One-Out）\n当 K 等于数据集样本数时，每次只用 1 个样本作为验证集，其余样本作为训练集，这种方法称为 留一法。 留一法适合小规模数据集，但计算开销较大。\n优点：\n各次评估结果的平均值可以更准确地反映模型性能。 更稳定，评估结果不依赖单次数据划分。 缺点：\n计算开销较大，尤其是数据集较大时。 第06章-支持向量机 # SVM 概念 # 三种分类：\n核函数、核技巧、核方法：\nSVM 如何克服过拟合 # 关于下面三种 SVM 部分，建议参考：看了这篇文章你还不懂SVM你就来打我 | TangShusen 线性可分 SVM — 硬间隔最大化 # 线性 SVM — 软间隔最大化 # 非线性SVM — 核技巧 # 回归问题 SVR # 在Support Vector Regression(SVR)中，同样也是计算间隔，不同的是使靠超平面最远的样本点之间的间隔最小。\n仅仅是约束有所不同\n第07章-聚类 # 聚类（Clustering）是最常见的无监督学习算法，它指的是按照某个特定标准（如距离）把一个数据集分割成不同的类或簇，使得同一个簇内的数据对象的相似性尽可能大，同时不在同一个簇中的数据对象的差异性也尽可能地大。\n主要类型 # ◼ 划分聚类（K-means、K-medoids等）\n◼ 层次聚类（凝聚法、分裂法）\n◼ 密度聚类（DBScan、基于密度峰值算法）\n◼ 网格法（STING、CLIQUE）\n◼ 模型法（概率模型：高斯混合模型Gaussian Mixture Models ；神经网络模型:SOM；吸引子传播算法： AP聚类）\n◼ 谱聚类\n划分聚类 # K-means：通过最小化簇内点到簇中心的平方误差，将数据划分为 k 个簇。 K-medoids：簇中心是数据点本身，通过最小化绝对距离实现聚类。 层次聚类 # 凝聚法：从每个点作为一个簇开始，逐步合并最相似的簇。 分裂法：从所有点作为一个簇开始，逐步将簇分裂成更小的簇。 密度聚类 # DBSCAN：通过核心点的密度连接形成簇，能够发现任意形状的簇。 基于密度峰值算法：通过识别局部密度的峰值作为簇中心实现聚类。 网格法 # STING：将数据划分为网格，并基于网格的统计信息进行聚类。 CLIQUE：结合网格划分和密度聚类，能够发现高维空间中的稀疏簇。 模型法 # 高斯混合模型（GMM）：假设数据由多个高斯分布组成，用概率计算点的簇隶属关系。 SOM：通过神经网络将高维数据映射到低维空间，同时保留数据的拓扑关系。 吸引子传播（AP聚类）：基于数据点间的相似性，通过消息传递选择簇中心。 基于网格的聚类 # 将数据空间划分成有限个单元的网格结构，所有的处理都是以单个的单元为对象 K-means算法 # K-means 算法的流程 # 随机选择 K 个簇中心点（可以选已有的数据作为中心点，也可直接选高维空间中的位置）\n样本被分配到离其最近的中心点\nK个簇中心点根据所在簇样本，以求平均值的方式重新计算\n开始迭代，重复第2步和第3步直到所有样本的分配不再改变\n损失函数 # K 的选择 # K-means算法 K 的选择(肘部法（elbow method）) • 目标：找到最合适的点——拐点 • 找到一个聚类数目，使得 K 高于该值之后的**损失（即上面的损失函数）**的变换会发生显著递减；也就是该点后的 loss 变换开始不明显。 • 这个 K 值，称为肘部点（elbow point），因为它看起来像一个人的肘部。\n优缺点 # 第08章-降维 # 维数灾难(Curse of Dimensionality)：通常是指在涉及到向量的计算的问题中，随着维数的增加，计算量呈指数倍增长的一种现象。\n在很多机器学习问题中，每条数据经常具有很高的特征维度。如果直接使用原始的数据，不仅会让训练非常缓慢，还会影响模型的泛化性能。\n降维(Dimensionality Reduction)是将训练数据中的样本(实例)从高维空间转换到低维空间。该过程与信息论中有损压缩概念相似，完全无损的降维是不存在。\n降维方法又分为线性降维和非线性降维，非线性降维又 分为基于核函数和基于流形等方法。\nPCA # 通过平移、旋转坐标轴完成对数据原始特征空间的重构\nPCA算法对于重构和降维的要求：\n重构的不同维度之间线性无关(正交、协方差为0)； 降维后所得维度的值尽可能分散(最大方差)； 考试复习重点 # PCA计算（必考） 条件：X矩阵 -\u0026gt; 减去 μ -\u0026gt; 其中可以是 m 或 m - 1 有 C = 1 / m * (X @ X.T)求协方差矩阵 协方差矩阵 -\u0026gt; 求特征值或特征向量（一般很难求，除非设计好数据） 特征向量转置则为 P，有P @ C @ P.T = λ 主对角线矩阵 降维 Y = Pi @ X ，贡献度为 λi 在 Σλ 的比值 SVM 给三个点求超平面 一定是三个点，因为三个点以上需要用SMO迭代 直接给对偶式子以及其st 带入即可求 a1 a2 a3 由 w = Σayx 得 w，带入任何一点即可求得 b 用正规方程求解线性回归 linalg.inv(X.T @ X) @ X.T @ Y 其中难点在求逆矩阵，增广矩阵法（会考吗？） 证明题： # 最小二乘法的关键因子推导（最简单）+ 带入梯度下降公式\n最小二乘法的正规方程推导\n线性回归最小二乘法的概率解释\n逻辑回归极大似然估计公式推导 -\u0026gt; 与线性回归的形式一致性\n线性可分 SVM\n从距离推导到目标 拉格朗日乘子法 求解 max (min L) SMO （非重点） 软间隔SVM 、非线性SVM 、SVR 推导可能性较小\nBP算法 （非重点）\n论述题： # 大概率一道回归、一道分类\n回归可能的点：\n房价预测实例 维度灾难时使用降维 最小二乘法为什么自然 非线性回归问题 -\u0026gt; 神经网络、SVR、线性回归核函数 分出训练集 测试集 验证集 正则化与过拟合 分类可能的点：\n区分有监督分类和无监督聚类\nSVM的使用方法、逻辑回归的使用方法（梯度与牛顿）\nSVM相比逻辑回归的好处\n神经网络的分类任务？\n二分类效果评估方法 F1 等\n简答题、选择题： # 监督学习 vs 无监督学习\n符号主义、连接主义、统计\n线性回归与逻辑回归中的 X 矩阵实际上是增广矩阵，用于适配 wx + b 中的 b\n损失函数 = 代价函数 ；加上 min，max 为目标函数\n特征规范化：x1=(x1-mean(x1))/std(x1)\n梯度下降与梯度上升（爬山）\n学习率的选择问题，过大会怎么样，过小会怎么样\nBGD vs SGD vs mini-batch\n全局极小值 vs 局部最小值\n线性回归 梯度下降 vs 正规方程\n过拟合与欠拟合 + 正则化\n什么是分类问题（硬分类与软分类），什么是回归问题\n单位阶跃函数 vs. Sigmoid function\nSigmoid 好在哪？，其参数怎么控制形状 Odds(几率、几率比)、似然函数\n牛顿法 vs 梯度法 牛顿法定义\n训练集 测试集 验证集\n交叉验证、K=10、留一法 自助法，可重复采样 准确率 精确率 召回率 F1score AUC\n核函数 核技巧 核方法\n结构风险最小化\nSVM 硬分类、软分类的 Margin 定义（松弛因子）\n非线性 SVM 的 𝐾(𝑥, 𝑦) = φ(𝑥) ⋅ φ(𝑦) 与 φ(x) : 𝑋 → 𝑅𝑚 (𝑚 ≫ 𝑛)\n高斯核参数以及惩罚参数对于分类情况的影响\nKKT 强对偶\nSVR 定义，目标函数\n聚类问题定义\n划分聚类：K-mean算法具体步骤与公式\n肘部法选择 K 优点缺点，对初值敏感 改进算法 层次聚类 密度聚类 网格法 模型法 谱聚类的定义\n什么是降维，什么是维度灾难，为什么降维\n完全无损的降维是不存在\nPCA的思想（计算考了，这里不考）\nPCA要求：正交（协方差为零）和最大方差\nPCA的优缺点\n神经网络 与 RBF神经网络\n感知器定义 感知器的表征能力\n多层前馈网络 正向传播 + 反向传播\n考试数学推导重点（手写） # ","date":"2025 年 2 月 14 日","externalUrl":null,"permalink":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%BA%94%E8%AF%95%E7%AC%94%E8%AE%B0/","section":"","summary":"","title":"机器学习 - 应试笔记","type":"posts"},{"content":"","date":"2025 年 2 月 14 日","externalUrl":null,"permalink":"/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","section":"","summary":"","title":"操作系统","type":"tags"},{"content":" 本博客为 吉林大学软件学院 操作系统课程 复习笔记。 本文内容基本只包括 简答题 的复习。\n名词解释题，网上已经有很多学长学姐的笔记，推荐 gonghr 学长。\n如果想 系统学习操作系统，本文也能起到一定的梳理作用。\n考试范围来自 2022级\n考试范围 # 第一章 绪论 # 操作系统（名词解释）：操作系统是位于硬件层(HAL)之上，所有其它软件层之下的一个系统软件，是管理系统中各种软硬件资源，方便用户使用计算机系统的程序集合。\n类别与发展（考过至少写出六种类别）\n第二章 进程管理 # 多道程序设计 # 吞吐量 = 作业道数 / 全部处理时间\n利用率 = CPU使用时间 / 运行总时间\nCPU利用率越高，说明系统效率越高对不对？\n不对，比如程序中出现死循环使得 CPU 利用率解决百分之百，无法处理其他请求，系统效率极低。\n单道程序设计资源利用率低\nMultiprogramming（多道程序设计）：多道程序设计是指在一台处理机上同时并发运行多个程序，即在一台处理机上有多个程序同时进入主存并发运行，宏观上并行，微观上串行交替运行。\n思考：内存中的程序数量是否越多越好\n道数过少，系统资源利用率低\n道数过多，系统开销(system overhead)增大，程序响应速度下降\n进程 # 1.重中之重\n4. 操作系统为什么提出“作业、进程、线程”的概念？\nPPT小结：\n作业与进程\n作业进入内存后变为进程\n一个作业通常与多个进程相对应\n进程与线程\n一个进程一般包含多个线程，至少包含一个线程\n不支持多线程的系统，可视为单线程进程\n**作业：**用户在一次解题或一个事物处理过程中要求计算机系统所做工作的集合。它包括用户程序、所需要的数据及控制指令等。作业是由一系列有序的步骤组成的。\n进程：\n进程是程序的一次执行\n进程是可以参与并发执行的程序\n进程是程序和数据一道通过处理器执行时所发生的活动\n进程是具有一定独立功能的程序关于一个数据集合的一次运行活动\n程序和进程\n程序静态，进程动态。这是进程和程序的本质差异\n程序可长期保存，进程有生存期\n一个程序可对应多个进程，一个进程只能执行一个程序\n并发：可与其它进程同时执行\n宏观同时，“交替执行”，不要求多个CPU\n**线程：**线程是进程中的一个实体，是被系统独立调度和执行的基本单位。\n作业是在早期的多道批处理系统中提出的，在现代操作系统中基本没有概念及应用。\n引入进程的目的是更好地使多道程序并发执行，提高资源利用率和系统吞吐量\n引入线程地目的使减小程序在并发执行时所付出地时空开销（上下文切换），提高操作系统地并发性能。\n进程状态转化\n进程创建时是什么状态\n就绪态\n当进程已分配到除处理器(CPU)以外的所有必要资源后，只要再获得处理器就可以执行的状态称为就绪状态。在一个系统里,可以有多个进程同时处于就绪状态，通常把这些就绪进程排成一个或多个队列，称为就绪队列。\n进程结束时是什么状态\n终止态\n当一个进程已经正常结束或异常结束，操作系统已将其从系统队列中移出，但是，尚未撤消，这时称为终止状态。\n下图为考试原题\n进程控制块PCB 标志进程存在的数据结构，其中保存系统管理进程所需的全部信息：pid、进程状态、现场信息、调度参数、所属用户(uid)……\n当调度某进程执行时，需要从该进程的PCB中查询其状态及优先级等参数\n当调度到某进程后，根据PCB中的现场信息恢复现场，并根据PCB中的程序和数据的内存地址找到程序和数据\n进程执行过程中，当需要与其它进程通信时，也要访问PCB\n当进程发生进程切换时，需要将现场信息从系统栈弹出，保存于PCB中\n系统建立进程时建立PCB，撤销进程时撤销PCB.\n进程上下文：PCB + 程序\n系统开销：运行操作系统程序完成系统管理工作所花费的时间和空间\nUNIX中分为 P区（proc）和U区（user）\nP区有Pid Uid 进程状态等 需要常驻内存\nU区是有进程被使用的时候才用的 不需要常驻\n进程切换时需要保存的现场信息\n16. 进程的现场信息包括什么，可能存放的位置\na 地址寄存器\n​\t保存当前CPU所访问的内存单元的地址\nb 通用寄存器\n​\t用于传送和暂存数据，也可参与算术逻辑运算，并保存运算结果\nc 浮点寄存器\n​\t用于存储浮点数字，它决定着计算机的计算精度。\nd. SP(系统栈指针)\ne. PSW(程序状态字)\nf. PC(指令计数器)\ng. 打开文件表\n存放位置：进程栈（不是系统栈）\n进程的特征\n§并发性 §动态性 §独立性 §交互性 §异步性 §结构性\n进程的创建与撤销\n进程创建 §向系统申请一个空闲PCB，并指定唯一的进程标识\n§为新进程分配资源\n§初始化新进程的PCB\n§加载程序\n§将PCB入就绪队列.\n考试原题！！考了两次\n引起进程创建的事件\n用户登录 作业调度 提供服务 应用请求\n进程撤销 exit()\n从系统PCB表中找到被撤销进程的PCB\n检查被撤销进程的状态是否为执行状态。若是，则立即停止该进程的执行\n设置重新调度标志，以便在该进程撤销后将处理器分配给其它进程\n检查被撤销进程是否有子孙进程，若有子孙进程还应撤销该进程的子孙进程\n回收该进程占有的全部资源并回收其PCB\n进程等待\n停止当前进程的执行，由于该进程正处于执行状态，故应停止该进程的执行\n保存该进程的现场信息。为了使进程以后能够重新调度运行，应将进程的现场信息送入其PCB中保存\n将进程状态改为等待.\n进程唤醒(事件发生)\n将被唤醒进程从相应的等待队列中移除\n将进程状态改为就绪，并将该进程插入就绪队列.\n思考：父进程创建子进程与主程序调用子程序区别?\n父进程创建子进程后，父进程与子进程可同时执行\n主程序调用子程序后，主程序暂停在调用点，子程序开始执行，直到子程序执行完毕返回，主程序才开始执行\n​\t思考\n​\t若系统中没有运行进程，是否一定没有就绪进程？\n​\ta：不一定比如死锁\n​\t若系统中即没有运行进程，也没有就绪进程，系统中是否就没有进程？\n​\ta：可能有等待状态的进程\n​\t在采用优先级进行调度时，运行进程是否一定是系统中优先级最高的进程？\n​\ta：就绪队列中的最高优先级进程\n​\t某进程被唤醒后立即投入运行，就说这个系统采用的是剥夺式调度方法？\n​\ta：不是，若当前CPU空闲，则非剥夺\n线程 # **线程是进程中一个相对独立的执行流。**一个进程可以包含多个线程，这些线程执行同一程序中的相同代码段或不同代码段，共享数据区和堆。一般认为，进程是资源的分配单位，线程是CPU的调度单位。\n多线程优点：\n§切换速度快（地址空间不变，避免了上下文切换（PCB+程序））\n§系统开销小\n§通讯容易（共享数据空间）\n线程控制块TCB(Thread control block)\n标志线程存在的数据结构，其中包含对线程管理需要的全部信息\n内容：线程标志 线程状态 调度参数 现场(通用寄存器,PC,SP) 链接指针\n存放位置：\n用户级线程：目态空间（用户空间）\n核心级线程：系统空间\n！考试原题：用户级线程与系统级的线程的区别（优缺点）\n用户级线程：\n§若同一进程中的多个线程至少有一个处于运行态，则该进程的状态为运行态\n§若同一进程中的多个线程均不处于运行态，但至少有一个线程处于就绪态，则该进程的状态为就绪态\n§若同一进程中的多个线程均处于等待态，则该进程的状态为等待态\n优点\n不依赖于操作系统，调度灵活\n同一进程中多线程切换速度快(不需进入操作系统)\n调度算法可以是进程专用的，不同的进程可以根据需要，对自己的线程选择不同的调度算法。\n用户级线程的实现于操作系统平台无关，对线程管理的代码是属于用户程序的一部分。\n缺点\n当线程执行一个系统调用时，不仅该线程被阻塞，而且进程内的所有线程都被阻塞。 不能发挥多处理机的优势，内核每次分配给进程仅有一个 CPU，因此进程中仅有一个线程能执行。 内核级线程\n优点 能充分发挥多处理机优势，内核能同时调度同一进程中多个线程并行执行。 如果进程中一个线程被阻塞，内核可以调度该进程中的其他线程占用处理机，也可以运行其他进程中的线程。 非新版本：内核支持线程具有很小的数据结构和堆栈，线程切换比较快、开销小。 非新版本：内核本身也可以采用多线程技术，可以提高系统的执行速度和效率。 缺点 同一进程中的线程切换，需要从用户态到核心态进行，系统开销大。 非新版本：线程的创建、撤销、调度在操作系统核心态，占用系统资源，增加系统开销。 具体区别\n核心级别线程操作系统可见；用户级别线程操作系统不可见\n用户级别线程的创建、撤销和调度不需要操作系统的支持，且是在（程序）语言这一级处理的。核心级别线程的创建、撤销和调度都需要操作系统内核的支持\n用户级别线程执行系统调用命令将导致其所属进程被中断，核心级别线程执行系统调用命令将导致线程被中断\n在仅有用户线程的系统内，CPU调度以进程为单位。在有核心级别线程的系统内，CPU调度以线程为单位\n用户级别线程的实体是运行在用户态下的程序，而核心级别线程的实体则是可以运行在任何状态下的程序\n第三章 中断和调度 # 中断 # 定义：处理器在运行过程中，出现了某一事件，必须中止正在运行的程序，转去处理这个事件，然后再返回原来运行的程序\n引入中断的目的\n实现并发活动\n实现实时处理\n故障自动处理\n中断类型： 自愿性主要的是系统调用、访管指令\n强迫性是硬件故障、程序性中断、外部中断、IO中断\n中断嵌套与中断屏蔽 计组学的\n中断屏蔽（关中断）-\u0026gt; 保护现场-\u0026gt;开中断（开放高优先级）-\u0026gt;中断处理-\u0026gt;关中断-\u0026gt;恢复现场（用PCB）-\u0026gt;开中断-\u0026gt;中断返回\n中断相当于一种特殊的子程序调用，发生时刻具有不确定性\n§思考1：中断现场保存在什么地方？进程现场保存在什么地方？\n中断现场主要保护PC PSW（中断向量），一般在系统栈中保存。\n进程以PCB进程控制块的形式保存在所有进程共享的内核空间中。\n§思考2：为什么说PCB保存的是核心级别现场？用户级别现场保存在什么地方？\nPCB保存在内核空间中，可以供操作系统内核以及其他进程访问。\n用户级现场保存在用户堆栈中，指的是线程级别的上下文信息，存储在目态空间。\n使用临界区的四个必要条件 ①空闲让进：临界区空闲时应该允许一个进程访问； ②忙则等待：临界区被访问时，其余想访问他的进程必须等待； ③有限等待：等待的进程在外等待的时间必须是有限的； ④让权等待：若等待进程一直等待，迟迟进不到临界区时，应该让出cpu，防止忙等待。 第五章 死锁 # 死锁：一组进程中的每一个进程，均无限期地等待此组进程中其它进程所占有的，因而永远无法得到的资源，这种现象称为进程死锁\n类型：竞争资源引起的死锁（可以竞争相同或不同的资源）、进程通讯引起的死锁、其他\n饥饿(starvation)\n当等待时间给进程推进和响应带来明显影响时,称发生了进程饥饿\n饥饿到一定程度的进程所赋予的使命即使完成也不再具有实际意义时称该进程被饿死\n§饥饿 vs 死锁\n§死锁进程处于等待状态，忙式等待的进程并非处于等待状态, 但却可能被饿死\n§死锁进程等待永远不会释放的资源, 饿死进程等待可能被释放,但却不会分给自己的资源,其等待时间没有上界\n§死锁一定发生了循环等待,饿死不然\n§死锁至少涉及两个进程, 饿死进程可能只有一个\n第六章 主存 # 动态异长分区的分配\n空闲区域表\n最先适应 (First Fit)\n​\t从低地址到高地址\n次适应法(Next Fit)\n​\t从低地址到高地址，从上次的地址开始继续找\n最佳适应 (Best Fit)\n​\t从小到大排序，会出碎片\n最坏适应 (Worst Fit)\n​\t从大到小排序，大进程无处可用\n碎片\n动态异常分区存储分配可能形成很小的空闲区域，称为碎片(fragment)\n如果碎片很多，将造成严重的存储资源浪费\n解决方法-紧凑(compaction)\n移动所有的占有区域，以使所有的空闲区域连成一片。缺点：开销大\n内存管理方式\n§界地址管理方式（一维地址）\n§页式管理方式（一维地址）\n§段式管理方式（二维地址）\n§段页式管理方式（二维地址）\n页式管理方式：具体和计组一样 多加了快表、页表\n页表对应 逻辑页号-\u0026gt;页框号 （存在多级页表）\n传统页表面向进程空间\n每个进程逻辑页面有一表项\n当进程空间很大时，页表很大\n反置页表面向内存空间\n对每个内存页框设置一个表项，表项的序号为物理页框号f，表项的内容为进程标识pid与逻辑页号p的有序对\n反置页表大小固定\n整个系统一个反置页表，为所有进程所共用\n快表相同，是更快的页表，但空间小\n段的共享（标记当前多少进程正在使用，归零后才能写入）\n段的保护-\u0026gt;\n对于保存共享代码的段，任何进程都不能修改它\n对于具有保密要求的段，某些进程不能读取它\n对于属于系统数据的段，某些进程不能修改等\n考试原题\n分段和分页的区别和优缺点\n页的大小是固定的，由操作系统决定，而段的大小不固定，取决于我们当前运行的程序。\n分页仅仅是为了满足操作系统内存管理的需求，而段是逻辑信息的单位，它含有一组其意义相对完整的信息，在程序中可以体现为代码段，数据段，是为了满足用户的需要。\n段一般比页大，因而段表比页表短，可以缩短查找时间，提高访问速度。\n分页对用户是透明的，分段对用户是可见的　第八章 文件 # 物理结构（顺序、链接、索引、倒排、散列）\n文件块：逻辑块号 + 块内地址（和页面一个道理）\nfcb：类似pcb 存储首地址，长度等信息\n顺序：整块的内存，用长度判越界\n链接：fcb存储块数，用指针形成链表\n索引：多加一个索引表，fcb存储索引表号和数量\n学习通简答题 # 作业、进程、线程（what，why） # 见上述表达\n忙式等待与排队等待 # 忙等待：当某进程正在使用临界区，其他试图进入临界区的进程都必须在进入区内连续空循环，会持续调用CPU查询临界区状态。\n排队等待：当某进程正在使用临界区，其他试图进入临界区的进程按顺序加入排队队列，当该临界区进入空闲时，给队首信号，让其进入临界区。在等待过程中不需要持续占用CPU。\n区分进程间的互斥与同步 # 两者都属于进程的竞态，其都有多个进程竞争使用不能被同时使用的只有，使得其一定要出现时间上的先后处理。\n互斥指的是当一个进程进入临界区时，其他程序一定要等待，当其退出临界区后，另一个进程才能访问该临界资源，其临界资源的使用是互斥的，在宏观上是串行的。\n同步指的是进程间具有前后执行顺序要求的，具有某种合作关系。\n面包店思路 # 说明一下面包店算法的思想? 如何实现的互斥与公平性问题?\n将每个线程想象成面包店的顾客，其想获得临界资源的操作为进入面包店，面包店每次只能进入一个人即临界资源只能同时被一个线程使用。想获取临界资源的线程获取一个号码，该号码逐次加一。但是当多个线程同时取号时，number修改前都进行了max，则他们会取到相同的number，但在执行时按照字典序进行。按照签到号码从小到大获取临界资源，完成后号码归零。\nA[i]=true; number[i]=max{number[0],…,number[n-1]}+1; A[i]=false; For (j=0; j\u0026lt; n; j++) { // 遍历 n 个进程 While (A[j]); // 当有线程 j 正在获取号码，阻塞 While ((number[j]!=0) \u0026amp;\u0026amp; (number[j],j)\u0026lt;(number[i],i)); // 如果找到线程 j 比 i 小，则等待 j 线程结束 } i 进入临界区…… // 清空 i 的号码 number[i] = 0; 其中 i 是某个当前有想要进入临界区的线程，j 是遍历全部线程找有没有比 i 号码靠前的线程。\n书中表达是 (a,b) \u0026lt; (c,d)\nA数组表示当前i是否正在取号，number数组表示取到的号码\n互斥性\n多个进程竞争进入临界区时, 抓到号且二元组(number[i],i)最小的进程获准进入临界区, 其它进程将在第一个while循环（ j正在抓号 ）或第二个while循环处（ 有比 i 更优先的 j）等待, 因而满足互斥性。\n公平性\n其本质上还是先进先出，一般情况下先申请的先获得号码，号码小的先执行。\n进展性\n只有一个线程申请进入临界区时，会直接执行。多个同时申请时，会有（number[i]，i）二元组最小的执行。\n优先等待性\n不会饿死\n活动进程 # 管程机制中的\u0026quot;活动进程“指的是什么进程?为什么在管程中只能有一个活动进程?\n活动进程：指的是处于就绪态或者是运行态的进程。 管程每次只允许一个进程进入，从而实现了进程的互斥，避免死锁\n","date":"2025 年 2 月 14 日","externalUrl":null,"permalink":"/posts/os-note/","section":"","summary":"","title":"操作系统 - 应试笔记","type":"posts"},{"content":" 本博客内容来源于我在某企业担任算法助教期间的教学材料，将课堂使用的 PPT 转换为 PDF 后整理而成。 博客前面内容为讲义内容大纲\n如果想仔细了解建议直接看最后的讲义原稿\n动态规划基础 # 动态规划（Dynamic Programming, DP）是一种优化决策过程的算法思想，常用于最优子结构和重叠子问题的场景。 主要包括： 状态定义 状态转移方程 初始状态 最终结果计算 经典 DP 问题分类 # 线性 DP # 最长递增子序列（LIS） 斐波那契数列 打家劫舍 最小花费爬楼梯 网格 DP # 最小路径和 不同路径 最大正方形 背包问题 # 0/1 背包 完全背包 多重背包 状态机 DP # 股票买卖问题 最长公共子序列（LCS） 划分 DP # 戳气球 石子合并 区间 DP # 回文子串 合并石子 数位 DP # 统计特定数字的个数 数位拆分问题 状态压缩 DP # 旅行商问题（TSP） 集合覆盖问题 斐波那契数列引入 # 斐波那契数列： $$ F(n) = F(n - 1) + F(n - 2) $$\n递归解法（时间复杂度 O(2^n)） 记忆化搜索（时间复杂度 O(n)） 动态规划（自底向上）（时间复杂度 O(n)） 矩阵快速幂（时间复杂度 O(log n)） 记忆化搜索 vs 动态规划 # 方法 适用情况 优点 缺点 记忆化搜索 递归问题 代码直观 可能栈溢出 动态规划 需要优化时间复杂度 避免重复计算 代码不一定直观 DP进阶 - 树上 DP # 换根 DP 树形背包 树的直径 课后练习题 # 最小花费爬楼梯（斐波那契进阶）\nLeetCode 746\n打家劫舍（经典 DP）\nLeetCode 198\n俄罗斯套娃信封问题（二维 LIS）\nLeetCode 354\n最长公共子序列（LCS）\nLeetCode 1143\n完整 PPT 预览 # 方式 1：腾讯文档在线预览 # 如果无法加载 PDF，请 点击这里打开腾讯文档。\n直接预览：\n方式 2：下载 PDF # 如果需要保存完整的 PDF 讲义，请点击下载： PDF 下载链接\n","date":"2025 年 2 月 13 日","externalUrl":null,"permalink":"/posts/%E4%BB%8E%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2%E5%88%B0%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","section":"","summary":"","title":"从记忆化搜索到动态规划","type":"posts"},{"content":" 本博客部分写自 2023 年，于 2025 年初重置。 由于本人经常忘记二分查找的要点，因此便对其进行了整理总结。\n部分参考了 yxc 和 0x3f 的教学内容。\n前言 # 二分查找在面试与竞赛中都十分常见。\n虽然算法难度不高。但不熟练的情况下会很容易出现边界错误而浪费时间。\n在复杂的综合题中，也可以会忘记使用二分查找，而导致超时。\n二分模板 # 二分最经典的情景，在单调数组中找目标值。\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e 原题链接：点击这里访问 # 第一个大于等于 target 的位置 # 等价于最常用的 lower_bound(a.begin(), a.end(), target) l = 0 r = n - 1 while l \u0026lt; r : mid = l + r \u0026gt;\u0026gt; 1 if nums[mid] \u0026lt; target: l = mid + 1 else: r = mid return l # 第一个大于 target 的位置 # 等价于 upper_bound(a.begin(), a.end(), target) l = 0 r = n - 1 while l \u0026lt; r : mid = l + r \u0026gt;\u0026gt; 1 if nums[mid] \u0026lt;= target: l = mid + 1 else: r = mid return l # 最后一个小于等于 target 的位置 # 等价于的 lower_bound(a.begin(), a.end(), target, greater\u0026lt;int\u0026gt;()) l = 0 r = n - 1 while l \u0026lt; r : mid = l + r + 1 \u0026gt;\u0026gt; 1 if nums[mid] \u0026lt; target: l = mid else: r = mid - 1 return l # 最后一个小于 target 的位置 # 等价于最常用的 upper_bound(a.begin(), a.end(), target, greater\u0026lt;int\u0026gt;()) l = 0 r = n - 1 while l \u0026lt; r : mid = l + r + 1 \u0026gt;\u0026gt; 1 if nums[mid] \u0026lt;= target: l = mid else: r = mid - 1 return l 二分的库函数 # 对于 C++ 而言：\n#include\u0026lt;bits/stdc++.h\u0026gt; #include\u0026lt;algorithm\u0026gt; // 具体头文件 vector\u0026lt;int\u0026gt; a = {1, 2, 3, 4, 4, 5, 6}; int target = 4; // 对 vector 二分，库返回的是迭代器 auto it1 = lower_bound(a.begin(), a.end(), target); auto it2 = upper_bound(a.begin(), a.end(), target); // 其实 greater 就是把数组反过来查找 auto it3 = lower_bound(a.begin(), a.end(), target, greater\u0026lt;int\u0026gt;()); auto it4 = upper_bound(a.begin(), a.end(), target, greater\u0026lt;int\u0026gt;()); int pos = it1 - a.begin(); 对于 python 而言：\nimport bisect a = [1, 2, 3, 4, 4, 5, 6] target = 4 # 分别对应 lower_bound 和 upper_bound pos1 = bisect.bisect_left(a, target) pos2 = bisect.bisect_right(a, target) # Python 没有原生的降序 bisect，只能自己写下面两个 二分答案 # 根据经验，当题目中出现求最小、求最大、最大化最小、最小化最大时，很有可能要对答案进行二分查找。\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e 灵茶山艾府总结：点击这里访问 在二分答案时候，要时刻注意：\nr 的初始值是什么？即答案的上界。（如果在比赛中，上界开大一些更稳妥）\ncheck() 条件对应的边界是哪种？\n一般而言，check(int x) 按正常的 bool 逻辑写。 即 x 满足条件为 true，不满足为 false。 而在 while 查找中，用 !check()，代替第一种二分的 if 条件。 问题有没有单调性，能不能用二分？\n如果没有单调性，一般是 DP 或 搜索。 绝大部分二分答案的上界都在 int 范围外\n因此千万别忘了 mid 开 long long\n求最小 - 修车的最少时间： # \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e 原题链接：点击这里访问 给你一个整数数组 ranks ，表示一些机械工的 能力值 。ranksi 是第 i 位机械工的能力值。能力值为 r的机械工可以在 r * n2 分钟内修好 n 辆车。\n同时给你一个整数 cars ，表示总共需要修理的汽车数目。\n请你返回修理所有汽车 最少 需要多少时间。\n**注意：**所有机械工可以同时修理汽车。\n示例 1：\n输入：ranks = [4,2,3,1], cars = 10 输出：16 解释： - 第一位机械工修 2 辆车，需要 4 * 2 * 2 = 16 分钟。 - 第二位机械工修 2 辆车，需要 2 * 2 * 2 = 8 分钟。 - 第三位机械工修 2 辆车，需要 3 * 2 * 2 = 12 分钟。 - 第四位机械工修 4 辆车，需要 1 * 4 * 4 = 16 分钟。 16 分钟是修理完所有车需要的最少时间。 示例 2：\n输入：ranks = [5,1,8], cars = 6 输出：16 解释： - 第一位机械工修 1 辆车，需要 5 * 1 * 1 = 5 分钟。 - 第二位机械工修 4 辆车，需要 1 * 4 * 4 = 16 分钟。 - 第三位机械工修 1 辆车，需要 8 * 1 * 1 = 8 分钟。 16 分钟时修理完所有车需要的最少时间。 提示：\n1 \u0026lt;= ranks.length \u0026lt;= 105 1 \u0026lt;= ranks[i] \u0026lt;= 100 1 \u0026lt;= cars \u0026lt;= 106 题解：\n# 经典二分答案 class Solution: def repairCars(self, ranks: List[int], cars: int) -\u0026gt; int: def check(x : int) -\u0026gt; bool: car_num = 0 for rank in ranks: car_num += int(sqrt(x / rank)) return car_num \u0026gt;= cars l, r = 0, int(1e15) while l \u0026lt; r: mid = l + r \u0026gt;\u0026gt; 1 if not check(mid): l = mid + 1 else: r = mid return l 最小化最大 - 袋子里最少数目的球： # \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e 原题链接：点击这里访问 给你一个整数数组 nums ，其中 nums[i] 表示第 i 个袋子里球的数目。同时给你一个整数maxOperations 。\n你可以进行如下操作至多 maxOperations 次：\n选择任意一个袋子，并将袋子里的球分到 2 个新的袋子中，每个袋子里都有正整数个球。 比方说，一个袋子里有 5 个球，你可以把它们分到两个新袋子里，分别有 1 个和 4 个球，或者分别有 2 个和 3 个球。 你的开销是单个袋子里球数目的 最大值 ，你想要 最小化 开销。\n请你返回进行上述操作后的最小开销。\n示例 1：\n输入：nums = [9], maxOperations = 2 输出：3 解释： - 将装有 9 个球的袋子分成装有 6 个和 3 个球的袋子。[9] -\u0026gt; [6,3] 。 - 将装有 6 个球的袋子分成装有 3 个和 3 个球的袋子。[6,3] -\u0026gt; [3,3,3] 。 装有最多球的袋子里装有 3 个球，所以开销为 3 并返回 3 。 示例 2：\n输入：nums = [2,4,8,2], maxOperations = 4 输出：2 解释： - 将装有 8 个球的袋子分成装有 4 个和 4 个球的袋子。[2,4,8,2] -\u0026gt; [2,4,4,4,2] 。 - 将装有 4 个球的袋子分成装有 2 个和 2 个球的袋子。[2,4,4,4,2] -\u0026gt; [2,2,2,4,4,2] 。 - 将装有 4 个球的袋子分成装有 2 个和 2 个球的袋子。[2,2,2,4,4,2] -\u0026gt; [2,2,2,2,2,4,2] 。 - 将装有 4 个球的袋子分成装有 2 个和 2 个球的袋子。[2,2,2,2,2,4,2] -\u0026gt; [2,2,2,2,2,2,2,2] 。 装有最多球的袋子里装有 2 个球，所以开销为 2 并返回 2 。 示例 3：\n输入：nums = [7,17], maxOperations = 2 输出：7 提示：\n1 \u0026lt;= nums.length \u0026lt;= 105 1 \u0026lt;= maxOperations, nums[i] \u0026lt;= 109 题解：\nclass Solution: def minimumSize(self, nums: List[int], maxOperations: int) -\u0026gt; int: def check(x : int) -\u0026gt; bool: if x == 0: return False operation = 0 for num in nums: if num \u0026gt; x: operation += (num + x - 1) // x - 1 # 向上取整后减一 return operation \u0026lt;= maxOperations l, r = 0, int(1e9) while l \u0026lt; r: mid = l + r \u0026gt;\u0026gt; 1 if not check(mid): l = mid + 1 else: r = mid return l 最大化最小 - 范围内整数的最大得分： # \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e 原题链接：点击这里访问 给你一个整数数组 start 和一个整数 d，代表 n 个区间 [start[i], start[i] + d]。\n你需要选择 n 个整数，其中第 i 个整数必须属于第 i 个区间。所选整数的 得分 定义为所选整数两两之间的最小 绝对差。\n返回所选整数的 最大可能得分 。\n示例 1：\n输入： start = [6,0,3], d = 2\n输出： 4\n解释：\n可以选择整数 8, 0 和 4 获得最大可能得分，得分为 min(|8 - 0|, |8 - 4|, |0 - 4|)，等于 4。\n示例 2：\n输入： start = [2,6,13,13], d = 5\n输出： 5\n解释：\n可以选择整数 2, 7, 13 和 18 获得最大可能得分，得分为 min(|2 - 7|, |2 - 13|, |2 - 18|, |7 - 13|, |7 - 18|, |13 - 18|)，等于 5。\n提示：\n2 \u0026lt;= start.length \u0026lt;= 105 0 \u0026lt;= start[i] \u0026lt;= 109 0 \u0026lt;= d \u0026lt;= 109 题解：\n// 24.9.8 注释： 对二分板子不熟悉 导致花了很长时间 class Solution { public: bool check(int mid, vector\u0026lt;int\u0026gt;\u0026amp; start, int d) { int n = start.size(); long long mn = start[0]; for (int i = 1; i \u0026lt; n; i++) { // 改了一个小时没改出来 max 这行 还得多学学 mn = max(1LL * start[i], mn + mid); if (mn \u0026lt;= start[i] + d) { continue; } return false; } return true; } int maxPossibleScore(vector\u0026lt;int\u0026gt;\u0026amp; start, int d) { int n = start.size(); sort(start.begin(), start.end()); // 上边界二分的写法不能忘啊 long long l = 0, r = long(2e9); while (l \u0026lt; r) { long long mid = l + r + 1 \u0026gt;\u0026gt; 1; if (!check(mid, start, d)) { r = mid - 1; } else { l = mid; } } return l; } }; 二分作为解题步骤之一 # 二分经常作为解题中的某一步，经常和其他算法结合考察。\n前缀和 - 青蛙过河 # 原题链接：点击这里访问 小青蛙住在一条河边，它想到河对岸的学校去学习。\n小青蛙打算经过河里的石头跳到对岸。\n河里的石头排成了一条直线，小青蛙每次跳跃必须落在一块石头或者岸上。\n不过，每块石头有一个高度，每次小青蛙从一块石头起跳，这块石头的高度就会下降 1，当石头的高度下降到 0 时小青蛙不能再跳到这块石头上（某次跳跃后使石头高度下降到 0 是允许的）。\n小青蛙一共需要去学校上 x 天课，所以它需要往返 2x 次。 当小青蛙具有一个跳跃能力 y 时，它能跳不超过 y 的距离。 请问小青蛙的跳跃能力至少是多少才能用这些石头上完 x 次课。\n输入格式\n输入的第一行包含两个整数 n, x，分别表示河的宽度和小青蛙需要去学校的天数。请注意 2x 才是实际过河的次数。\n第二行包含 n−1 个非负整数 H1, H2, ⋅⋅⋅, Hn−1，其中 Hi \u0026gt; 0 表示在河中与小青蛙的家相距 i 的地方有一块高度为 Hi 的石头，Hi = 0 表示这个位置没有石头。\n输出格式\n输出一行，包含一个整数，表示小青蛙需要的最低跳跃能力。\n数据范围\n对于所有评测用例，1 ≤ n ≤ 10⁵, 1 ≤ x ≤ 10⁹, 0 ≤ Hi ≤ 10⁴。\n输入样例\n5 1 1 0 1 0 输出样例\n4 样例解释\n由于只有两块高度为 1 的石头，所以往返只能各用一块。\n第 1 块石头和对岸的距离为 4，如果小青蛙的跳跃能力为 3 则无法满足要求。\n所以小青蛙最少需要 4 的跳跃能力。\n题解\n// 找规律 + 前缀和 + 二分查找 // 核心是先找到为了让青蛙能踩到对应的石头，满足 i 块到 i + step 块石头的和大于 2 * x 即可 // 多次求区间之和自然想到前缀和 // 多次求位置的 step 并且符合二段性 自然考虑二分查找 // 此题要实现的细节挺多的 要注意 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n, x; vector\u0026lt;int\u0026gt;stone; vector\u0026lt;long long\u0026gt;prefix; bool check(int step) { // 注意上界为 n - step for (int i = 0; i \u0026lt; n - step + 1; i++) { if (prefix[i + step] - prefix[i] \u0026lt; 2 * x) { return false; } } return true; } int main () { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; x; n--; stone.resize(n); for (int i = 0; i \u0026lt; n ;i++) { cin \u0026gt;\u0026gt; stone[i]; } prefix.resize(n + 1); prefix[0] = 0; for (int i = 1; i \u0026lt;= n; i++) { prefix[i] = prefix[i - 1] + stone[i - 1]; //\tcout \u0026lt;\u0026lt; prefix[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } int l = 0, r = n + 100; while(l \u0026lt; r) { int mid = l + r \u0026gt;\u0026gt; 1; //\tcout \u0026lt;\u0026lt; mid \u0026lt;\u0026lt; \u0026#34; \u0026#34;; if (!check(mid)) l = mid + 1; else r = mid; } cout \u0026lt;\u0026lt; l; return 0; } ","date":"2025 年 2 月 12 日","externalUrl":null,"permalink":"/posts/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%80%BB%E7%BB%93%E4%B8%8E%E4%BE%8B%E9%A2%98/","section":"","summary":"","title":"“二分查找” 总结与例题","type":"posts"},{"content":"","date":"2025 年 2 月 12 日","externalUrl":null,"permalink":"/tags/%E4%BA%8C%E5%88%86/","section":"","summary":"","title":"二分","type":"tags"},{"content":" \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e 原题链接：点击这里访问 猫和老鼠 题干 # 两位玩家分别扮演猫和老鼠，在一张无向图上进行游戏，两人轮流行动。\n图的形式是：graph[a] 是一个列表，由满足 ab 是图中的一条边的所有节点 b 组成。\n老鼠从节点 1 开始，第一个出发；猫从节点 2 开始，第二个出发。在节点 0 处有一个洞。\n在每个玩家的行动中，他们必须沿着图中与所在当前位置连通的一条边移动。例如，如果老鼠在节点 1 ，那么它必须移动到 graph[1] 中的任一节点。\n此外，猫无法移动到洞中（节点 0）。\n然后，游戏在出现以下三种情形之一时结束：\n如果猫和老鼠出现在同一个节点，猫获胜。 如果老鼠到达洞中，老鼠获胜。 = 如果某一位置重复出现（即，玩家的位置和移动顺序都与上一次行动相同），游戏平局。 给你一张图 graph ，并假设两位玩家都都以最佳状态参与游戏：\n如果老鼠获胜，则返回 1； 如果猫获胜，则返回 2； 如果平局，则返回 0 。 示例 1：\n输入：graph = [[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]] 输出：0 示例 2：\n输入：graph = [[1,3],[0],[3],[0,2]] 输出：1\n提示：\n3 \u0026lt;= graph.length \u0026lt;= 50 1 \u0026lt;= graph[i].length \u0026lt; graph.length 0 \u0026lt;= graph[i][j] \u0026lt; graph.length graph[i][j] != i graph[i] 互不相同 猫和老鼠在游戏中总是可以移动 博弈 前置知识 # 显然此题和博弈有关。先回忆最简单的博弈：NIM 游戏。\n给定 N 堆石子，第 i 堆有 ai 个石子。\n两名玩家轮流行动，每次在一堆石子中取若干个，不能不取，最后不能取的人输。\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e 原题链接：点击这里访问 简单来说，在公平博弈中，己方的最优策略是通过将对方引入其必败状态来确保胜利。\n核心思想是，在假设双方都采用最优策略的情况下：\n如果从某个状态可以到达至少一个对方必败状态，那么该状态对于己方就是必胜的。\n反之，如果无法到达任何对方必败状态，则该状态对己方就是必败的。\n如果游戏存在平局，则无法在确认必胜或必负的情况就是平局。\n对于该前置内容，我在24年初写过一道蓝桥杯的题，连接贴在下面可以参考：\n原题链接：点击这里访问 灭鼠先锋是一个老少咸宜的棋盘小游戏，由两人参与，轮流操作。\n灭鼠先锋的棋盘有各种规格，本题中游戏在两行四列的棋盘上进行。游戏的规则为：两人轮流操作，每次可选择在棋盘的一个空位上放置一个棋子，或在同一行的连续两个空位上各放置一个棋子，放下棋子后使棋盘放满的一方输掉游戏。\n小蓝和小乔一起玩游戏，小蓝先手，小乔后手。小蓝可以放置棋子的方法很多，通过旋转和翻转可以对应如下四种情况：\nXOOO XXOO OXOO OXXO OOOO OOOO OOOO OOOO 其中 O 表示棋盘上的一个方格为空，X 表示该方格已经放置了棋子。\n请问，对于以上四种情况，如果小蓝和小乔都是按照对自己最优的策略来玩游戏，小蓝是否能获胜。如果获胜，请用 V 表示，否则用 L 表示。请将四种情况的胜负结果按顺序连接在一起提交。\n24年题解如下\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; bool check(string s){//判断是否只有一个O int cnt = 0; for(auto i : s){ cnt += i==\u0026#39;O\u0026#39;; } return cnt == 1; } unordered_map\u0026lt;string, bool\u0026gt;mp; bool dfs(string s){ if(mp.count(s))return mp[s]; if(check(s)){//当当前状态只有一个O时标记为必败态 mp[s] = false; return false; } // 核心思路是只有遍历能到达一个必败态，此态就是必胜的（两人都是最优策略） // 如果一个必败态都无法到达，此态就是必败的 // 进行记忆化搜素 // 放置一个 for(int i = 0; i \u0026lt; s.size(); i ++){ if(s[i] == \u0026#39;O\u0026#39;){ string tmp = s; tmp[i] = \u0026#39;X\u0026#39;; if(dfs(tmp) == false){ mp[s] = true; return true; } } } // 放置两个 for(int i = 0; i \u0026lt; s.size(); i ++){ if(s[i] == \u0026#39;O\u0026#39; \u0026amp;\u0026amp; s[i+1] == \u0026#39;O\u0026#39; \u0026amp;\u0026amp; i != 3){ string tmp = s; tmp[i] = \u0026#39;X\u0026#39;; tmp[i+1] = \u0026#39;X\u0026#39;; if(dfs(tmp) == false){ mp[s] = true; return true; } } } mp[s] = false; return false; } int main() { dfs(\u0026#34;OOOOOOOO\u0026#34;); dfs(\u0026#34;XOOOOOOO\u0026#34;); dfs(\u0026#34;OXOOOOOO\u0026#34;); dfs(\u0026#34;XXOOOOOO\u0026#34;); dfs(\u0026#34;OXXOOOOO\u0026#34;); cout \u0026lt;\u0026lt; mp[\u0026#34;OXXOOOOO\u0026#34;] \u0026lt;\u0026lt; endl; return 0; } 记忆化搜索 # 一般而言，博弈问题可以转化为搜索问题。显然在博弈过程中会有大量重复子问题，因此往往会引入记忆化搜索。\n对于该题，很容易思考到搜索的前两个参数：猫位置与鼠位置。而第三个参数则有两种可能的写法，即 bool 类型表示现在是哪方的回合，以及 int 类型表示当前第几回合。\n而初始状态为：\n老鼠成功进洞，即 dp[0][j][1] = 1 （贪心可知，老鼠赢的下一回合一定是猫的回合） 猫捉到老鼠，即 dp[i][i][1] = 2 dp[i][i][0] = 2 如果想用 bool 类型表示回合，就又引出了新的问题。在无法确定回合数的情况下，如果不加上其他限制，对于平局会进入无限循环的搜索。\n但是对于 int 类型表示回合数，在此题的时间复杂度是不够的：\n在本题中，猫和鼠的数据范围都是 n 。如果第三个参数为上述的 int 行，其上界为： \\( 2 \\times n^2 \\) 则搜索状态为 \\( O(n^4) \\)，而此题的初始状态数上述提到过了是 n ，因此总复杂度为： \\( O(n^5) \\) 不能满足时间要求。\n根据上面的分析，此题的问题变为：在使用 bool 表示当前是谁的回合时，如何避免出现无限循环的搜索并尽可能剪枝。\n对于回合数作为第三个参数时的官方题解如下：\nclass Solution { public: const int MOUSE_TURN = 0, CAT_TURN = 1; const int DRAW = 0, MOUSE_WIN = 1, CAT_WIN = 2; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; graph; vector\u0026lt;vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026gt; degrees; vector\u0026lt;vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026gt; results; int catMouseGame(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; graph) { int n = graph.size(); this-\u0026gt;graph = graph; this-\u0026gt;degrees = vector\u0026lt;vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026gt;(n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;(n, vector\u0026lt;int\u0026gt;(2))); this-\u0026gt;results = vector\u0026lt;vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026gt;(n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;(n, vector\u0026lt;int\u0026gt;(2))); queue\u0026lt;tuple\u0026lt;int, int, int\u0026gt;\u0026gt; qu; for (int i = 0; i \u0026lt; n; i++) { for (int j = 1; j \u0026lt; n; j++) { degrees[i][j][MOUSE_TURN] = graph[i].size(); degrees[i][j][CAT_TURN] = graph[j].size(); } } for (int node : graph[0]) { for (int i = 0; i \u0026lt; n; i++) { degrees[i][node][CAT_TURN]--; } } for (int j = 1; j \u0026lt; n; j++) { results[0][j][MOUSE_TURN] = MOUSE_WIN; results[0][j][CAT_TURN] = MOUSE_WIN; qu.emplace(0, j, MOUSE_TURN); qu.emplace(0, j, CAT_TURN); } for (int i = 1; i \u0026lt; n; i++) { results[i][i][MOUSE_TURN] = CAT_WIN; results[i][i][CAT_TURN] = CAT_WIN; qu.emplace(i, i, MOUSE_TURN); qu.emplace(i, i, CAT_TURN); } while (!qu.empty()) { auto [mouse, cat, turn] = qu.front(); qu.pop(); int result = results[mouse][cat][turn]; vector\u0026lt;tuple\u0026lt;int, int, int\u0026gt;\u0026gt; prevStates = GetPrevStates(mouse, cat, turn); for (auto \u0026amp; [prevMouse, prevCat, prevTurn] : prevStates) { if (results[prevMouse][prevCat][prevTurn] == DRAW) { bool canWin = (result == MOUSE_WIN \u0026amp;\u0026amp; prevTurn == MOUSE_TURN) || (result == CAT_WIN \u0026amp;\u0026amp; prevTurn == CAT_TURN); if (canWin) { results[prevMouse][prevCat][prevTurn] = result; qu.emplace(prevMouse, prevCat, prevTurn); } else if (--degrees[prevMouse][prevCat][prevTurn] == 0) { int loseResult = prevTurn == MOUSE_TURN ? CAT_WIN : MOUSE_WIN; results[prevMouse][prevCat][prevTurn] = loseResult; qu.emplace(prevMouse, prevCat, prevTurn); } } } } return results[1][2][MOUSE_TURN]; } vector\u0026lt;tuple\u0026lt;int, int, int\u0026gt;\u0026gt; GetPrevStates(int mouse, int cat, int turn) { vector\u0026lt;tuple\u0026lt;int, int, int\u0026gt;\u0026gt; prevStates; int prevTurn = turn == MOUSE_TURN ? CAT_TURN : MOUSE_TURN; if (prevTurn == MOUSE_TURN) { for (int \u0026amp; prev : graph[mouse]) { prevStates.emplace_back(prev, cat, prevTurn); } } else { for (int \u0026amp; prev : graph[cat]) { if (prev != 0) { prevStates.emplace_back(mouse, prev, prevTurn); } } } return prevStates; } }; 拓扑排序 前置知识 # 此题说是用到拓扑排序并不准确，更应该说是用到拓扑排序的“ 入度表 ”的思想。\n入度表 记录 每个节点被指向的次数。\n使用 队列 处理 入度为 0 的节点。\n不断删除已处理的节点，更新 入度表。\n若无法遍历所有节点，则存在环。\n时间复杂度 O(n + m)，适用于 有向无环图（DAG）。\n对于该拓扑排序前置知识，可以参考下面：\n任务拓扑排序 # 一个工程被分解成n个子任务，编号为0至n-1。要完成整个工程需要完成所有的子任务。其中一些子任务必须先于另外一些子任务被完成。给定各子任务之间的先后关系，请编写程序给出一个合理的任务完成顺序，若工程不可行，程序亦能识别。\n输入第一行为两个整数n和e，均不超过100。n表示子任务数。接下来e行，表示已知的两个子任务间的先后关系，每行为两个整数a和b，表示任务a必须先于任务b完成。\n若工程不可行（一些子任务以自己为先决条件），输出“unworkable project”；若工程可行，输出为1行整数，每个整数后一个空格，为n个子任务的编号，表示子任务的完成顺序，如果有多种可能的顺序，则输出字典序最小者。\n注：字典序，即对象在字典中的顺序。对于两个数字序列，从第一个数字开始比较，当某一个位置的数字不同时，该位置数字较小的序列，字典序较小，例如1 2 3 9比1 2 4 5小，1 2 8 9比1 2 10 3小。\n样例1：\n3 2 0 1 1 2 0 1 2 样例2：\n3 3 0 1 1 2 2 0 unworkable project ANSWER # #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; graph(n); vector\u0026lt;int\u0026gt; inDegree(n, 0); // 记录每个节点的入度 // 读取边信息 for (int i = 0; i \u0026lt; m; i++) { int from, to; cin \u0026gt;\u0026gt; from \u0026gt;\u0026gt; to; graph[from].push_back(to); inDegree[to]++; // 目标节点的入度增加 } // 小顶堆（优先队列）保证字典序最小 priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; q; // 将所有入度为 0 的节点入队 for (int i = 0; i \u0026lt; n; i++) { if (inDegree[i] == 0) { q.push(i); } } vector\u0026lt;int\u0026gt; topoOrder; // 记录拓扑排序结果 while (!q.empty()) { int node = q.top(); q.pop(); topoOrder.push_back(node); for (int neighbor : graph[node]) { inDegree[neighbor]--; // 删除当前节点的出边 if (inDegree[neighbor] == 0) { // 若入度变为 0，则加入队列 q.push(neighbor); } } } // 如果排序结果中的节点数小于总节点数，说明有环 if (topoOrder.size() \u0026lt; n) { cout \u0026lt;\u0026lt; \u0026#34;unworkable project\u0026#34; \u0026lt;\u0026lt; endl; } else { for (int node : topoOrder) { cout \u0026lt;\u0026lt; node \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } } return 0; } 动态规划 # 那么在这道题中，如果为所有状态添加一个入度表，就可以做到上述的剪枝。\n同样的，我们选择自顶向下，初始状态为：\n老鼠成功进洞，即 result[0][j][1] = 1 （贪心可知，老鼠赢的下一回合一定是猫的回合） 猫捉到老鼠，即 result[i][i][1] = 2 result[i][i][0] = 2 其他状态设置为 0，即平局。 而对于入度的初始化为：\ndegree[i][j][0] = len(graph[i])\ndegree[i][j][1] = len(graph[j])\ndegree[i][j][1] -= 1 if j in graph[0] （猫不能在洞里）\n那么状态转移可以理解为：\n从最终状态遍历每一个前置状态： 若遍历到该前置状态的必胜态，则使其入度为零。 如没遍历到必胜态，则每次遍历使得其入度减一，知道其度为零，则设置其为必败态。 将已经确定必败或必胜的状态加入 queue 中， BFS 遍历其前置状态。 该转移没有遍历到的状态即平局状态。 当然此题还有些细节需要注意，可以看题解中的注释:\nclass Solution: def catMouseGame(self, graph: List[List[int]]) -\u0026gt; int: n = len(graph) queue = deque() # 状态为 degree[i][j][k] 表示: # 老鼠在 i , 猫在 j, 谁先手为 k (0 表示老鼠回合，1 表示猫回合) degree = [[[0, 0] for _ in range(n)] for _ in range(n)] result = [[[0, 0] for _ in range(n)] for _ in range(n)] def init(): for i in range(n): for j in range(1, n): degree[i][j][0] = len(graph[i]) degree[i][j][1] = len(graph[j]) # 猫不能在洞里，所以要减去这种特殊情况 for i in range(n): for j in graph[0]: degree[i][j][1] -= 1 for i in range(n): for j in range(1, n): if i == 0: result[i][j][1] = 1 # result[i][j][0] = 1 queue.append([i, j, 1]) # queue.append([i, j, 0]) elif i == j: result[i][j][1] =2 result[i][j][0] =2 queue.append([i, j, 1]) queue.append([i, j, 0]) init() # 检查前一个状态是否已经能被确定 def preCheck(preMouse, preCat, preTurn, result_state): if result[preMouse][preCat][preTurn] != 0: return # 如果下一个状态能赢，则直接确定为赢 win = True if result_state == 1 + preTurn else False if win: # 如果能赢，则入度直接归零 result[preMouse][preCat][preTurn] = result_state queue.append((preMouse, preCat, preTurn)) degree[preMouse][preCat][preTurn] = 0 # 避免重复处理 else: degree[preMouse][preCat][preTurn] -= 1 if degree[preMouse][preCat][preTurn] == 0: result[preMouse][preCat][preTurn] = 2 - preTurn queue.append((preMouse, preCat, preTurn)) # queue 中都是已经确定结果的状态 while queue: mouse, cat, turn = queue.popleft() result_state = result[mouse][cat][turn] preTurn = 1 - turn # 换手 if preTurn == 0: # 前一个回合是老鼠 for preMouse in graph[mouse]: preCheck(preMouse, cat, preTurn, result_state) else: # 前一个回合是猫 for preCat in graph[cat]: if preCat == 0: continue preCheck(mouse, preCat, preTurn, result_state) return result[1][2][0] 总结 # 此题综合了博弈论、搜索剪枝、动态规划、拓扑排序。有一定的难度，可以时常复习。\n","date":"2025 年 2 月 10 日","externalUrl":null,"permalink":"/posts/%E7%8C%AB%E5%92%8C%E8%80%81%E9%BC%A0-lc/","section":"","summary":"","title":"从“猫和老鼠”题解看博弈题型","type":"posts"},{"content":"","date":"2025 年 2 月 10 日","externalUrl":null,"permalink":"/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/","section":"","summary":"","title":"拓扑排序","type":"tags"},{"content":"","date":"2025 年 2 月 10 日","externalUrl":null,"permalink":"/tags/%E5%9B%BE%E8%AE%BA/","section":"","summary":"","title":"图论","type":"tags"},{"content":" 由于我使用的 oj 平台比较杂，很多时候找不到自己做过的题。\n特此将有价值的题目分类索引。\n本分类从 2025.02 开始。\n二分查找 # leetcode 1552 - 最大化最小\nleetcode 1760 - 最小化最大\nleetcode 2594 - 最小化最大\nleetcode 81 - 经典旋转数组二分，要考虑比较多的边界\nleetcode 33 - 上一道题的简化版\nluogu P1068 - 模拟排序 记得看下字符串输入输出\n记忆化搜索 # leetcode 63 - 走迷宫\nleetcode 132 - 分割字符串，返回计数。此题做法先记忆化搜索来预处理子串，之后用简单的 选或不选 DP 进行分割。\n搜索 # leetcode 90 - 类似选或不选的简单搜索\nleetcode 47 - 经典全排列，和上面类似\nleetcode 680 - 经典题验证回文串\nleetcode 131 - 经典回溯法，分割字符串\n动态规划 # 资源分配 DP # leetcode 2209 用地毯覆盖后的最少白色砖块 - 资源分配问题，dp[i][j]表示：前 i 个地砖用 j 个地毯后的最小白砖数量。其中 i 为进度轴、j 为资源轴。\nleetcode 1278. 分割回文串 III - 是前面两个记忆化搜索的分割字符串的延续。思路还是资源分配 DP，前 i 给字符分割成 j 给字符串的最小修改次数。\nleecode 1745. 分割回文串 IV - 和上面的 Ⅲ 几乎完全一致，不过是把维护修改数量改成维护 bool 值。\n区间 DP # 奶牛体检 - 区间DP + 前缀和，比较规矩的模板\n打家劫舍型 DP # 蓝桥 对局匹配 - 将数值分成 k 组，其中 i+k，i+2*k……为一组，可以保证组之间互不干扰。而在组中，就是打家劫舍问题。\nleetcode 2597. 美丽子集的数目 - 和上面的对局匹配几乎完全一致，不过要多想一下为什么 k 组之间相互独立\n状态机 DP # leetcode 2272. 最大波动的子字符串 - 此题转化成 状态机DP 的难度不低，小写字母双层外部遍历，内部遍历中维护两个状态。\n博弈 DP # leetcode 913. 猫和老鼠 - 比较复杂的博弈，写了博客文章。\n蓝桥 砍柴 - 基本是最简单的博弈，记忆化和递推都好写。加一个线性筛判断质数，但这题卡常极其恶心。\n蓝桥 魔法迅游 - 比较复杂的状态机 DP，也包含了前缀优化 DP 的思路。状态转移很复杂，模拟量较大。\n双指针 # leetcode 680 - 经典题验证回文串\n滑动窗口 # leetcode 3306. 元音辅音字符串计数 II - 至少型 滑动窗口，题目要求恰好 k，但滑动窗口只能解决至少 k 和 至少 k + 1，则需要将其相减。此外可以参考下其求至少的思路，即 ans += l ，其中 l 左侧每个都可以成为一个满足条件的子数组。\n字符串 # leetcode 541 - 字符串反转、练习下切片\n蓝桥 吊坠 - 字符串破坏成链DP + 克鲁斯卡尔 能过 80%，优化常数能过 90%。想过 100% 需要后缀自动机\n数论 # leetcode 2614. 对角线上的质数 - 线性筛预处理\n图论 # 蓝桥 吊坠 - 字符串破坏成链DP + 克鲁斯卡尔 能过 80%，优化常数能过 90%。想过 100% 需要后缀自动机。此题用图论的并查集克鲁斯卡尔。\nleetcode 547. 省份数量 - 最基础的图论 DFS。\nleetcode 1311. 获取你好友已观看的视频 - 最基础的图论 BFS，加一个 map 转化 vector 用 lambda 排序。\nleetcode 1129. 颜色交替的最短路径 - 必须交替走两种颜色的路径，由于路径长度都为一，因此还是 BFS。不过要维护两种颜色的 visited 和 两种颜色分别作为第一步的 ans。\n线段树 # leetcode 2080 - 统计区间内数字频数，将静态线段树板子的 max 改成统计词频的哈希表即可。（此题二分 + 前缀和更优）\nleetcode 307 - 经典的区间和检索，静态线段树板子\n模拟 # 蓝桥 连连看 - 需要先简单转化一下，得到模拟所有主副对角线，之后哈希统计。转化稍微需要一点思维。\n蓝桥 神奇闹钟 - 日期时间模拟，考库函数。日期做差。\n蓝桥 跑步 - 日期时间模拟，注意 weekday() 下标从 0 开始。\n蓝桥 跑步计划 - 日期时间模拟，和上一道题十分相似\nleetcode 2711. 对角线上不同值的数量差 - 简单二维模拟，用个 set 就秒了\nccfcsp 矩阵计算 - 模拟矩阵的点乘和积乘，此题正常算的复杂度很勉强。矩阵计算需要把点乘放到最后，因此用乘法交换律从右向左算。\nccfcsp 坐标变换（其二） - 前缀和 + 模拟，注意下三角函数库函数输入为弧度制。并需要控制输出精度。\n思维题 # leetcode 1287 - 有序数组中找 1/4 以上的连续数。其logn 复杂度下，思想角度类似鸽巢原理，或者从字符串角度看有一点像 kmp。\n蓝桥 召唤数学精灵 - 蓝桥杯特有的找规律，不得不品尝。前面位置的题不会了就缩小数据范围找规律试试。\n蓝桥 数字诗意 - 还是那个找规律，答案是所有的 2 ** n ，用 n \u0026amp; (n - 1) == 0 判断\n蓝桥 蓝桥村的真相 - 稍微难一点的找规律，和考公题一样。\n异或和 # leetcode 2588. 统计美丽子数组数目 - 巧妙的异或和例子\n蓝桥 异或和之和 - 异或和 加 贡献法\n贡献法 # 农夫约翰的奶酪块 - 贡献法，三维映射到二维\n哞叫时间 - 比较麻烦的模拟，基本方法是：先尝试该某点，获取哈希表计数，撤回对该点的修改\n哞叫时间Ⅱ - 在遍历过程中维护三个数组，“遍历右，维护左”\n贪心 # leetcode 624 - 经典的遍历右，维护左。\n蛋糕游戏 - 博弈中的贪心，要使用到前缀和\nleetcode 1328. 破坏回文串 - 有一些贪心做法，不过暴力也能过。\nleetcode 2070. 每一个查询的最大美丽值 - 经典遍历右，维护左\nleetcode 1963. 使字符串平衡的最小交换次数 - 可以交换的括号匹配，当遇到无法匹配的右括号时，贪心从后向前的左括号交换。\n蓝桥 回文数组 - 贪心，前后做差。可以看作差分数组的简化版本。\nleetcode 2680. 最大或值 - 贪心，将 k 都给一个元素是最好的。为了 On 实现，需要维护前后缀和。要注意此题并非维护区间和，区间和需要线段树。\nleetcode 2116. 判断一个括号字符串是否有效 - 指定可变括号位置的括号匹配。分别将可变的括号视作 “(“ 和 “)”，如果两次匹配都能成功，说明可变的位置是灵活的，说明能成功匹配。\n","date":"2025 年 2 月 2 日","externalUrl":null,"permalink":"/posts/%E7%AE%97%E6%B3%95%E9%A2%98-%E7%B4%A2%E5%BC%95/","section":"","summary":"","title":"算法题 - 分类索引","type":"posts"},{"content":" 首先，非常感谢您打开我的个人博客 🤗🤗🤗 我是谁？ # 👋 你好，我是 陈驰水 ！\n🎓 吉林大学软件工程 专业大三在读。\n📅 我出生于 2004 年，成长于北京市宣武区。\n🎯 目前正积极为 2025 年推免研究生 做准备，同时也在寻找合适的 企业实习 机会。\n💡 我对软件开发及前沿技术充满浓厚兴趣，当前正深入学习 AI \u0026amp; 机器学习 的理论与实践。\n🔗 如果您希望进一步了解我，欢迎点击本文上方头像下方的各平台链接。\n🧐 如果和您在线下见面，希望您能认出我：\n我的 GitHub 头像，就是我的证件照。\n👉跳转我的 GitHub\n💬 在闲暇时，我喜欢观看电影、阅读人文社科类书籍。\n🤝 我性格上乐于交流，也活跃于各类社交媒体，期待与更多志同道合的朋友相识！\n您可以通过本文的目录快速跳转到我的各个方面 📖 ➡️ 😊 关于此博客 # 本博客所使用的技术栈：\n此博客使用 github page + hugo 进行搭建。 对 blowfish theme 进行了个性化修改。 目前正使用 firebase 作为数据库。 目前解析到的域名是 blog.chencs.online ，并已经通过 icp备案 和 公安备案。 并使用 CDN 加速，以方便国内访问。 本博客内容：\n算法与数据结构的整理和总结。 本科课程的应试笔记。 机器学习等技术的学习笔记。 我的杂谈和优秀文章的转载。 此博客页面设计：\n本人对界面设计感比较看重，因此在博客的风格上也进行了一定的努力。 修改导航栏为灵动岛风格。 大部分字体与样式都经过我的微调。 文章全部进行分类和标记。 大部分 Markdown排版 和 latex公式 使用得当。 学习与技术经历 # 在算法上：\n目前全平台累计刷题已超过 700 道。 计算机软件能力认证考试 CCS-CSP：340 分（累计排名前 2%）。 Leetcode 周赛分数 1860+（全球排名前 7%）。 2024年夏季于某上市企业担任高薪算法助教。 在技术栈上：\n了解 C/C++ 及其 qt 图形化框架。熟悉⾯向对象编程思想和常⽤数据结构。 了解 HTML、CSS、JavaScript 前端开发，有多次⽹⻚与⼩程序开发设计的经验。 了解 Python 与 Pytorch 机器学习框架。有多次使⽤ Pytorch 实现基础深度学习模型的经验。 常使⽤ GitHub 等平台，有多次合作项⽬经历。熟悉分⽀管理、Pull Request 流程、issue 跟踪等功能。 具备⼀定的系统维护经验，了解 SQL 数据库操作、 Docker 容器化技术和 Linux 操作系统。 在科研上：\n简单了解热门方向：CV、LLM。 产出一篇 MARL方向论文。 有较为完整的科研经历。 其他：\n熟悉计组、计网、数据结构、操作系统、设计模式、数据库、编译原理等课程。 全国计算机博弈大赛国家级一等奖。 通过 CET6，有基本的英语阅读能力。 普通话等级二甲。 校园经历 # 我积极参加学生工作。\n从 2023 年开始担任 班长。\n在 2024 年担任 辅导员助理，负责处理学院的新生工作。\n于 2024.10 荣获 国家奖学金。\n还获得多种荣誉：校级优秀学生干部、校级优秀学生、校级优秀团员、社会奖学金。\n此外，我闲暇时参加了各类社团活动与优秀学生培养计划，并在其中结识了许多优秀的朋友。\n生活层面 # 近期喜欢的电影🎬：走走停停、芝加哥七君子审判。\n近期喜欢的游戏🎮：旷野之息、死亡搁浅、歧路旅人。\n近期喜欢的书籍📖：孤岛的来访者、失败者的春秋。\n网易云音乐重度用户🎵，日均使用时长 7小时。\n近期喜欢的歌手🎶：银河快递、蛙池、上海彩虹室内合唱团。\n🤝 如果想了解生活中的我，欢迎通过邮件添加我的个人微信。\n","date":"2025 年 2 月 1 日","externalUrl":null,"permalink":"/posts/%E5%85%B3%E4%BA%8E%E6%88%91/","section":"","summary":"","title":"关于我","type":"posts"},{"content":"","date":"2025 年 2 月 1 日","externalUrl":null,"permalink":"/categories/%E6%9D%82%E8%B0%88/","section":"","summary":"","title":"杂谈","type":"categories"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]