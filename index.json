
[{"content":" 最近文章 # ","date":"2025 年 2 月 8 日","externalUrl":null,"permalink":"/posts/","section":"","summary":"","title":"","type":"posts"},{"content":"","date":"2025 年 2 月 8 日","externalUrl":null,"permalink":"/","section":"陈驰水-个人博客","summary":"","title":"陈驰水-个人博客","type":"page"},{"content":"","date":"2025 年 2 月 8 日","externalUrl":null,"permalink":"/posts/%E5%85%B3%E4%BA%8E%E6%88%91/","section":"","summary":"","title":"关于我","type":"posts"},{"content":" 机器学习 # ","date":"2025 年 2 月 8 日","externalUrl":null,"permalink":"/posts/ml/","section":"","summary":"","title":"ML","type":"posts"},{"content":" 文章分类 # ","date":"2025 年 2 月 8 日","externalUrl":null,"permalink":"/categories/","section":"","summary":"","title":"","type":"categories"},{"content":" A 网络布线（最小支撑树） # 分数 50\n全屏浏览切换布局\n作者 朱允刚\n单位 吉林大学\n2024年亚洲杯足球赛刚刚落下帷幕，赛前人们普遍预测：本届比赛中日韩是最强的，冠军也会从日韩中产生……随着东道主卡塔尔队的夺冠，这一预言未能成真。\n但我们这里要研究的是另一个问题，亚洲杯赛期间需要保证运动员公寓网络畅通，以使运动员都能正常上网。\n假定公寓楼内有n个房间，编号为0…n−1，每个房间都需要网络连接。房间 i 有网络，当且仅当满足如下2个条件之一：\n（1）房间 i 安装了路由器（成本为 r**i\u0026gt;0）\n（2）房间 i 和房间 j 有网线连接且房间 j 有网络（在房间 i 和房间 j 之间布置网线的成本为 f**ij\u0026gt;0）\n假定你是赛事组委会的网络工程师，请编写程序设计一个网络布线方案（哪些房间安装路由器，哪些房间之间布置网线），使得所有房间都有网络，且总成本最小。\n例如下图包含7个房间和10个可能的连接，安装路由器的成本为括号内数字，房间之间布置网线的成本为边的权值。其解决方案为右下图，即在房间1和4安装路由器，并进行图中的网线布置。总成本为120。\n输入格式:\n输入第一行为两个正整数n和e；n为房间数，不超过600；e为可能的连接数，不超过2×105。接下来一行为n个空格间隔的正整数，第i个整数(i≥0)表示在房间i安装路由器的成本。接下来e行，每行为3个非负整数i、j、f，表示在房间i和房间j之间布置网线的成本为f。\n输出格式:\n输出为一个整数，表示最优网络布线方案的成本。\n输入样例:\n7 10 60 10 35 55 40 70 70 0 1 20 0 4 75 0 3 45 1 3 50 1 2 15 2 6 5 5 6 45 4 5 5 3 5 25 3 6 65 输出样例:\n120 提示:\n可引入一个虚拟顶点，将该顶点与其他所有顶点用边相连，边权等于那些顶点的权值。进而形成一个新图，对新图求最小支撑树。注意本题顶点编号从0开始。 答案 # #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; //下面为并查集的模板，用类的形式 class UF { public: vector\u0026lt;int\u0026gt; f; UF(int n) { f.resize(n); for (int i = 0; i \u0026lt; n; i++) { f[i] = i; } } int find(int x) { return f[x] == x ? x : f[x] = find(f[x]); } void connect(int a, int b) { f[find(a)] = find(b); } bool connected(int a, int b) { return find(a) == find(b); } }; void minCostConnectPoints(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; edges, int n) { // 生成所有边及权重，Kruskal算法的核心是边 // 将边按照权重从小到大排序 // lambda表示式，函数sort的第三个变量为sort依据 sort(edges.begin(), edges.end(), [](const vector\u0026lt;int\u0026gt;\u0026amp; a, const vector\u0026lt;int\u0026gt;\u0026amp; b) { return a[2] \u0026lt; b[2]; }); // 执行 Kruskal 算法 // 并查集的结构是点集合 int mst = 0; UF uf(n + 1); for (auto\u0026amp; edge : edges) { //排序后的边集合用于贪心出最小生成树 int u = edge[0]; int v = edge[1]; int weight = edge[2]; // 若这条边会产生环，则不能加入 mst if (uf.connected(u, v)) { continue; } // 若这条边不会产生环，则属于最小生成树 mst += weight; uf.connect(u, v); } cout \u0026lt;\u0026lt; mst; } // 邻接表 int main(void) { ios::sync_with_stdio(false); int n, count; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; count; vector\u0026lt;int\u0026gt;cost; for (int i = 0; i \u0026lt; n; i++) { int temp = 0; cin \u0026gt;\u0026gt; temp; cost.push_back(temp); } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;graph; while(count--) { int from, to, dis; cin \u0026gt;\u0026gt; from \u0026gt;\u0026gt; to \u0026gt;\u0026gt; dis; graph.push_back({from, to, dis}); } for (int i = 0; i \u0026lt; n; i++) { graph.push_back({n, i ,cost[i]}); } minCostConnectPoints(graph, n); return 0; } B 社交网络 （floyd） # 分数 50\n全屏浏览切换布局\n作者 朱允刚\n单位 吉林大学\n可以将n个QQ用户间的好友关系建模为一个包含n个顶点的无向图，顶点编号为1至n，每个顶点对应一个用户，若2个用户i和j是QQ好友，则在顶点i和j之间连接一条边，并根据用户间的亲密度对该边附以一个权值c**ij。在该图中，可以利用两个顶点间的最短路径长度衡量两个用户的关系密切程度，也可以利用经过一个顶点的最短路径数目来衡量一个用户在关系网络中的影响力，具体地，我们定义用户k在QQ关系网络中的“影响力”为：\n其中N**ij为顶点i到j的最短路径数目，N**ijk为顶点i到j的所有最短路径中经过顶点k的最短路径数目（上述二值可能超出int型范围，请使用long long类型）。D**ij表示i到j的最短路径长度。\n现给定一个如上描述的无向图，请编写程序，计算每个顶点的“影响力”，假定给定的图是连通的。\n输入格式:\n输入第一行为两个正整数n和e，分别表示图的顶点数和边数，接下来e行表示每条边的信息，每行为3个正整数a、b、c，其中a和b表示该边的端点编号，c表示权值。各边并非按端点编号顺序排列。\nn≤100，e≤5000，c≤1000，任意两点间的最短路径数目≤1010\n输出格式:\n输出为n行，每行一个实数，精确到小数点后3位，第i行为顶点i的影响力。\n输入样例:\n4 4 3 2 6 4 3 1 1 3 9 4 1 1 输出样例:\n0.000 0.000 30.000 20.000 解释:\n对于顶点1：边2-3、3-4、2-4的最短路径均不经过顶点1，故顶点1的影响力为0.\n对于顶点3： 顶点1到2的最短路径共1条，长度为8，经过点3，顶点2到4的最短路径共1条，长度为7，经过点3，顶点1到4的最短路径共1条，但不经过点3。 故f(3)=D12∗1+D24∗1+D14∗0+D21∗1+D42∗1+D41∗0=8+7+0+8+7+0=30.000\n提示:\n若顶点a到顶点b有x条路径，点b到点c有y条路径，则a经过b到达c的路径有x*y条。\n答案 # #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;climits\u0026gt; using namespace std; vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt;fre; // Floyd算法 void floyd(vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt;\u0026amp; dist, int n) { fre.resize(n, vector\u0026lt;long long\u0026gt;(n, 0)); for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) { if (i != j \u0026amp;\u0026amp; dist[i][j] != INT_MAX) { fre[i][j] = 1; } } } for (int k = 0; k \u0026lt; n; k++) { for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) { if (dist[i][k] != INT_MAX \u0026amp;\u0026amp; dist[k][j] != INT_MAX \u0026amp;\u0026amp; dist[i][k] + dist[k][j] \u0026lt; dist[i][j] ) { dist[i][j] = dist[i][k] + dist[k][j]; fre[i][j] = fre[i][k] * fre[k][j]; } else if (dist[i][k] + dist[k][j] == dist[i][j]) fre[i][j] += fre[i][k] * fre[k][j]; } } } } // 计算顶点的影响力 vector\u0026lt;double\u0026gt; calculateInfluence(const vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt;\u0026amp; dist, int n) { vector\u0026lt;double\u0026gt; influence(n, 0.0); for (int k = 0; k \u0026lt; n; k++) { for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) { if (i != j \u0026amp;\u0026amp; i != k \u0026amp;\u0026amp; j != k \u0026amp;\u0026amp; dist[i][j] == dist[i][k] + dist[k][j]) { influence[k] += 1.0 * dist[i][j] * (fre[i][k] * fre[k][j]) / fre[i][j]; } } } } return influence; } int main() { int n, e; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; e; // 输入 vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt; dist(n, vector\u0026lt;long long\u0026gt;(n, INT_MAX)); for (int i = 0; i \u0026lt; n; i++) { dist[i][i] = 0; } // 邻接矩阵 for (int i = 0; i \u0026lt; e; i++) { int from, to, dis; cin \u0026gt;\u0026gt; from \u0026gt;\u0026gt; to \u0026gt;\u0026gt; dis; dist[from - 1][to - 1] = dis; dist[to - 1][from - 1] = dis; } floyd(dist, n); // 计算影响力 vector\u0026lt;double\u0026gt; influence = calculateInfluence(dist, n); // 输出 cout.precision(3); cout \u0026lt;\u0026lt; fixed; for (int i = 0; i \u0026lt; n; i++) { cout \u0026lt;\u0026lt; influence[i] \u0026lt;\u0026lt; endl; } return 0; } ","date":"2025 年 2 月 8 日","externalUrl":null,"permalink":"/posts/pta/","section":"","summary":"","title":"PTA","type":"posts"},{"content":"","date":"2025 年 2 月 8 日","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"2025 年 2 月 8 日","externalUrl":null,"permalink":"/tags/%E5%8D%9A%E5%AE%A2/","section":"Tags","summary":"","title":"博客","type":"tags"},{"content":"","date":"2025 年 2 月 8 日","externalUrl":null,"permalink":"/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","section":"","summary":"","title":"算法与数据结构","type":"categories"},{"content":"","date":"2025 年 2 月 8 日","externalUrl":null,"permalink":"/tags/%E7%AB%99%E7%82%B9%E4%BC%98%E5%8C%96/","section":"Tags","summary":"","title":"站点优化","type":"tags"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]