
[{"content":" 文章分类 # ","date":"2025 年 2 月 10 日","externalUrl":null,"permalink":"/categories/","section":"","summary":"","title":"","type":"categories"},{"content":" 最近文章 # ","date":"2025 年 2 月 10 日","externalUrl":null,"permalink":"/posts/","section":"","summary":"","title":"","type":"posts"},{"content":"","date":"2025 年 2 月 10 日","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"2025 年 2 月 10 日","externalUrl":null,"permalink":"/tags/%E5%8D%9A%E5%BC%88/","section":"Tags","summary":"","title":"博弈","type":"tags"},{"content":"","date":"2025 年 2 月 10 日","externalUrl":null,"permalink":"/","section":"陈驰水-个人博客","summary":"","title":"陈驰水-个人博客","type":"page"},{"content":"","date":"2025 年 2 月 10 日","externalUrl":null,"permalink":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","section":"Tags","summary":"","title":"动态规划","type":"tags"},{"content":" \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e 原题链接：点击这里访问 猫和老鼠 题干 # 两位玩家分别扮演猫和老鼠，在一张 无向 图上进行游戏，两人轮流行动。\n图的形式是：graph[a] 是一个列表，由满足 ab 是图中的一条边的所有节点 b 组成。\n老鼠从节点 1 开始，第一个出发；猫从节点 2 开始，第二个出发。在节点 0 处有一个洞。\n在每个玩家的行动中，他们 必须 沿着图中与所在当前位置连通的一条边移动。例如，如果老鼠在节点 1 ，那么它必须移动到 graph[1] 中的任一节点。\n此外，猫无法移动到洞中（节点 0）。\n然后，游戏在出现以下三种情形之一时结束：\n如果猫和老鼠出现在同一个节点，猫获胜。 如果老鼠到达洞中，老鼠获胜。 = 如果某一位置重复出现（即，玩家的位置和移动顺序都与上一次行动相同），游戏平局。 给你一张图 graph ，并假设两位玩家都都以最佳状态参与游戏：\n如果老鼠获胜，则返回 1； 如果猫获胜，则返回 2； 如果平局，则返回 0 。 示例 1：\n输入：graph = [[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]] 输出：0 示例 2：\n输入：graph = [[1,3],[0],[3],[0,2]] 输出：1\n提示：\n3 \u0026lt;= graph.length \u0026lt;= 50 1 \u0026lt;= graph[i].length \u0026lt; graph.length 0 \u0026lt;= graph[i][j] \u0026lt; graph.length graph[i][j] != i graph[i] 互不相同 猫和老鼠在游戏中总是可以移动 博弈 前置知识 # 显然此题和博弈有关。先回忆最简单的博弈：NIM 游戏。\n给定 N 堆石子，第 i 堆有 ai 个石子。\n两名玩家轮流行动，每次在一堆石子中取若干个，不能不取，最后不能取的人输。\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e 原题链接：点击这里访问 简单来说，在公平博弈中，己方的最优策略是通过将对方引入其必败状态来确保胜利。\n核心思想是，在假设双方都采用最优策略的情况下：\n如果从某个状态可以到达至少一个对方必败状态，那么该状态对于己方就是必胜的。\n反之，如果无法到达任何对方必败状态，则该状态对己方就是必败的。\n如果游戏存在平局，则无法在确认必胜或必负的情况就是平局。\n对于该前置内容，我在24年初写过一道蓝桥杯的题，连接贴在下面可以参考：\n原题链接：点击这里访问 灭鼠先锋是一个老少咸宜的棋盘小游戏，由两人参与，轮流操作。\n灭鼠先锋的棋盘有各种规格，本题中游戏在两行四列的棋盘上进行。游戏的规则为：两人轮流操作，每次可选择在棋盘的一个空位上放置一个棋子，或在同一行的连续两个空位上各放置一个棋子，放下棋子后使棋盘放满的一方输掉游戏。\n小蓝和小乔一起玩游戏，小蓝先手，小乔后手。小蓝可以放置棋子的方法很多，通过旋转和翻转可以对应如下四种情况：\nXOOO XXOO OXOO OXXO OOOO OOOO OOOO OOOO 其中 O 表示棋盘上的一个方格为空，X 表示该方格已经放置了棋子。\n请问，对于以上四种情况，如果小蓝和小乔都是按照对自己最优的策略来玩游戏，小蓝是否能获胜。如果获胜，请用 V 表示，否则用 L 表示。请将四种情况的胜负结果按顺序连接在一起提交。\n24年题解如下\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; bool check(string s){//判断是否只有一个O int cnt = 0; for(auto i : s){ cnt += i==\u0026#39;O\u0026#39;; } return cnt == 1; } unordered_map\u0026lt;string, bool\u0026gt;mp; bool dfs(string s){ if(mp.count(s))return mp[s]; if(check(s)){//当当前状态只有一个O时标记为必败态 mp[s] = false; return false; } // 核心思路是只有遍历能到达一个必败态，此态就是必胜的（两人都是最优策略） // 如果一个必败态都无法到达，此态就是必败的 // 进行记忆化搜素 // 放置一个 for(int i = 0; i \u0026lt; s.size(); i ++){ if(s[i] == \u0026#39;O\u0026#39;){ string tmp = s; tmp[i] = \u0026#39;X\u0026#39;; if(dfs(tmp) == false){ mp[s] = true; return true; } } } // 放置两个 for(int i = 0; i \u0026lt; s.size(); i ++){ if(s[i] == \u0026#39;O\u0026#39; \u0026amp;\u0026amp; s[i+1] == \u0026#39;O\u0026#39; \u0026amp;\u0026amp; i != 3){ string tmp = s; tmp[i] = \u0026#39;X\u0026#39;; tmp[i+1] = \u0026#39;X\u0026#39;; if(dfs(tmp) == false){ mp[s] = true; return true; } } } mp[s] = false; return false; } int main() { dfs(\u0026#34;OOOOOOOO\u0026#34;); dfs(\u0026#34;XOOOOOOO\u0026#34;); dfs(\u0026#34;OXOOOOOO\u0026#34;); dfs(\u0026#34;XXOOOOOO\u0026#34;); dfs(\u0026#34;OXXOOOOO\u0026#34;); cout \u0026lt;\u0026lt; mp[\u0026#34;OXXOOOOO\u0026#34;] \u0026lt;\u0026lt; endl; return 0; } 记忆化搜索 # 一般而言，博弈问题可以转化为搜索问题。显然在博弈过程中会有大量重复子问题，因此往往会引入记忆化搜索。\n对于该题，很容易思考到搜索的前两个参数：猫位置与鼠位置。而第三个参数则有两种可能的写法，即 bool 类型表示现在是哪方的回合，以及 int 类型表示当前第几回合。\n而初始状态为：\n老鼠成功进洞，即 dp[0][j][1] = 1 （贪心可知，老鼠赢的下一回合一定是猫的回合） 猫捉到老鼠，即 dp[i][i][1] = 2 dp[i][i][0] = 2 如果想用 bool 类型表示回合，就又引出了新的问题。在无法确定回合数的情况下，如果不加上其他限制，对于平局会进入无限循环的搜索。\n但是对于 int 类型表示回合数，在此题的时间复杂度是不够的：\n其中猫和鼠的数据范围都是 N，如果第三个参数为上述的 int 行，其上界为 $2 * n^2$。则搜索状态为 $ O n ^4 $，而此题的初始状态数上述提到过了是 N，因此总复杂度为 $ O n ^ 5 $。不能满足时间要求。\n根据上面的分析，此题的问题变为：在使用 bool 表示当前是谁的回合时，如何避免出现无限循环的搜索并尽可能剪枝。\n对于回合数作为第三个参数时的官方题解如下：\nclass Solution { public: const int MOUSE_TURN = 0, CAT_TURN = 1; const int DRAW = 0, MOUSE_WIN = 1, CAT_WIN = 2; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; graph; vector\u0026lt;vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026gt; degrees; vector\u0026lt;vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026gt; results; int catMouseGame(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; graph) { int n = graph.size(); this-\u0026gt;graph = graph; this-\u0026gt;degrees = vector\u0026lt;vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026gt;(n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;(n, vector\u0026lt;int\u0026gt;(2))); this-\u0026gt;results = vector\u0026lt;vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026gt;(n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;(n, vector\u0026lt;int\u0026gt;(2))); queue\u0026lt;tuple\u0026lt;int, int, int\u0026gt;\u0026gt; qu; for (int i = 0; i \u0026lt; n; i++) { for (int j = 1; j \u0026lt; n; j++) { degrees[i][j][MOUSE_TURN] = graph[i].size(); degrees[i][j][CAT_TURN] = graph[j].size(); } } for (int node : graph[0]) { for (int i = 0; i \u0026lt; n; i++) { degrees[i][node][CAT_TURN]--; } } for (int j = 1; j \u0026lt; n; j++) { results[0][j][MOUSE_TURN] = MOUSE_WIN; results[0][j][CAT_TURN] = MOUSE_WIN; qu.emplace(0, j, MOUSE_TURN); qu.emplace(0, j, CAT_TURN); } for (int i = 1; i \u0026lt; n; i++) { results[i][i][MOUSE_TURN] = CAT_WIN; results[i][i][CAT_TURN] = CAT_WIN; qu.emplace(i, i, MOUSE_TURN); qu.emplace(i, i, CAT_TURN); } while (!qu.empty()) { auto [mouse, cat, turn] = qu.front(); qu.pop(); int result = results[mouse][cat][turn]; vector\u0026lt;tuple\u0026lt;int, int, int\u0026gt;\u0026gt; prevStates = GetPrevStates(mouse, cat, turn); for (auto \u0026amp; [prevMouse, prevCat, prevTurn] : prevStates) { if (results[prevMouse][prevCat][prevTurn] == DRAW) { bool canWin = (result == MOUSE_WIN \u0026amp;\u0026amp; prevTurn == MOUSE_TURN) || (result == CAT_WIN \u0026amp;\u0026amp; prevTurn == CAT_TURN); if (canWin) { results[prevMouse][prevCat][prevTurn] = result; qu.emplace(prevMouse, prevCat, prevTurn); } else if (--degrees[prevMouse][prevCat][prevTurn] == 0) { int loseResult = prevTurn == MOUSE_TURN ? CAT_WIN : MOUSE_WIN; results[prevMouse][prevCat][prevTurn] = loseResult; qu.emplace(prevMouse, prevCat, prevTurn); } } } } return results[1][2][MOUSE_TURN]; } vector\u0026lt;tuple\u0026lt;int, int, int\u0026gt;\u0026gt; GetPrevStates(int mouse, int cat, int turn) { vector\u0026lt;tuple\u0026lt;int, int, int\u0026gt;\u0026gt; prevStates; int prevTurn = turn == MOUSE_TURN ? CAT_TURN : MOUSE_TURN; if (prevTurn == MOUSE_TURN) { for (int \u0026amp; prev : graph[mouse]) { prevStates.emplace_back(prev, cat, prevTurn); } } else { for (int \u0026amp; prev : graph[cat]) { if (prev != 0) { prevStates.emplace_back(mouse, prev, prevTurn); } } } return prevStates; } }; 拓扑排序 前置知识 # 此题说是用到拓扑排序并不准确，更应该说是用到拓扑排序的“ 入度表 ”的思想。\n入度表 记录 每个节点被指向的次数。\n使用 队列 处理 入度为 0 的节点。\n不断删除已处理的节点，更新 入度表。\n若无法遍历所有节点，则存在环。\n时间复杂度 O(n + m)，适用于 有向无环图（DAG）。\n对于该拓扑排序前置知识，可以参考下面：\n任务拓扑排序 # 一个工程被分解成n个子任务，编号为0至n-1。要完成整个工程需要完成所有的子任务。其中一些子任务必须先于另外一些子任务被完成。给定各子任务之间的先后关系，请编写程序给出一个合理的任务完成顺序，若工程不可行，程序亦能识别。\n输入第一行为两个整数n和e，均不超过100。n表示子任务数。接下来e行，表示已知的两个子任务间的先后关系，每行为两个整数a和b，表示任务a必须先于任务b完成。\n若工程不可行（一些子任务以自己为先决条件），输出“unworkable project”；若工程可行，输出为1行整数，每个整数后一个空格，为n个子任务的编号，表示子任务的完成顺序，如果有多种可能的顺序，则输出字典序最小者。\n注：字典序，即对象在字典中的顺序。对于两个数字序列，从第一个数字开始比较，当某一个位置的数字不同时，该位置数字较小的序列，字典序较小，例如1 2 3 9比1 2 4 5小，1 2 8 9比1 2 10 3小。\n样例1：\n3 2 0 1 1 2 0 1 2 样例2：\n3 3 0 1 1 2 2 0 unworkable project ANSWER # #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; graph(n); vector\u0026lt;int\u0026gt; inDegree(n, 0); // 记录每个节点的入度 // 读取边信息 for (int i = 0; i \u0026lt; m; i++) { int from, to; cin \u0026gt;\u0026gt; from \u0026gt;\u0026gt; to; graph[from].push_back(to); inDegree[to]++; // 目标节点的入度增加 } // 小顶堆（优先队列）保证字典序最小 priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; q; // 将所有入度为 0 的节点入队 for (int i = 0; i \u0026lt; n; i++) { if (inDegree[i] == 0) { q.push(i); } } vector\u0026lt;int\u0026gt; topoOrder; // 记录拓扑排序结果 while (!q.empty()) { int node = q.top(); q.pop(); topoOrder.push_back(node); for (int neighbor : graph[node]) { inDegree[neighbor]--; // 删除当前节点的出边 if (inDegree[neighbor] == 0) { // 若入度变为 0，则加入队列 q.push(neighbor); } } } // 如果排序结果中的节点数小于总节点数，说明有环 if (topoOrder.size() \u0026lt; n) { cout \u0026lt;\u0026lt; \u0026#34;unworkable project\u0026#34; \u0026lt;\u0026lt; endl; } else { for (int node : topoOrder) { cout \u0026lt;\u0026lt; node \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } } return 0; } 动态规划 # 那么在这道题中，如果为所有状态添加一个入度表，就可以做到上述的剪枝。\n同样的，我们选择自顶向下，初始状态为：\n老鼠成功进洞，即 result[0][j][1] = 1 （贪心可知，老鼠赢的下一回合一定是猫的回合） 猫捉到老鼠，即 result[i][i][1] = 2 result[i][i][0] = 2 其他状态设置为 0，即平局。 而对于入度的初始化为：\ndegree[i][j][0] = len(graph[i])\ndegree[i][j][1] = len(graph[j])\ndegree[i][j][1] -= 1 if j in graph[0] （猫不能在洞里）\n那么状态转移可以理解为：\n从最终状态遍历每一个前置状态： 若遍历到该前置状态的必胜态，则使其入度为零。 如没遍历到必胜态，则每次遍历使得其入度减一，知道其度为零，则设置其为必败态。 将已经确定必败或必胜的状态加入 queue 中， BFS 遍历其前置状态。 该转移没有遍历到的状态即平局状态。 当然此题还有些细节需要注意，可以看题解中的注释:\nclass Solution: def catMouseGame(self, graph: List[List[int]]) -\u0026gt; int: n = len(graph) queue = deque() # 状态为 degree[i][j][k] 表示: # 老鼠在 i , 猫在 j, 谁先手为 k (0 表示老鼠回合，1 表示猫回合) degree = [[[0, 0] for _ in range(n)] for _ in range(n)] result = [[[0, 0] for _ in range(n)] for _ in range(n)] def init(): for i in range(n): for j in range(1, n): degree[i][j][0] = len(graph[i]) degree[i][j][1] = len(graph[j]) # 猫不能在洞里，所以要减去这种特殊情况 for i in range(n): for j in graph[0]: degree[i][j][1] -= 1 for i in range(n): for j in range(1, n): if i == 0: result[i][j][1] = 1 # result[i][j][0] = 1 queue.append([i, j, 1]) # queue.append([i, j, 0]) elif i == j: result[i][j][1] =2 result[i][j][0] =2 queue.append([i, j, 1]) queue.append([i, j, 0]) init() # 检查前一个状态是否已经能被确定 def preCheck(preMouse, preCat, preTurn, result_state): if result[preMouse][preCat][preTurn] != 0: return # 如果下一个状态能赢，则直接确定为赢 win = True if result_state == 1 + preTurn else False if win: # 如果能赢，则入度直接归零 result[preMouse][preCat][preTurn] = result_state queue.append((preMouse, preCat, preTurn)) degree[preMouse][preCat][preTurn] = 0 # 避免重复处理 else: degree[preMouse][preCat][preTurn] -= 1 if degree[preMouse][preCat][preTurn] == 0: result[preMouse][preCat][preTurn] = 2 - preTurn queue.append((preMouse, preCat, preTurn)) # queue 中都是已经确定结果的状态 while queue: mouse, cat, turn = queue.popleft() result_state = result[mouse][cat][turn] preTurn = 1 - turn # 换手 if preTurn == 0: # 前一个回合是老鼠 for preMouse in graph[mouse]: preCheck(preMouse, cat, preTurn, result_state) else: # 前一个回合是猫 for preCat in graph[cat]: if preCat == 0: continue preCheck(mouse, preCat, preTurn, result_state) return result[1][2][0] 总结 # 此题综合了博弈论、搜索剪枝、动态规划、拓扑排序。有一定的难度，可以时常复习。\n","date":"2025 年 2 月 10 日","externalUrl":null,"permalink":"/posts/%E7%8C%AB%E5%92%8C%E8%80%81%E9%BC%A0-lc/","section":"","summary":"","title":"猫和老鼠 LC","type":"posts"},{"content":"","date":"2025 年 2 月 10 日","externalUrl":null,"permalink":"/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","section":"","summary":"","title":"算法与数据结构","type":"categories"},{"content":"","date":"2025 年 2 月 10 日","externalUrl":null,"permalink":"/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/","section":"Tags","summary":"","title":"拓扑排序","type":"tags"},{"content":"","date":"2025 年 2 月 10 日","externalUrl":null,"permalink":"/tags/%E5%9B%BE%E8%AE%BA/","section":"Tags","summary":"","title":"图论","type":"tags"},{"content":"","date":"2025 年 2 月 8 日","externalUrl":null,"permalink":"/posts/%E5%85%B3%E4%BA%8E%E6%88%91/","section":"","summary":"","title":"关于我","type":"posts"},{"content":" 机器学习 # ","date":"2025 年 2 月 8 日","externalUrl":null,"permalink":"/posts/ml/","section":"","summary":"","title":"ML","type":"posts"},{"content":" A 网络布线（最小支撑树） # 分数 50\n全屏浏览切换布局\n作者 朱允刚\n单位 吉林大学\n2024年亚洲杯足球赛刚刚落下帷幕，赛前人们普遍预测：本届比赛中日韩是最强的，冠军也会从日韩中产生……随着东道主卡塔尔队的夺冠，这一预言未能成真。\n但我们这里要研究的是另一个问题，亚洲杯赛期间需要保证运动员公寓网络畅通，以使运动员都能正常上网。\n假定公寓楼内有n个房间，编号为0…n−1，每个房间都需要网络连接。房间 i 有网络，当且仅当满足如下2个条件之一：\n（1）房间 i 安装了路由器（成本为 r**i\u0026gt;0）\n（2）房间 i 和房间 j 有网线连接且房间 j 有网络（在房间 i 和房间 j 之间布置网线的成本为 f**ij\u0026gt;0）\n假定你是赛事组委会的网络工程师，请编写程序设计一个网络布线方案（哪些房间安装路由器，哪些房间之间布置网线），使得所有房间都有网络，且总成本最小。\n例如下图包含7个房间和10个可能的连接，安装路由器的成本为括号内数字，房间之间布置网线的成本为边的权值。其解决方案为右下图，即在房间1和4安装路由器，并进行图中的网线布置。总成本为120。\n输入格式:\n输入第一行为两个正整数n和e；n为房间数，不超过600；e为可能的连接数，不超过2×105。接下来一行为n个空格间隔的正整数，第i个整数(i≥0)表示在房间i安装路由器的成本。接下来e行，每行为3个非负整数i、j、f，表示在房间i和房间j之间布置网线的成本为f。\n输出格式:\n输出为一个整数，表示最优网络布线方案的成本。\n输入样例:\n7 10 60 10 35 55 40 70 70 0 1 20 0 4 75 0 3 45 1 3 50 1 2 15 2 6 5 5 6 45 4 5 5 3 5 25 3 6 65 输出样例:\n120 提示:\n可引入一个虚拟顶点，将该顶点与其他所有顶点用边相连，边权等于那些顶点的权值。进而形成一个新图，对新图求最小支撑树。注意本题顶点编号从0开始。 答案 # #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; //下面为并查集的模板，用类的形式 class UF { public: vector\u0026lt;int\u0026gt; f; UF(int n) { f.resize(n); for (int i = 0; i \u0026lt; n; i++) { f[i] = i; } } int find(int x) { return f[x] == x ? x : f[x] = find(f[x]); } void connect(int a, int b) { f[find(a)] = find(b); } bool connected(int a, int b) { return find(a) == find(b); } }; void minCostConnectPoints(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; edges, int n) { // 生成所有边及权重，Kruskal算法的核心是边 // 将边按照权重从小到大排序 // lambda表示式，函数sort的第三个变量为sort依据 sort(edges.begin(), edges.end(), [](const vector\u0026lt;int\u0026gt;\u0026amp; a, const vector\u0026lt;int\u0026gt;\u0026amp; b) { return a[2] \u0026lt; b[2]; }); // 执行 Kruskal 算法 // 并查集的结构是点集合 int mst = 0; UF uf(n + 1); for (auto\u0026amp; edge : edges) { //排序后的边集合用于贪心出最小生成树 int u = edge[0]; int v = edge[1]; int weight = edge[2]; // 若这条边会产生环，则不能加入 mst if (uf.connected(u, v)) { continue; } // 若这条边不会产生环，则属于最小生成树 mst += weight; uf.connect(u, v); } cout \u0026lt;\u0026lt; mst; } // 邻接表 int main(void) { ios::sync_with_stdio(false); int n, count; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; count; vector\u0026lt;int\u0026gt;cost; for (int i = 0; i \u0026lt; n; i++) { int temp = 0; cin \u0026gt;\u0026gt; temp; cost.push_back(temp); } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;graph; while(count--) { int from, to, dis; cin \u0026gt;\u0026gt; from \u0026gt;\u0026gt; to \u0026gt;\u0026gt; dis; graph.push_back({from, to, dis}); } for (int i = 0; i \u0026lt; n; i++) { graph.push_back({n, i ,cost[i]}); } minCostConnectPoints(graph, n); return 0; } B 社交网络 （floyd） # 分数 50\n全屏浏览切换布局\n作者 朱允刚\n单位 吉林大学\n可以将n个QQ用户间的好友关系建模为一个包含n个顶点的无向图，顶点编号为1至n，每个顶点对应一个用户，若2个用户i和j是QQ好友，则在顶点i和j之间连接一条边，并根据用户间的亲密度对该边附以一个权值c**ij。在该图中，可以利用两个顶点间的最短路径长度衡量两个用户的关系密切程度，也可以利用经过一个顶点的最短路径数目来衡量一个用户在关系网络中的影响力，具体地，我们定义用户k在QQ关系网络中的“影响力”为：\n其中N**ij为顶点i到j的最短路径数目，N**ijk为顶点i到j的所有最短路径中经过顶点k的最短路径数目（上述二值可能超出int型范围，请使用long long类型）。D**ij表示i到j的最短路径长度。\n现给定一个如上描述的无向图，请编写程序，计算每个顶点的“影响力”，假定给定的图是连通的。\n输入格式:\n输入第一行为两个正整数n和e，分别表示图的顶点数和边数，接下来e行表示每条边的信息，每行为3个正整数a、b、c，其中a和b表示该边的端点编号，c表示权值。各边并非按端点编号顺序排列。\nn≤100，e≤5000，c≤1000，任意两点间的最短路径数目≤1010\n输出格式:\n输出为n行，每行一个实数，精确到小数点后3位，第i行为顶点i的影响力。\n输入样例:\n4 4 3 2 6 4 3 1 1 3 9 4 1 1 输出样例:\n0.000 0.000 30.000 20.000 解释:\n对于顶点1：边2-3、3-4、2-4的最短路径均不经过顶点1，故顶点1的影响力为0.\n对于顶点3： 顶点1到2的最短路径共1条，长度为8，经过点3，顶点2到4的最短路径共1条，长度为7，经过点3，顶点1到4的最短路径共1条，但不经过点3。 故f(3)=D12∗1+D24∗1+D14∗0+D21∗1+D42∗1+D41∗0=8+7+0+8+7+0=30.000\n提示:\n若顶点a到顶点b有x条路径，点b到点c有y条路径，则a经过b到达c的路径有x*y条。\n答案 # #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;climits\u0026gt; using namespace std; vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt;fre; // Floyd算法 void floyd(vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt;\u0026amp; dist, int n) { fre.resize(n, vector\u0026lt;long long\u0026gt;(n, 0)); for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) { if (i != j \u0026amp;\u0026amp; dist[i][j] != INT_MAX) { fre[i][j] = 1; } } } for (int k = 0; k \u0026lt; n; k++) { for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) { if (dist[i][k] != INT_MAX \u0026amp;\u0026amp; dist[k][j] != INT_MAX \u0026amp;\u0026amp; dist[i][k] + dist[k][j] \u0026lt; dist[i][j] ) { dist[i][j] = dist[i][k] + dist[k][j]; fre[i][j] = fre[i][k] * fre[k][j]; } else if (dist[i][k] + dist[k][j] == dist[i][j]) fre[i][j] += fre[i][k] * fre[k][j]; } } } } // 计算顶点的影响力 vector\u0026lt;double\u0026gt; calculateInfluence(const vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt;\u0026amp; dist, int n) { vector\u0026lt;double\u0026gt; influence(n, 0.0); for (int k = 0; k \u0026lt; n; k++) { for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) { if (i != j \u0026amp;\u0026amp; i != k \u0026amp;\u0026amp; j != k \u0026amp;\u0026amp; dist[i][j] == dist[i][k] + dist[k][j]) { influence[k] += 1.0 * dist[i][j] * (fre[i][k] * fre[k][j]) / fre[i][j]; } } } } return influence; } int main() { int n, e; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; e; // 输入 vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt; dist(n, vector\u0026lt;long long\u0026gt;(n, INT_MAX)); for (int i = 0; i \u0026lt; n; i++) { dist[i][i] = 0; } // 邻接矩阵 for (int i = 0; i \u0026lt; e; i++) { int from, to, dis; cin \u0026gt;\u0026gt; from \u0026gt;\u0026gt; to \u0026gt;\u0026gt; dis; dist[from - 1][to - 1] = dis; dist[to - 1][from - 1] = dis; } floyd(dist, n); // 计算影响力 vector\u0026lt;double\u0026gt; influence = calculateInfluence(dist, n); // 输出 cout.precision(3); cout \u0026lt;\u0026lt; fixed; for (int i = 0; i \u0026lt; n; i++) { cout \u0026lt;\u0026lt; influence[i] \u0026lt;\u0026lt; endl; } return 0; } ","date":"2025 年 2 月 8 日","externalUrl":null,"permalink":"/posts/pta/","section":"","summary":"","title":"PTA","type":"posts"},{"content":"","date":"2025 年 2 月 8 日","externalUrl":null,"permalink":"/tags/%E5%8D%9A%E5%AE%A2/","section":"Tags","summary":"","title":"博客","type":"tags"},{"content":"","date":"2025 年 2 月 8 日","externalUrl":null,"permalink":"/tags/%E7%AB%99%E7%82%B9%E4%BC%98%E5%8C%96/","section":"Tags","summary":"","title":"站点优化","type":"tags"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]